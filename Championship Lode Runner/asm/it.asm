; --------------------------------------------------------------------------------------------------------------------- ;
; Championship Lode Runner - it.prg
; --------------------------------------------------------------------------------------------------------------------- ;
; Memory Map
; --------------------------------------------------------------------------------------------------------------------- ;
; $0000 - $00ff:  Zero Page
; $0400 - $07f7:  Screen Multi Color
; $07f8 - $07ff:  Sprite Pointers
; $0800 - $09c3:  Buffer Expanded level data - in game modified with loderunner/enemies/holes
; $0a00 - $0bc3:  Buffer Expanded level data - original without loderunner/enemies/holes
; $0c00 - $0cff:  Buffer Sprite Data 01
; $0d00 - $0dff:  Buffer Sprite Data 02
; $0e00 - $0ec7:  Table HiRes rows start address LO
; $0f00 - $0fc7:  Table HiRes rows start address HI
; $1000 - $10ff:  Buffer Level Data Save/Load
; $1100 - $11ff:  Buffer High Score Save/Load
; $1200 - $12ff:  Game Work Tables
; $1300 - $133b:  Game Variables
; $1400 - $1fff:  Data Start Graphic
; $2000 - $3fff:  Screen Multicolor HiRes Display
; $4000 - $5fff:  Screen Multicolor HiRes Prepare
; --------------------------------------------------------------------------------------------------------------------- ;
; $6000 - $b7ff:  Game ($5800 bytes)
; $6000 - $93ae:  Game Code
; $93af - $b4ff:  
; $9500 - $993d:  Game Data Jingles
; $993e - $b7ff:  
; $a000 - $b0ff:  Game Image Data
; $b100 - $b1c8:  Game Data Demo Move Level 01
; $b1d0 - $b2c3:  Game Data Demo Move Level 02
; $b2c4 - $b369:  Game Data Demo Move Level 03
; $b36a - $b4ff:  
; $b500 - $b5ff:  Game Data Demo Level 01
; $b600 - $b6ff:  Game Data Demo Level 02
; $b700 - $b7ff:  Game Data Demo Level 03
; --------------------------------------------------------------------------------------------------------------------- ;
; $c000 - $c0ff:  Buffer Tunes Play Time
; $c100 - $c1ff:  Buffer Tunes Data Ptr Voice 2
; $c200 - $c2ff:  Buffer Tunes Data Ptr Voice 3
; $c300 - $c3ff:  Buffer Tunes Sustain/Release/Volume (not used)
; 
; $c800 - $c8ff:  Buffer High Score Work Old
; $c900 - $c9ff:  Buffer High Score Work New
; --------------------------------------------------------------------------------------------------------------------- ;
                            * = $6000
; --------------------------------------------------------------------------------------------------------------------- ;
; compiler settings
; --------------------------------------------------------------------------------------------------------------------- ;
                            .cpu "6502"                     ; standard 65xx processor
                            
Mem                         .include "../../inc/c64.MEM.asm" ; C64 Memory layout (includes found via -I cmd line option)
; --------------------------------------------------------------------------------------------------------------------- ;
Var                         .include "../inc/CL_Var.asm"    ; Game Variables
ZPG                         .include "../inc/CL_Zpg.asm"    ; Game Zero Page Equates
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Start                     Does    : game start entry point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Start                      .block                           ; 
                            lda #$00                        ; get initial value
                            sta CL_CheatMode                ; ini cheat mode
                            sta CL_Volume                   ; ini volume to off
                            
                            lda #CL_ControllerType_Joystick ; get control type joystick
                            sta CL_ControllerType           ; ini ca=joystick  cb=keyboard
                            
                            jsr StartInitMachine            ; set up the machine
                            jsr CopyProtection              ; read in check bytes from the original disk in drive
; --------------------------------------------------------------------------------------------------------------------- ;
; read in score block and validate CL disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColdStart                 Does    : game restart in case of errors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColdStart                  .block                           ; 
                            jsr StartInitMachine            ; set up the machine
                            
                            lda #$ff                        ; get initial value
                            sta CL_Volume                   ; ini volume
                            sta CL_LodeRuFallsDown          ; ini $00=fall $20=no fall $ff=init
                            sta CL_TuneDeath                ; <obsolete> here - overwritten in next ini block
                            sta CL_LodeRuShootMode          ; ini CL_LodeRuShootMode_Front
                            
                            lda #$00                        ; get init value
                            sta CL_ColorStatus              ; ini status line color to BLACK
                            sta CL_Unused_1353              ; 
                            sta CL_TuneFreeBufferPosOff     ; ini offset to next free tune buffer byte
                            sta CL_TuneToPlayOff            ; ini offset to next tune to play
                            sta CL_LodeRuShoot              ; ini CL_LodeRuShoot_No
                            sta CL_TuneDeath                ; ini CL_TuneDeath_None
                            sta CL_KeyNew                   ; ini new key input
                            sta CL_KeyOld                   ; ini pressed key store
                            sta CL_SpriteShow               ; ini CL_SpriteShow_On
                            
                            lda #>CL_LevelDataBuf           ; get packed level data page from disk - Target: $1000-$10ff
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; ini ReadDiskData command
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; ini WriteDiskData command
                            sta CL_GoldJingleRndSeed        ; ini RND beam pos seed
                            
                            lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            sta CL_KeyOld                   ; ini pressed key store
                            
                            lda #LSTX_NONE                  ; get initial value - no key pressed
                            sta LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            
                            lda #CL_GameSpeed_Normal        ; get wait cout of 5 interupts before next move (normal speed)
                            sta CL_GameSpeed                ; ini normal speed 
                            
                            lda #CL_GameMode_Start          ; get flag show start grafic
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            jmp StartGraficOut              ; display the start grafic screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStart                 Does    : start game preparations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStart                  .block                           ; 
                            lda #$00                        ; get initial value
                            sta CL_Score_Lo                 ; ini scores
                            sta CL_Score_MidLo              ; 
                            sta CL_Score_MidHi              ; 
                            sta CL_Score_Hi                 ; 
                            sta CL_GameSpeedCtrl            ; ini game speed
                            sta CL_CirclePhase              ; <obsolete> - not used anymore
                            sta CL_EnemyBirthCol            ; ini CL_EnemyBirthCol_Min
                            sta CLZ_DemoMoveDuration        ; ini demo move duration
                            sta CLZ_DemoMoveDataPtr_Lo      ; ini demo move data pointer LO
                            
                            lda #>TabDemoMoves              ; ini demo move data pointer LO
                            sta CLZ_DemoMoveDataPtr_Hi      ; ini DemoMoveData pointer
                            sta CL_LevelReload              ; ini reload flag - force level reload if <> CL_LevelNumDisk
                            
                            lda #CL_NumLivesInit            ; get initial value
                            sta CL_NumLives                 ; ini number of lives
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; ini target output indicator - $20=$2000 $40=$4000
                            
                            jsr JingleGotAllGoldInit        ; init the jingle control data
                            jsr GraficScreenClearBoth       ; clear the display and prepare screen hires screens
                            jsr ColorLevelSelect            ; set a new color any 10th level
                            
                            lda CL_ColorLevel               ; get the actual level color
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            jsr GameUniquePlayIdSet         ; get a play ID for this session to avoid disk swap
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelStart                Does    : start a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelStart                 .block                           ; 
                            lda #BLACK                      ; get initial value
                            sta CL_ColorStatus              ; set status line color
                            
                            ldx #CL_LevelLoad_Yes           ; get flag force new copy from disk and init
                            jsr GameLevelDataExpand         ; expand compressed level disk data
                            
                            sta CL_TuneToPlayOff            ; ini offset tune to play
                            sta CL_TuneFreeBufferPosOff     ; ini offset next free tune buffer byte
                            
                            ldy CL_EnemyCount               ; get number of enemies ($00-$05)
                            lda TabEnemySpriteNum,y         ; get sprite enable value
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda #CL_JoystickMove_None       ; get initial value
                            sta CL_JoystickMoveDirY         ; ini joystick dir Y
                            sta CL_JoystickMoveDirX         ; ini joystick dir X
                            
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq MainLoopInit                ; check: demo - yes: bypass flicker
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player key - flicker loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
FlickerNextLodeRuSprt       lda SPENA                       ; VIC($D015) Sprite Enable Register
                            and #~SPENA_M0E                 ; switch off loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldy #$90                        ; get waittime LO
                            ldx #$00                        ; get waittime HI
; --------------------------------------------------------------------------------------------------------------------- ;
; black loderunner phase
; --------------------------------------------------------------------------------------------------------------------- ;
WaitLodeRuBlack             dex                             ; dec waittime LO
                            jsr PlayerCheckInput            ; look for player input
                            bcs WaitPlayerEnd               ; check: did player press something - yes
                            
                            bne WaitLodeRuBlack             ; check: min waittime LO - no: continue
                            dey                             ; dec waittime HI
                            bne WaitLodeRuBlack             ; check: min waittime HI - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch loderunner sprite on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPENA                       ; VIC($D015) Sprite Enable Register
                            ora #SPENA_M0E                  ; switch on loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldy #$90                        ; get waittime LO
                            ldx #$00                        ; get waittime HI
; --------------------------------------------------------------------------------------------------------------------- ;
; white loderunner phase
; --------------------------------------------------------------------------------------------------------------------- ;
WaitLodeRuWhite             dex                             ; dec waittime LO
                            jsr PlayerCheckInput            ; look for player input
                            bcs WaitPlayerEnd               ; check: did player press something - yes
                            
                            bne WaitLodeRuWhite             ; check: min waittime LO - no: continue
                            dey                             ; dec waittime HI
                            bne WaitLodeRuWhite             ; check: min waittime HI - no: continue
                            
                            jmp FlickerNextLodeRuSprt       ; next round - wait and flicker loderunner sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; end of wait - switch on a possibly switched off loderunner sprite
; --------------------------------------------------------------------------------------------------------------------- ;
WaitPlayerEnd               lda SPENA                       ; VIC($D015) Sprite Enable Register
                            ora #SPENA_M0E                  ; switch on loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda CL_KeyNew                   ; 
                            cmp #$8d                        ; test <CTRL> + s
                            bne MainLoopInit                ; check: EQ - no: no save
; --------------------------------------------------------------------------------------------------------------------- ;
; a game can only be saved at level start
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameSaveSlotHandler         ; save a game only at level start
; --------------------------------------------------------------------------------------------------------------------- ;
; enable enemy sprites
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CL_EnemyCount               ; get enemy count
                            lda TabEnemySpriteNum,y         ; get enemy sprite enable offset
                            sta SPENA                       ; VIC($D015) Sprite Enable Register; VIC 2 - $D015 = Sprite Enable
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoopInit              Does    : game main loop preparations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoopInit               .block                           ; 
                            ldx #CL_LodeRuShoot_No          ; get initial value
                            stx CL_LodeRuShoot              ; ini loderunner does not shoot - $00=no $01=right $ff=left
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate offset into enemy move dispatch table
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_GameSpeedCtrl            ; get game speed control value ($00-$0a)
                            clc                             ; 
                            adc CL_EnemyCount               ; add number of enemies ($00-$05)
                            tay                             ; set enemy cycle tab offset
; --------------------------------------------------------------------------------------------------------------------- ;
; fill enemy move control table - used in EnemyMoveHandler
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabEnemyMoveCyclesOff,y     ; get offsets enemy move cycles tab
                            lda TabEnemyMoveCycle_01,x      ; get enemy move cycles tab value 1
                            sta CLZ_EnemyMoveCycle_01       ; set tab value 1 
                            
                            lda TabEnemyMoveCycle_02,x      ; get enemy move cycles tab value 2
                            sta CLZ_EnemyMoveCycle_02       ; set tab value 2
                            
                            lda TabEnemyMoveCycle_03,x      ; get enemy move cycles tab value 3
                            sta CLZ_EnemyMoveCycle_03       ; set tab calue 3
                            
                            ldy CL_GameSpeedCtrl            ; get lap counter for speed up ($00-$0a)
                            lda TabEnemyInHoleTime,y        ; get time in hole tab
                            sta CL_EnemyInHoleTime          ; set enemy in hole time
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoop                  Does    : game main loop
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop                   .block                           ; 
                            jsr LodeRuMoveHandler           ; control the loderunner moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has survived his last move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LodeRuState              ; get loderunner heartbeat
                            beq GoLodeRuDeath               ; check: loderunner had an accident - yes
                            
                            lda CL_GoldToCollect            ; get gold to collect count
                            bne MainLoop_CheckLrRow         ; check: got all - no: some gold still left over
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner still alive and all gold collected
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr JingleGotAllGoldCopy        ; prepare melody
                            jsr LevelExitLadderShow         ; display exit ladders
                            jsr GameMessageTextShow         ; show the level solved msg
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on top of the screen 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CheckLrRow         lda CLZ_LodeRuRow               ; get actual row loderunner
                            bne MainLoop_CloseHoles         ; check: lodrunner on top row - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on mid of image 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner pos on image left/right
                            cmp #CLZ_LodeRuOnImgPosY_Mid    ; test center of screen image
                            bne MainLoop_CloseHoles         ; check: center of screen image - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; all gold must be collected - level completed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_GoldToCollect            ; get number of gold to collect for this level
                            beq LevelComplete               ; check: got all gold - yes: level finished successfully
                            cmp #$ff                        ; test -1
                            beq LevelComplete               ; check: got all gold plus one - yes: level finished successfully
; --------------------------------------------------------------------------------------------------------------------- ;
; continue play
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CloseHoles         jsr GameCloseHoles              ; close open holes and eventually kill trapped loderunner and enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner survived the close hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LodeRuState              ; get loderunner heartbeat 
GoLodeRuDeath               beq LodeRuDeath                 ; check: loderunner was trapped in a hole - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; move next enemy - one by one
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveHandler            ; control all enemy moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LodeRuState              ; get loderunner heartbeat 
                            beq LodeRuDeath                 ; check: loderunner was cought by an enemy - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; wait a bit
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_Delay              lda CL_CountIRQs                ; get wait counter (inc'd every IRQ)
                            cmp CL_GameSpeed                ; test with game speed
                            bcc MainLoop_Delay              ; check: lower - yes: wait
                            
                            lda #CL_CountIRQs_Init          ; get initial value
                            sta CL_CountIRQs                ; ini wait counter (inc'd every IRQ)
                            
                            jmp MainLoop                    ; continue the endless loop
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelComplete             Does    : prepare for next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelComplete              .block                           ; 
                            inc CL_LevelNumGame             ; inc game level number 001-050
                            inc CL_LevelNumDisk             ; inc disk level number 000-049
; --------------------------------------------------------------------------------------------------------------------- ;
; finish the actual game tune
; --------------------------------------------------------------------------------------------------------------------- ;
WaitTuneFinished            lda CL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp CL_TuneToPlayOff            ; test still playing
                            bne WaitTuneFinished            ; check: tune still playing - yes: continue wait
                            
                            jsr JingleGotAllGoldNext        ; set the next level completed jingle
; --------------------------------------------------------------------------------------------------------------------- ;
; increase loderunner number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_NumLives                 ; 
                            bne ScoreTuneIni                ; check: maximum - no: bypass adaptation
                            
                            dec CL_NumLives                 ; ensure a max of $ff (255)
; --------------------------------------------------------------------------------------------------------------------- ;
; init level end scoring tune - each dec of CLZ_SfxScoreSub scores 100 points
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneIni                lda #CLZ_SfxScoreSub_Start      ; get init score tune subtraction value
                            sta CLZ_SfxScoreSub             ; set substraction value
                            
                            sei                             ; disallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; increase score whilst the scoring tune gets higher and higher
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneNext               lda #CLZ_SfxScoreSub_Base       ; get base tune value 
                            sec                             ; 
                            sbc CLZ_SfxScoreSub             ; 
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            ldy #$2c                        ; get wait time LO
ScoreWaitTuneGetNextHi      ldx #$00                        ; get wait time HI
ScoreWaitTuneDecNextLo      dex                             ; dec wait time LO
                            bne ScoreWaitTuneDecNextLo      ; check: min - no: continue
                            dey                             ; dec wait time HI
                            bne ScoreWaitTuneGetNextHi      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch tune off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; score next 100
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; $00 - score add value LO - each time tick scores 100 points
                            iny                             ; $01 - score add value HI
                            jsr StatusOutScore              ; score and update status row
; --------------------------------------------------------------------------------------------------------------------- ;
; dec until CL_Score_FinishLevel points are scored
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_SfxScoreSub             ; sub value - tune gets higher and higher
                            bpl ScoreTuneNext               ; check: underflow - no: continue
                            
                            cli                             ; reallow interrupts
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi GoLevelStart                ; check: championship LR - no: old LR
                            
                            lda CL_LevelNumGame             ; get game level number 001-050
                            cmp #CL_LevelNumGame_Max        ; test 051
                            bcc GoLevelStart                ; check: start a new level
                            
                            jmp GameOver                    ; finish after last level
; --------------------------------------------------------------------------------------------------------------------- ;
GoLevelStart                jmp LevelStart                  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuDeath               Does    : discount loderunner lives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuDeath                .block                           ; 
                            dec CL_NumLives                 ; subtract from lives
                            
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            bne LodeRuDeathTune             ; check: demo - no: play death tune
                            
                            jmp DemoVolumeHandler           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuDeathTune             lda #CL_TuneDeath_Ini           ; get initial value
                            sta CL_TuneDeath                ; ini death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; complete running jingles
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForGameTunesFinish      lda CL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp CL_TuneToPlayOff            ; test with tune to play offset
                            bne WaitForGameTunesFinish      ; check: finished - no: wait for all in game tunes to be finished
; --------------------------------------------------------------------------------------------------------------------- ;
; reset values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_LodeRuShoot_No          ; get shoot off
                            sta CL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            lda #CL_LodeRuFallsDown_No      ; get flag no fall
                            sta CL_LodeRuFallsDown          ; set $00=fall $20=no fall $ff=init
                            
                            jsr StatusOutLives              ; write out remaining number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
; complete funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForDeathTuneEnd         lda CL_TuneDeath                ; get death tune value
                            bne WaitForDeathTuneEnd         ; check: min - no: continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
; check number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_NumLives                 ; get number of lives
                            bne LevelComplete.GoLevelStart  ; check: all used up - no: continue game with one live less
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOver                  Does    : spin game over sign and wait for restart or demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOver                   .block                           ; 
                            jsr ScoreEntryHandler           ; 
                            jsr GameNewChampionHandler      ; care for a new champion
                            bcs DemoWaitInit                ; check: new champ - yes
                            
                            jsr GameOverSpinSign            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init wait for demo or player input
; --------------------------------------------------------------------------------------------------------------------- ;
DemoWaitInit                ldx #$ff                        ; get wait time LO
                            ldy #$ff                        ; get wait time MID
                            
                            bcs DemoWaitIniCounter_Hi       ; check: player break during flip
; --------------------------------------------------------------------------------------------------------------------- ;
; reset player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; init wait counter HI
; --------------------------------------------------------------------------------------------------------------------- ;
DemoWaitIniCounter_Hi       lda #$03                        ; get wait time HI
                            sta CLZ_WaitForDemoCounter      ; set wait time HI
                            
DemoWaitPlayerInput         lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check quick start joystick
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq GameStartInit               ; check: EQ - yes: immediately start the game
                            
                            lda CL_KeyNew                   ; get key pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check load a saved game
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$aa                        ; test <CTRL> + l(oad)
                            bne CheckShowLeaderboard        ; check: EQ - no
                            
                            jsr GameLoad                    ; load a game from the save game list
; --------------------------------------------------------------------------------------------------------------------- ;
; check show leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
CheckShowLeaderboard        cmp #$01                        ; test <ENTER>
                            beq DemoHighScoreHandler.GoScoreShowLeaderboard ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check clear leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$94                        ; test <CTRL> + c(lear) leaderboard
                            beq DemoHighScoreHandler.GoClrHighScores ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check quick start keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$3c                        ; test <SPACE>
                            beq GameStartInit               ; check: EQ - yes: immediately start the game
; --------------------------------------------------------------------------------------------------------------------- ;
; continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
                            dex                             ; count down wait time LO
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dey                             ; count down wait time MID
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dec CLZ_WaitForDemoCounter      ; count down wait time HI
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
; --------------------------------------------------------------------------------------------------------------------- ;
; wait time is over without any player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            bne DemoHighScoreHandler        ; check: start_screen - no
; --------------------------------------------------------------------------------------------------------------------- ;
; init start demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$01                        ; get initial value
                            stx CL_GameMode                 ; ini CL_GameMode_Demo - $00=start_screen $01=demo $02=play
                            stx CL_LevelNumGame             ; ini game level number 001-050
                            stx CLZ_DemoNoFunction          ; ini flag - used but has no function
                            stx CL_Cheated                  ; ini CL_Cheated_No
                            
                            ldx CL_Volume                   ; get volume
                            stx DemoVolumeHandler.smSetVolume ; set game volume
                            
                            lda #$00                        ; get demo volume off
                            sta CL_Volume                   ; set demo volume off
                            sta CL_LevelNumDisk             ; set disk level number 000-049 - 1st demo level
                            
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoVolumeHandler         Does    : control game volume
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoVolumeHandler          .block                           ; 
smSetVolume                 = * + $01                       ; 
                            lda #CL_Volume_Off              ; get modified game volume
                            sta CL_Volume                   ; set game volume
                            
                            jmp GameOver.DemoWaitInit       ; init wait for demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHighScoreHandler      Does    : show the leaderboard of ten entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHighScoreHandler       .block                           ; 
                            cmp #CL_GameMode_Demo           ; test demo mode
                            bne DemoShowStartGraphic        ; check: was demo - no: show start graphic screen
; --------------------------------------------------------------------------------------------------------------------- ;
; show leaderboard after the demo
; --------------------------------------------------------------------------------------------------------------------- ;
GoScoreShowLeaderboard      jsr ScoreShowLeaderboard        ; show leaderboard
                            
                            lda #CL_GameMode_Play           ; get play mode
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            clc                             ; force new key reset
                            jmp GameOver.DemoWaitInit       ; init wait for demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoShowStartGraphic        lda #$00                        ; get initial value
                            sta CL_LevelNumDisk             ; ini disk level number 000-049
                            sta CL_GameMode                 ; ini game mode - $00=start_screen $01=demo $02=play
                            
                            jmp StartGraficOut              ; display the start grafic screen
; --------------------------------------------------------------------------------------------------------------------- ;
GoClrHighScores             jsr GameClearHighScores         ; clear disk leaderboard
                            jmp GoScoreShowLeaderboard      ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStartInit             Does    : initialize game (re)start values
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStartInit              .block                           ; 
                            ldx #CL_LevelNumDisk_Min        ; get initial value
                            stx CL_LevelNumDisk             ; ini disk level number 000-049
                            
                            inx                             ; 
                            stx CL_LevelNumGame             ; set game level number 001-050
                            stx CL_Cheated                  ; set CL_Cheated_No
                            
                            lda #CL_GameMode_Play           ; get play mode
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            lda #CL_Volume_Max              ; get switch on volume again
                            sta CL_Volume                   ; set volume
                            
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesOff       = * ; 
                            .byte TabEnemyMoveCyclesBlock_00 - TabEnemyMoveCycles ; 00 - $00
                            .byte TabEnemyMoveCyclesBlock_01 - TabEnemyMoveCycles ; 01 - $03
                            .byte TabEnemyMoveCyclesBlock_02 - TabEnemyMoveCycles ; 02 - $06
                            .byte TabEnemyMoveCyclesBlock_03 - TabEnemyMoveCycles ; 03 - $09
                            .byte TabEnemyMoveCyclesBlock_04 - TabEnemyMoveCycles ; 04 - $0c
                            .byte TabEnemyMoveCyclesBlock_05 - TabEnemyMoveCycles ; 05 - $0f
                            .byte TabEnemyMoveCyclesBlock_06 - TabEnemyMoveCycles ; 06 - $12
                            .byte TabEnemyMoveCyclesBlock_07 - TabEnemyMoveCycles ; 07 - $15
                            .byte TabEnemyMoveCyclesBlock_08 - TabEnemyMoveCycles ; 08 - $18
                            .byte TabEnemyMoveCyclesBlock_09 - TabEnemyMoveCycles ; 09 - $1b
                            .byte TabEnemyMoveCyclesBlock_0a - TabEnemyMoveCycles ; 0a - $1e
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyInHoleTime          = *       ; 
                            .byte $26 ; $00
                            .byte $26 ; $01
                            .byte $2e ; $02
                            .byte $44 ; $03
                            .byte $47 ; $04
                            .byte $49 ; $05
                            .byte $4a ; $06
                            .byte $4b ; $07
                            .byte $4c ; $08
                            .byte $4d ; $09
                            .byte $4e ; $0a
                            .byte $4f ; $0b
                            .byte $50 ; $0c
                            .byte $51 ; $0d
                            .byte $52 ; $0e
                            .byte $53 ; $0f
                            .byte $54 ; $10
                            .byte $55 ; $11
                            .byte $56 ; $12
                            .byte $57 ; $13
                            .byte $58 ; $14
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartGraficOut            Does    : display the start grafic screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartGraficOut             .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_BLACK_BLACK             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1) - screen size 40*25
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_BMM_ON              ; switch on Bitmap Mode (BMM)
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; set charset location
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda VMCSB                       ; VIC($D018) VIC Chip Memory Control
                            and #~(VMCSB_CB_MASK | %00000001) ; clear char set location part
                            ora #VMCSB_CB_2000              ; chr generator to video base + 2000-3fff
                            sta VMCSB                       ; VIC($D018) VIC Chip Memory Control
; --------------------------------------------------------------------------------------------------------------------- ;
; set start grafic hires colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta CL_StartGfxTabOff           ; ini start table offset
                            
GetNextGfxCounter           ldx CL_StartGfxTabOff           ; get table offset
                            inc CL_StartGfxTabOff           ; inc table offset
                            
                            lda TabStartGfxOutLo,x          ; get screen target address LO
                            sta smColorOut_Lo               ; set screen target address LO
                            
                            lda TabStartGfxColorOutHi,x     ; get screen target address HI
                            sta smColorOut_Hi               ; set screen target address HI
                            
                            lda TabStartGfxColorAmount,x    ; get color count
                            tay                             ; set as offset
                            
                            lda TabStartGfxColor,x          ; get color
                            beq StartGraphicPicture         ; check: EoT - yes: finished with colors
                            
smColorOut_Lo               = * + $01                       ; 
smColorOut_Hi               = * + $02                       ; 
SetNextGfxColor             sta CL_ScreenStartGfx,y         ; set color to hires color screen
                            
                            dey                             ; dec color count
                            cpy #$ff                        ; test min
                            bne SetNextGfxColor             ; check: EQ - no: continue
                            
                            jmp GetNextGfxCounter           ; continue
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabStartGfxOutLo            = *          ; 
                            .byte <$0405 ; Broderbund Software Presents
                            .byte <$0505 ; 
                            .byte <$0521 ; Championship Loderunner
                            .byte <$0621 ; 
                            .byte <$06ba ; by
                            .byte <$0727 ; Dough Smith and Dane Bigham
                            .byte <$077c ; (c) 1983, 1984
; --------------------------------------------------------------------------------------------------------------------- ;
TabStartGfxColorOutHi       = *          ; 
                            .byte >$0405 ; Broderbund Software Presents
                            .byte >$0505 ; 
                            .byte >$0521 ; Championship Loderunner
                            .byte >$0621 ; 
                            .byte >$06ba ; by
                            .byte >$0727 ; Dough Smith and Dane Bigham
                            .byte >$077c ; (c) 1983, 1984
; --------------------------------------------------------------------------------------------------------------------- ;
TabStartGfxColorAmount      = *          ; 
                            .byte $ff    ; 
                            .byte $09    ; 
                            .byte $ff    ; 
                            .byte $82    ; 
                            .byte $68    ; 
                            .byte $41    ; 
                            .byte $37    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabStartGfxColor            = *           
                            .byte HR_CYAN_BLACK    ; Broderbund Software Presents
                            .byte HR_CYAN_BLACK    ; 
                            .byte HR_WHITE_BLACK   ; Championship Loderunner
                            .byte HR_WHITE_BLACK   ; 
                            .byte HR_YELLOW_BLACK  ; by
                            .byte HR_CYAN_BLACK    ; Dough Smith and Dane Bigham
                            .byte HR_LT_GREY_BLACK ; (c) 1983, 1984
                            
                            .byte $00  ; End of Table marker
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartGraphicPicture       Does    : 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartGraphicPicture        .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1) - screen size 40*25
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            and #SCROLX_MCM_OFF             ; Multi Color Mode (MCM) off
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; init start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CL_StartGfxData           ; get start gfx in memory LO
                            sta CLZ_ScreenGfxPtr_Lo         ; set start gfx in ptr LO
                            lda #>CL_StartGfxData           ; get start gfx in memory HI
                            sta CLZ_ScreenGfxPtr_Hi         ; set start gfx in ptr HI
                            
                            lda #<CL_ScreenGfxDisplay - $01 ; get display screen address LO
                            sta CLZ_StartGfxDisplay_Lo      ; set start gfx output ptr LO
                            
                            lda #>CL_ScreenGfxDisplay - $01 ; get display screen address HI
                            sta CLZ_StartGfxDisplay_Hi      ; set start gfx output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextGfxDataInPair        ldy #$00                        ; get offset to gfx data byte count
                            lda (CLZ_ScreenGfxPtr),y        ; get gfx data byte count
                            sta CLZ_WorkStartGfxDataCount   ; set gfx data byte count
                            
                            iny                             ; set offset to gfx data byte
                            lda (CLZ_ScreenGfxPtr),y        ; get gfx data byte
                            sta CLZ_WorkStartGfxData        ; set gfx data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance gfx data pointer to next gfx data pair
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_ScreenGfxPtr_Lo         ; get grafic output ptr LO
                            clc                             ; 
                            adc #CL_StartGfxDataPtr_Len     ; add compressed data length
                            sta CLZ_ScreenGfxPtr_Lo         ; set grafic output ptr LO
                            bcc GetGfxCountAndDataByte      ; check: overflow - no
                            inc CLZ_ScreenGfxPtr_Hi         ; inc grafic output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
; output the next start grafic data bytes
; --------------------------------------------------------------------------------------------------------------------- ;
GetGfxCountAndDataByte      lda CLZ_WorkStartGfxDataCount   ; get gfx data byte count
                            tay                             ; set gfx data byte count as offset
                            lda CLZ_WorkStartGfxData        ; get gfx data byte
                            
SetNextStartGfxDataByte     sta (CLZ_StartGfxDisplay),y     ; set start grafic data
                            dey                             ; dec gfx data byte count
                            bne SetNextStartGfxDataByte     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; advance start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_StartGfxDisplay_Lo      ; get next start grafic pos LO
                            clc                             ; 
                            adc CLZ_WorkStartGfxDataCount   ; add old offset
                            sta CLZ_StartGfxDisplay_Lo      ; set next start grafic pos LO
                            bcc ChkEndOfCopy                ; check: overflow - no
                            inc CLZ_StartGfxDisplay_Hi      ; inc next start grafic pos HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check end of start grafic expand
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfCopy                lda CLZ_StartGfxDisplay_Hi      ; get start grafic pos HI
                            cmp #>CL_ScreenGfxDisplayEnd    ; test maximum
                            bcc GetNextGfxDataInPair        ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; output a possible top scorers values and wait for demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0d                        ; get output row number
                            jsr ScoreShowTopScorer          ; show a possible top scorers message and score
                            jmp GameOver.DemoWaitInit       ; init wait for demo - .C set forces new key reset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_PlayTunes             Does    : play the tune available in IRQ tune buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunes              .block                           ; 
                            ldx CL_TuneToPlayOff            ; get tune buffer offset
                            cpx CL_TuneFreeBufferPosOff     ; test with next free tune buffer offset
                            beq IRQ_PlayTunesOff            ; check: EQ - yes: all tunes completed - exit
                            
                            lda #CNTRL3_GATE_ADS | CNTRL3_TRI ; get start attack decay sustain/triangle wave
                            sta CL_WaveVoice2               ; set wave form voice 2
                            sta CL_WaveVoice3               ; set wave form voice 3
                            
                            lda CL_TuneSuReVol,x            ; get tune s/r/volume - not used
                            
                            lda #STNRIS2_STN_MASK           ; get sustain voice 2
                            and CL_Volume                   ; isolate sustain volume level
                            sta SUREL2                      ; SID($D40D) Oscillator 2 Sustain/Release
                            sta SUREL3                      ; SID($D414) Oscillator 3 Sustain/Release
                            
                            lda CL_TuneDataPtrVoice2,x      ; get new tab tune data pointer voice 2
                            bne SetFreqCtrlDataTableOff     ; check: none - yes
                            
                            sta CL_WaveVoice2               ; set new tab tune data pointer voice 2
                            
SetFreqCtrlDataTableOff     tay                             ; set as offset
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sta FRELO2                      ; SID($D407) Oscillator 2 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sta FREHI2                      ; SID($D408) Oscillator 2 Freq Ctrl (HI byte)
                            
                            lda CL_TuneDataPtrVoice3,x      ; get tab tune data pointer voice 3
                            bpl ChkTuneDataPtrZero          ; check: positive - yes
                            
                            lda CL_TuneDataPtrVoice2,x      ; get tab tune data pointer voice 2
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set decreased freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sbc #$80                        ; decrease
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sbc #$00                        ; subtract .C
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
                            
                            jmp SetVoiceCtrlData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTuneDataPtrZero          bne SetAsOffset                 ; check: zero - no
                            
                            sta CL_WaveVoice3               ; set tune data for voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; set freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
SetAsOffset                 tay                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq ctrl data LO
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq ctrl data HI
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice control data for voice 2/voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
SetVoiceCtrlData            lda CL_WaveVoice2               ; get tune control data for voice 2
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            
                            lda CL_WaveVoice3               ; get tune control data for voice 3
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; dec playtime
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CL_TunePlayTime,x           ; dec tune play time
                            bne IRQ_PlayTunesX              ; check: end of tune - no: exit - continue this one
; --------------------------------------------------------------------------------------------------------------------- ;
; set next tune to play
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_TuneToPlayOff            ; set offest to next tune to play
                            
IRQ_PlayTunesX              rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunesOff            lda #$00                        ; get reset value
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuSetGetGoldJingle    Does    : fill the IRQ tune buffer with get gold jingle
;                           Expects : 
;                           Returns : 
;                           Remark  : jingle is played with IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuSetGetGoldJingle     .block                           ; 
                            pla                             ; 
                            sta CLZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            pla                             ; 
                            sta CLZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne IncJingleDataPtr            ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; copy next jingle part value to tune buffers
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBuf      sei                             ; disable interrupts - do not play any jingle now
; --------------------------------------------------------------------------------------------------------------------- ;
; a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial offset
                            lda (CLZ_JingleDataPtr),y       ; get 1st jingle data block byte
                            beq PutNextJingleByteToBufX     ; check: EoD - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st byte: fill time buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta CL_TunePlayTime,x           ; set tab jingle time
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd byte: fill voice 2 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (CLZ_JingleDataPtr),y       ; get 2nd jingle data block byte
                            sta CL_TuneDataPtrVoice2,x      ; set tab jingle data pointer voice 2
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd byte: fill voice 3 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (CLZ_JingleDataPtr),y       ; get 3rd jingle data block byte
                            sta CL_TuneDataPtrVoice3,x      ; set tab jingle data pointer voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; 4th byte: fill sustain/release/volume buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (CLZ_JingleDataPtr),y       ; get 4th jingle data block byte
                            sta CL_TuneSuReVol,x            ; set tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next jingle block of data
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_TuneFreeBufferPosOff     ; inc offset next free tune buffer byte
                            lda CLZ_JingleDataPtr_Lo        ; get jingle data pointer LO
                            clc                             ; 
                            adc #LodeRuGetGold.TabGoldJinglePart_Len ; add tune part table length
                            sta CLZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            
                            lda CLZ_JingleDataPtr_Hi        ; get jingle data pointer HI
                            adc #$00                        ; add .C
                            sta CLZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
IncJingleDataPtr            inc CLZ_JingleDataPtr_Lo        ; inc jingle data pointer LO
                            bne PutNextJingleByteToBuf      ; check: overflow - no
                            inc CLZ_JingleDataPtr_Hi        ; inc jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push jingle data pointer to stack - thus return to code directly following jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBufX     lda CLZ_JingleDataPtr_Hi        ; get pointer jingle data end HI
                            pha                             ; push as return address
                            
                            lda CLZ_JingleDataPtr_Lo        ; get pointer jingle data end LO
                            pha                             ; push as return address
                            
                            cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; return to instruction directly after end of jingle data
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGoldJingleVal    Does   : return RND raster beam position within given limits
;                           Expects : .A=bottom limit
;                                   : .X=lower limit
;                                   : .Y=upper limit
;                           Returns : .A=raster beam position within limits
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGoldJingleVal     .block                           ; 
                            sta CL_GoldJingleBeamLimit      ; save bottom limit
                            
GetNextRasterBeamPos        lda RASTER                      ; VIC($D012) Read: Current Raster Scan Line (Bit 8 in SCROLY = $D011)
                            sta CL_GoldJingleBeamPos        ; set beam pos
                            
                            cpx CL_GoldJingleBeamPos        ; test beam pos lower limit
                            bcc ChkUpperLimit               ; check: LT - yes
                            beq ChkUpperLimit               ; check: EQ - yes
                            
                            jmp GetNextRasterBeamPos        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpy CL_GoldJingleBeamPos        ; test beam pos upper limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; raster beam value is between upper and lower limit
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc CL_GoldJingleRndSeed        ; 
                            bcs ChkBottomLimit              ; check: underflow - no
                            
                            eor #$ff                        ; set ones complement - make positive
                            adc #$01                        ; 
                            
ChkBottomLimit              cmp CL_GoldJingleBeamLimit      ; test limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes: get next beam pos
                            
                            lda CL_GoldJingleBeamPos        ; get correct beam pos
                            sta CL_GoldJingleRndSeed        ; set new seed
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldInit      Does    : initialize the jingle control data
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldInit       .block                           ; 
                            lda TabJingleMaxNum             ; get initial value
                            sta CL_JingleNum                ; set jingle count
                                                              
                            lda TabJingleHeight_Min         ; get initial value
                            sta CL_JingleHeight             ; ini jingle height
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldNext      Does    : set the next got all gold jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldNext       .block                           ; 
                            dec CL_JingleNum                ; set next Jingle number
                            bpl JingleGotAllGoldNextX       ; check: underflow - no: exit
                            
                            inc CL_JingleHeight             ; inc Jingle height
                            
                            lda CL_JingleHeight             ; get Jingle height
                            cmp TabJingleHeight_Max         ; test max
                            bcc SetJingleMaxNum             ; check: LT - no: set Jingle to max
                            
                            lda TabJingleHeight_Min         ; get min height
                            sta CL_JingleHeight             ; set height to min again
                            
SetJingleMaxNum             lda TabJingleMaxNum             ; get initial value
                            sta CL_JingleNum                ; ini jingle number
                            
JingleGotAllGoldNextX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldCopy      Does    : fill the tune buffers with the data for the all gold collected jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldCopy       .block                           ; 
                            lda CL_JingleNum                ; get Jingle number
                            asl a                           ; *2 for pointer length
                            tax                             ; set Jingle data pointer table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set jingle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabJingleDataPtr_Lo,x       ; get pointer to Jingle data LO
                            sta CLZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            lda TabJingleDataPtr_Hi,x       ; get pointer to Jingle data HI
                            sta CLZ_JingleDataPtr_Hi        ; set Jingle data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextJingleDataBlock      sei                             ; disable interrupts - do not play any jingle now
                            
                            ldy #$00                        ; get offset Jingle data
                            lda (CLZ_JingleDataPtr),y       ; get Jingle data for play time
                            beq JingleGotAllGoldCopyX       ; check: end of data - yes: exit
                            
                            ldx CL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta CL_TunePlayTime,x           ; set tune play time
                            
                            iny                             ; advance offset Jingle data
                            lda (CLZ_JingleDataPtr),y       ; get Jingle data for voice 2
                            beq SetTuneDataVoice2           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc CL_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice2           sta CL_TuneDataPtrVoice2,x      ; set tab tune data pointer voice 2
                            
                            iny                             ; advance offset Jingle data
                            lda (CLZ_JingleDataPtr),y       ; get Jingle data for voice 3
                            beq SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            bmi SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc CL_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice3           sta CL_TuneDataPtrVoice3,x      ; set tab tune data pointer voice 3
                            
                            iny                             ; advance offset Jingle data
                            lda (CLZ_JingleDataPtr),y       ; get Jingle data for sustain/release/volume
                            sta CL_TuneSuReVol,x            ; set tune s/r/volume  (not used)
                            
                            inc CL_TuneFreeBufferPosOff     ; inc offset to next free tune buffer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance Jingle data pointer - a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_JingleDataPtr_Lo        ; get Jingle data pointer LO
                            clc                             ; 
                            adc #TabJingleDataBlock_Len     ; add entry block length
                            sta CLZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            
                            lda CLZ_JingleDataPtr_Hi        ; get data pointer HI
                            adc #$00                        ; add .C
                            sta CLZ_JingleDataPtr_Hi        ; set data pointer HI
                            
                            bne GetNextJingleDataBlock      ; always (hopefully)
                            
JingleGotAllGoldCopyX       cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ                       Does    : loderunner IRQ routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ                        .block                           ; 
                            inc CL_CountIRQs                ; inc wait counter (inc at every IRQ)
                            
                            lda #$00                        ; get initial value
                            sta CLZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            lda CL_Volume                   ; get volume
                            and #MODEVOL_VOL_MASK           ; isolate volume
                            sta MODEVOL                     ; SID($D418) Volume/Filter Select
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
                            bne InitFallBeep                ; check: not falling - yes
                            
                            ldx CL_TuneBeepFall             ; get fall beep
                            stx CLZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            jmp CheckLodeRuShoot            ; check for shooting
; --------------------------------------------------------------------------------------------------------------------- ;
InitFallBeep                lda #CL_TuneBeepFall_Start      ; get initial value
                            sta CL_TuneBeepFall             ; set fall beep start value
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is shooting
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuShoot            lda CL_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq InitShootTune               ; check: no shoot - yes
                            
                            lda CL_TuneShoot                ; get actual shoot tune value
                            sec                             ; 
                            sbc #CL_TuneShoot_Step          ; step tune value down
                            sta CL_TuneShoot                ; set actual shoot tune value
                            sta CLZ_TuneValueVoice_01       ; set tune value voice 1
                            beq InitShootTune               ; check: zero - yes: reinit
                            
                            jmp CheckLodeRuDeath            ; check for death
; --------------------------------------------------------------------------------------------------------------------- ;
InitShootTune               lda #CL_TuneShoot_Start         ; get 
                            sta CL_TuneShoot                ; set 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has died
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuDeath            lda CL_TuneDeath                ; get actual death tune
                            beq GetTuneValueToPlay          ; check: death - no
                            
                            sec                             ; 
                            sbc #CL_TuneDeath_Step          ; step tune value down
                            sta CLZ_TuneValueVoice_01       ; set tune value voice 1
                            sta CL_TuneDeath                ; set actual death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; play tune
; --------------------------------------------------------------------------------------------------------------------- ;
GetTuneValueToPlay          lda CLZ_TuneValueVoice_01       ; get tune value voice 1
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            jsr IRQ_PlayTunes               ; play the tune available in IRQ tune buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            bne ChkKeyNone                  ; check: <INS/DEL> - no
                            
                            lda #$07                        ; get <CURSOR DOWN>
                            
ChkKeyNone                  cmp #LSTX_NONE                  ; test no key pressed
                            bne GetFlagShiftKey             ; check: a key pressed - yes
                            
                            lda #$00                        ; get initial value
                            sta CL_KeyOld                   ; ini pressed key store
                            
                            jmp KEY                         ; continue with main KERNAL IRQ entry point
; --------------------------------------------------------------------------------------------------------------------- ;
GetFlagShiftKey             pha                             ; save .A
                            
                            lda SHFLAG                      ; <SHIFT> key indicator - $01=shift $02=commodore $04=ctrl
                            and #SHFLAG_CTRL                ; isolate <CTRL>
                            tax                             ; save result
                            
                            pla                             ; restore .A
                            
                            cpx #SHFLAG_CTRL                ; test <CTRL>
                            bne ChkKeyOld                   ; check: EQ - no: bypass set <SHIFT> flag
                            
                            ora #$80                        ; set bit7 - mark shifted key input
                            
ChkKeyOld                   cmp CL_KeyOld                   ; test pressed key store
                            beq GoMainIRQ                   ; check: EQ key got - yes: bypass store
                            
                            sta CL_KeyOld                   ; set pressed key store
                            sta CL_KeyNew                   ; set new key
                            
GoMainIRQ                   jmp KEY                         ; continue with main KERNAL IRQ entry point
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartInitMachine          Does    : set up the machine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartInitMachine           .block                           ; 
                            lda R6510                       ; 6510 On-Chip I/O Data
                            and #%11000000 | LORAM_BASIC_OFF; switch basic off
                            sta R6510                       ; 6510 On-Chip I/O Data
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner bit-mapped memory
;   $19 blocks ($00-$18)
;     each block contains $140 (320) bytes and controls $08 horizontal pixel rows
;     every 8th Y-value starts a new block of $140 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
;   byte number of the 1st byte in any block (X=pixel col number/Y=row number)
;     320*(INT(Y/8))
;   byte number contaning the requested hires bit
;     320*(INT(Y/8)) + (Y AND 7) + 8*(INT(X/8))
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
;       X !  Column $00  !  column $01  !  column $02  !     !  column $26  !  column $27  ! 
; Y       ! byte  number ! byte  number ! byte  number !     ! byte  number ! byte  number ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $00 !     0000     !     0008     !    0010      ! ... !     0130     !     0138     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $00
; row $07 !     0007     !     000f     !    0017      ! ... !     0137     !     013f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $08 !     0140     !     0148     !    0150      ! ... !     0282     !     0278     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $01
; row $0f !     0147     !     014f     !    0157      ! ... !     0277     !     027f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; ...     !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! 
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c0 !     1e00     !     1e08     !    1e10      ! ... !     1f30     !     1f38     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $18
; row $c7 !     1e07     !     1e0f     !    1e17      ! ... !     1f37     !     1f3f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; block $19 not used
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c8 !     1f40     !     1f48     !    1f50      ! ... !     1f00     !     1f08     !  
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $19
; row $cf !     1f47     !     1f4f     !    1f57      ! ... !     1f07     !     1fff     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
; init values of the tables containing the HiRes pixel row start addresses
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get intial value LO
                            sta CLZ_WorkHiresRowStartAdr_Lo ; ini work grafic row start address LO
                            lda #$00                        ; get initial value HI <obsolete>
                            sta CLZ_WorkHiresRowStartAdr_Hi ; ini work grafic row start address HI
                            
                            ldy #$00                        ; ini offset tab grafic row start pointer tab
                            
                            lda #VICSCN_NLINES              ; get hires block count (25)
                            sta CL_HiresBlockCount          ; ini hires block count (25*320 bytes)
; --------------------------------------------------------------------------------------------------------------------- ;
; create tables with HI/LO start addresses of $c8 HiRes rows forming $19 blocks of $08 stacked pixel rows
; --------------------------------------------------------------------------------------------------------------------- ;
; $0e00: block $00 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $00
; $0e08: block $01 LO - $40 $41 $42 $43 $44 $45 $46 $47 - start address LO - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0ec0: block $18 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
; $0f00: block $00 HI - $00 $00 $00 $00 $00 $00 $00 $00 - start address HI - $08 pixel rows of block $00
; $0f08: block $01 HI - $01 $01 $01 $01 $01 $01 $01 $01 - start address HI - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0fc0: block $18 HI - $1e $1e $1e $1e $1e $1e $1e $1e - start address HI - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextBlockRowCount        ldx #$08                        ; ini count stacked bytes per block
GetNextTabPairValue         lda CLZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            sta CL_HiresRowStartPtrTab_Hi,y ; set tab grafic row start address HI
                            
                            lda CLZ_WorkHiresRowStartAdr_Lo ; get work grafic row start address LO
                            sta CL_HiresRowStartPtrTab_Lo,y ; set tab grafic row start address LO
                            
                            inc CLZ_WorkHiresRowStartAdr_Lo ; inc work grafic row start address LO
                            
                            iny                             ; inc offset tab grafic row start pointer tab
                            dex                             ; dec count stacked bytes per block
                            bne GetNextTabPairValue         ; check: count stacked bytes per block min - no: contiinue
                            
                            clc                             ; .A=work grafic row start pointer LO
                            adc #<$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta CLZ_WorkHiresRowStartAdr_Lo ; set work grafic row start address LO
                            
                            lda CLZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            adc #>$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta CLZ_WorkHiresRowStartAdr_Hi ; set work grafic row start address HI
                            
                            dec CL_HiresBlockCount          ; dec hires block count
                            bne GetNextBlockRowCount        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set NMI vector to a simple RTI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<NMI                       ; get start of NMI routine LO
                            sta NMINV_LO                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)
                            lda #>NMI                       ; get start of NMI routine HI
                            sta NMINV_HI                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)
                            
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #BLACK                      ; get color
                            sta BGCOL0                      ; VIC($D021) Background Color 0
                            sta EXTCOL                      ; VIC($D020) Border Color
; --------------------------------------------------------------------------------------------------------------------- ;
; set IRQ vector - handles all ingame tunes
; --------------------------------------------------------------------------------------------------------------------- ;
                            sei                             ; 
                            lda #<IRQ                       ; 
                            sta CINV_LO                     ; Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31);
                            lda #>IRQ                       ; 
                            sta CINV_HI                     ; Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31); irq vector
                            cli                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; ini SID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$b0                        ; get initial value
                            sta SUREL1                      ; SID($D406) Oscillator 1 Sustain/Release
                            
                            lda #CNTRL1_TRI | CNTRL1_GATE_ADS ; get initial value
                            sta VCREG1                      ; SID($D404) Oscillator 1 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; ini sprites
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_SpriteData / SPRT_BLK_LEN ; get sprite storage pointer
                            stx CL_SpritePtr_00             ; set sprite 0 data pointer to CL_SpriteData + $00
                            inx                             ; 
                            stx CL_SpritePtr_02             ; set sprite 2 data pointer to CL_SpriteData + $40
                            inx                             ; 
                            stx CL_SpritePtr_03             ; set sprite 3 data pointer to CL_SpriteData + $80
                            inx                             ; 
                            stx CL_SpritePtr_04             ; set sprite 4 data pointer to CL_SpriteData + $c0
                            inx                             ; 
                            stx CL_SpritePtr_06             ; set sprite 6 data pointer to CL_SpriteData + $00
                            inx                             ; 
                            stx CL_SpritePtr_07             ; set sprite 7 data pointer to CL_SpriteData + $40
                            
                            lda #SPBGPR_ALL_FG              ; get all Sprites display priority in front of background
                            sta SPBGPR                      ; set VIC($D01B) Sprite to Foreground Display Priority
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite buffers
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; init buffer page offset to $00
ClrNextSpriteBufferByte     sta ZP_START + $02,y            ; set zero page
                            sta CL_SpriteDataPage_01,y      ; set sprite data store at $0c00 to $00
                            sta CL_SpriteDataPage_02,y      ; set sprite data store at $0d00 to $00
                            
                            iny                             ; inc buffer page offset
                            bne ClrNextSpriteBufferByte     ; check: buffer page offset max - no: continue
                            
                            lda #SPENA_ALL_ON               ; get switch on all sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda #CYAN                       ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorSprites              Does    : set sprite colors
;                           Expects : .A=enemy sprite color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorSprites               .block                           ; 
                            ldy #$07                        ; ini max sprite count
SetNextEnemyColor           sta SP0COL,y                    ; VIC($D027) Color Sprite 0
                            
                            dey                             ; dec enemy sprite count
                            bne SetNextEnemyColor           ; check: enemy sprite count min - no: continue
                            
                            iny                             ; get loderunner sprite color WHITE
                            sty SP0COL                      ; VIC($D027) Color Sprite 0
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorLevel                Does    : fill the multicolor hires screen with the selected colors
;                           Expects : .A=hires color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevel                 .block                           ; 
                            sta ssHiresColor                ; set actual hires color
                            
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            ora #SCROLX_MCM_ON              ; switch on Multi Color Mode (MCM)
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            
                            ldy #$00                        ; get offset
ssHiresColor                = * + $01                       ; 
GetNextHiresColor           lda #HR_ORANGE_BLUE             ; get actual hires color
                            sta CL_ScreenMC_Page0,y         ; set hires color pages
                            sta CL_ScreenMC_Page1,y         ; 
                            sta CL_ScreenMC_Page2,y         ; 
                            sta CL_ScreenMC_Page3,y         ; 
                            
                            lda #WHITE                      ; get constant coloram color of WHITE
                            sta CL_ColorRam_Page0,y         ; set ColorRAM Page $00 - $D800 (of $D800-$DBFF)
                            sta CL_ColorRam_Page1,y         ; set ColorRAM Page $01 - $D900 (of $D800-$DBFF)
                            sta CL_ColorRam_Page2,y         ; set ColorRAM Page $02 - $DA00 (of $D800-$DBFF)
                            sta CL_ColorRam_Page3,y         ; set ColorRAM Page $03 - $DB00 (of $D800-$DBFF)
                            
                            dey                             ; dec offset
                            bne GetNextHiresColor           ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; NMI                       Does    : NMI interrupt
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
NMI                        .block                           ; 
                            rti                             ; nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteNum           = *       ; 
                            .byte $01 ; .......# - $00
                            .byte $05 ; .....#.# - $01
                            .byte $0d ; ....##.# - $02
                            .byte $1d ; ...###.# - $03
                            .byte $5d ; .#.###.# - $04
                            .byte $dd ; ##.###.# - $05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveShowList          Does    : show the game save slot selection list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveShowList           .block                           ; 
                            lda #>CL_ScreenGfxDisplay       ; get gfx prepare screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            lda #CL_LevelNumDisk_Save       ; 155 - (t=$0c s=$0b) containes the saved game list
                            sta CL_LevelNumDisk             ; set disk level number 000-049
                            
                            lda #CL_SaveGameBufName_Len     ; get initial value
                            sta CL_InputBufMaxLen           ; ini name length
                            
                            lda #CL_GameMode_Play           ; get play mode
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr DiskOperationHandler        ; read or write a game data block from disk
                            jsr GameCheckGameListId         ; check game list block id and reinit block if not found
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            lda #$04                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;   NAME   LEVEL MEN  SCORE
                            .byte " " | $80 ; <SHIFT_SPACE> ; -------- ----- --- --------
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial value
                            sty CLZ_SaveGameDataOff         ; ini offset save game data
                            
InitNextListIdLen           lda #CL_SaveGameBufName_Len     ; get initial value
                            sta CLZ_SaveGameDataNameLen     ; ini name length
                            
GetNextDataOff              ldy CLZ_SaveGameDataOff         ; get offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            dec CLZ_SaveGameDataNameLen     ; dec name length
                            bne GetNextDataOff              ; check: min - no
                            
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            
                            lda CL_SaveGameBuf,y            ; 
                            cmp #$a0                        ; test <SHIFT_SPACE>
                            bne GoConvertHexToDec           ; check: EQ - no
                            
                            jmp SetNextGameDataOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoConvertHexToDec           jsr ConvertHexToDec             ; Hex2Dec  (1307=100 1308=10 1309=1)
                            
                            lda CL_Digit_100                ; get 100s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_10                 ; get 10s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get 1s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr ConvertHexToDec             ; Hex2Dec  (1307=100 1308=10 1309=1)
                            
                            lda CL_Digit_100                ; get 100s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_10                 ; get 10s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get 1s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            inc CLZ_SaveGameDataOff         ; inc offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            ldy CLZ_SaveGameDataOff         ; get offset save game data
                            lda CL_SaveGameBuf,y            ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            lda #$8d                        ; <newline>
                            jsr TextOutCharHandler          ; control the output of a single char
; --------------------------------------------------------------------------------------------------------------------- ;
; set offset to next entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextGameDataOff          lda CLZ_SaveGameDataOff         ; get offset save game data
                            and #<CL_SaveGameBufId          ; protect list id values
                            
                            clc                             ; 
                            adc #CL_SaveGameBufEntryLen     ; 
                            sta CLZ_SaveGameDataOff         ; set offset save game data to next entry
                            
                            cmp #CL_SaveGameBuf_Len         ; test complete length
                            beq GameSaveShowListX           ; check: EQ - yes: exit
                            
                            jmp InitNextListIdLen           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveShowListX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveSlotHandler       Does    : control the save game entry handling
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveSlotHandler        .block                           ; 
                            jsr ScoreBlockPrepareRead       ; prepare read of the leaderboard block
                            bcs GameSaveShowList.GameSaveShowListX ; check: bad: yes
                            
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            sta CL_LevelNumDiskSave         ; 
                            
ShowNextSaveList            jsr GameSaveShowList            ; show the game save slot selection list
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextCursorHome           lda #$00                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;  S  TO SAVE GAME IN PROGRESS
                            .byte "s" | $80 ;               ;  D  TO DELETE AN ENTRY BELOW
                            .byte " " | $80 ; <SHIFT_SPACE> ;    <R/S> TO CONTINUE GAME
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; discard key pressed
                            
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            ldx #CL_KeyNew_None             ; get initial value
                            stx CL_KeyNew                   ; discard key pressed
                            
                            cmp #$0d                        ; test "s"
                            bne TestChar_Delete             ; check: EQ - no: next test
                            
                            jmp GameSaveSlotAdd             ; try to add an entry
; --------------------------------------------------------------------------------------------------------------------- ;
TestChar_Delete             cmp #$12                        ; test "d"
                            beq GameSaveSlotDelete          ; check: EQ - yes
                            
                            cmp #$3f                        ; test <RUN/STOP>
                            bne CmdKeyInputError            ; check: EQ - no: error wrong command key
                            
                            jmp GameSaveLevelRestart        ; restart the level after <RUN/STOP>
; --------------------------------------------------------------------------------------------------------------------- ;
CmdKeyInputError            jsr GameErrorBeep               ; 
                            jmp GameSaveSlotHandler.SetNextCursorHome ; start over
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveSlotDelete        Does    : delete an existing entry from save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveSlotDelete         .block                           ; 
                            lda #$00                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;        DELETE AN ENTRY
                            .byte " " | $80 ; <SHIFT_SPACE> ;        NAME >        <
                            .byte " " | $80 ; <SHIFT_SPACE> ;        <R/S>  TO ABORT
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ScreenRow               ; dec screen row ($00 - $0f)
                            
                            lda #$0d                        ; 
                            sta CLZ_ScreenCol               ; set screen col ($00 - $1b)
                            
                            jsr GameGetPlayerInputAll       ; fill the input buffer with numeric or char values
                            jsr GameSaveDelListEntry        ; remove an entry from the save game list
                            
                            cpx #$00                        ; test 
                            beq ExitCursorHome              ; 
                            
                            jmp GameSaveSlotHandler.ShowNextSaveList ; next round
; --------------------------------------------------------------------------------------------------------------------- ;
ExitCursorHome              jmp GameSaveSlotHandler.SetNextCursorHome ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveSlotAdd           Does    : add a new entry to the save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveSlotAdd            .block                           ; 
                            lda #$00                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;    SAVE GAME IN PROGRESS
                            .byte " " | $80 ; <SHIFT_SPACE> ;     NAME >        <
                            .byte " " | $80 ; <SHIFT_SPACE> ;       <R/S> TO ABORT
                            .byte "s" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ScreenRow               ; dec screen row ($00 - $0f)
                            
                            lda #$0b                        ; get initial value
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr GameGetPlayerInputAll       ; fill the input buffer with numeric or char values
                            beq GoSetNextCursorHome         ; check: no name entered or <RUN/STOP> key pressed - yes
                            
                            jsr GameSaveSearchEntry         ; look for the buffer entry in the save game list
                            bcs CreateNewEntry              ; check: name found in list - yes: overwrite
                            
                            jsr GameSaveFindFreeSlot        ; look for a free slot in the save game list
                            bcs CreateNewEntry              ; check: found one - yes: fill it
; --------------------------------------------------------------------------------------------------------------------- ;
; error handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameErrorBeep               ; save game list full
                            jsr GameErrorBeep               ; 
                            
GoSetNextCursorHome         jmp GameSaveSlotHandler.SetNextCursorHome ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the entry
; --------------------------------------------------------------------------------------------------------------------- ;
CreateNewEntry              tay                             ; ini the save list offset
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in the entry name
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini the input buffer offset
GetNextNameChar             lda CL_InputBuffer,x            ; 
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            inx                             ; 
                            cpx #$08                        ; test max
                            bcc GetNextNameChar             ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in the entry values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LevelNumGame             ; get game level number 001-050
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_LevelNumDiskSave         ; fill in the level number
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_NumLives                 ; fill in number of lives
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_Score_Hi                 ; fill in the score reached
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_Score_MidHi              ; 
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_Score_MidLo              ; 
                            sta CL_SaveGameBuf,y            ; 
                            
                            iny                             ; inc the save list offset
                            lda CL_Score_Lo                 ; 
                            sta CL_SaveGameBuf,y            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check the play ID
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
; --------------------------------------------------------------------------------------------------------------------- ;
; write back the block to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr DiskOperationHandler        ; read or write a game data block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
; show the new list
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameSaveShowList            ; show the game save slot selection list
                            
                            lsr CL_GameMode                 ; shift out mode flag to .C - $00=start_screen $01=demo $02=play 
                            jmp GameOver.DemoWaitInit       ; wait and eventually start the demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveLevelRestart      Does    : restart the level after <RUN/STOP> interrupt in the save/delete entry list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveLevelRestart       .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda CL_ColorLevel               ; get the actual level color
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            
                            lda #CL_CirclePhase_Open        ; <obsolete> - not used anymore
                            sta CL_CirclePhase              ; <obsolete>
                            
                            lda CL_LevelNumDiskSave         ; get saved level number
                            sta CL_LevelNumDisk             ; restore disk level number 000-049
                            
                            lda #CL_LevelReload_Force       ; get force reload
                            sta CL_LevelReload              ; 000-049 - force level reload from disk if <> LR_LevelNoDisk
                            
                            jmp LevelStart                  ; restart the interrupted level
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveDelListEntry      Does    : remove an entry from the save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveDelListEntry       .block                           ; 
                            jsr GameSaveSearchEntry         ; look for the buffer entry in the save game list
                            bcc EntryNotFoundError          ; check: entry found - no: error - beep and exit
                            
                            tay                             ; set save game list entry slot offset
; --------------------------------------------------------------------------------------------------------------------- ;
; delete - move the whole list one position up
; --------------------------------------------------------------------------------------------------------------------- ;
MoveNextListByteUp          lda CL_SaveGameBuf + CL_SaveGameBufEntryLen,y ; get data from next entry onwards
                            sta CL_SaveGameBuf,y            ; set data to this entry onwards
                            
                            iny                             ; inc save game list offset
                            cpy #CL_SaveGameBuf_Len         ; test complete length
                            bcc MoveNextListByteUp          ; check: EQ - no continue
                            
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr DiskOperationHandler        ; read or write a game data block from disk
                            
                            clc                             ; 
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
EntryNotFoundError          jsr GameErrorBeep               ; 
                            jsr GameErrorBeep               ; 
                            
                            clc                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameGetPlayerInputAll     Does    : fill the input buffer with numeric or char values
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameGetPlayerInputAll      .block                           ; 
                            lda #CL_InputBufferCheck_Both   ; get flag check input for both char/number
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameGetPlayerInput        Does    : fill the input buffer with values of a given type
;                           Expects : .A=input check flags
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameGetPlayerInput         .block                           ; 
                            sta CL_InputBufferCheck         ; flag for check input type
                            
                            ldx #CL_InputBufferLen          ; get length input buffer
                            lda #$a0                        ; get <SHIFT_SPACE>
ClearNextInputBufPos        sta CL_InputBuffer,x            ; set next <SHIFT_SPACE>
                            
                            dex                             ; dec length input buffer
                            bpl ClearNextInputBufPos        ; check: min - no: continue
                            
                            inx                             ; $00
                            stx CL_InputBufferPtr           ; ini input buffer pointer
                            stx CL_KeyNew                   ; discard input key
                            
GetNextInputBufPtr          ldx CL_InputBufferPtr           ; get buffer pointer
                            lda CL_InputBuffer,x            ; get a byte from input buffer
                            jsr TextCharPrepare             ; prepare a text char for output
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            ldx #CL_KeyNew_None             ; get initial value
                            stx CL_KeyNew                   ; discard input key
                            
                            cmp #$3f                        ; test RUN/STOP
                            beq Abort_RunStop               ; check: EQ - yes: exit
                            
                            jsr InputKeySubstitute          ; get a raw input char substitution value
; --------------------------------------------------------------------------------------------------------------------- ;
; check flag request number input
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit CL_InputBufferCheck         ; test flag: check input number
                            bpl CheckNumCtrlChars           ; check: set - no: check input ctrl chars
                            
                            cmp #$b0                        ; test lower key "0"
                            bcc CheckNumCtrlChars           ; check: 
                            
                            cmp #$ba                        ; test lower key "9"
                            bcc OutCharToBufAndScrn         ; check: LT - yes - output
; --------------------------------------------------------------------------------------------------------------------- ;
; check input control chars
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNumCtrlChars           cmp #$8d                        ; test <RETURN> - end of edit
                            beq Exit_Return                 ; check: EQ - yes
                            
                            cmp #$88                        ; test <CURSOR UP/DOWN>
                            beq MoveInputCursorLeft         ; check: EQ - yes
                            
                            cmp #$95                        ; test <CURSOR LEFT/RIGHT>
                            beq MoveInputCursorRight        ; check: EQ - yes
                            
                            cmp #$a0                        ; test <SHIFT_SPACE>
                            beq OutCharToBufAndScrn         ; check: EQ - yes - output
; --------------------------------------------------------------------------------------------------------------------- ;
; check flag request char input
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit CL_InputBufferCheck         ; test flag: check input char 
                            bvc BeepInputError              ; check: set - no: wrong flags - beep error
                            
                            cmp #$ae                        ; test "."
                            beq OutCharToBufAndScrn         ; check: EQ - yes: output
                            
                            cmp #$c1                        ; test "A"
                            bcc BeepInputError              ; check: LT - yes
                            
                            cmp #$db                        ; test "Z" + 1
                            bcs BeepInputError              ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; output a valid input char
; --------------------------------------------------------------------------------------------------------------------- ;
OutCharToBufAndScrn         ldx CL_InputBufferPtr           ; 
                            sta CL_InputBuffer,x            ; 
                            
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            inc CL_InputBufferPtr           ; 
                            lda CL_InputBufferPtr           ; 
                            cmp CL_InputBufMaxLen           ; test 
                            bcc GetNextInputBufPtr          ; check: 
                            
                            dec CL_InputBufferPtr           ; 
                            dec CLZ_ScreenCol               ; screen col ($00 - $1b)
                            jmp GetNextInputBufPtr          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle input end after <RETURN> key
; --------------------------------------------------------------------------------------------------------------------- ;
Exit_Return                 ldx CL_InputBufMaxLen           ; 
GetNextInputBufferKey       lda CL_InputBuffer,x            ; 
                            cmp #$a0                        ; test <SHIFT_SPACE>
                            bne Exit_Char                   ; check: EQ - no: return the input char
                            
                            dex                             ; 
                            bpl GetNextInputBufferKey       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
Abort_RunStop               sec                             ; empty name entry or RUN/STOP
                            ldx #$00                        ; 
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
Exit_Char                   sec                             ; 
                            ldx #$01                        ; 
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one pos left
; --------------------------------------------------------------------------------------------------------------------- ;
MoveInputCursorLeft         dec CLZ_ScreenCol               ; screen col ($00 - $1b)
                            dec CL_InputBufferPtr           ; 
                            bpl GetNextInputBufPtr          ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset to min pos and beep
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenCol               ; screen col ($00 - $1b)
                            inc CL_InputBufferPtr           ; 
                            jmp BeepInputError              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one pos right
; --------------------------------------------------------------------------------------------------------------------- ;
MoveInputCursorRight        ldx CL_InputBufferPtr           ; get input buffer pointer
                            inx                             ; inc input buffer pointer
                            cpx CL_InputBufMaxLen           ; test max 
                            bcs BeepInputError              ; check: GE - yes: beep input error
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00 - $1b)
                            inc CL_InputBufferPtr           ; inc buffer pointer
                            jmp GetNextInputBufPtr          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BeepInputError              jsr GameErrorBeep               ; 
                            jsr GameErrorBeep               ; 
                            
                            jmp GetNextInputBufPtr          ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveSearchEntry       Does    : look for the buffer entry in the save game list
;                           Expects : 
;                           Returns : .C=0 - name not found in list
;                                   : .C=1 - name found in list
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveSearchEntry        .block                           ; 
                            ldy #$00                        ; ini save game list offset
GetNextBufOff               ldx #$00                        ; ini input buffer name offset
GetNextNameByte             lda CL_SaveGameBuf,y            ; get a byte from the save game list
                            cmp CL_InputBuffer,x            ; test wit input buffer byte
                            bne SetNextListOff              ; check: EQ - no: set offset to next entry
                            
                            iny                             ; inc save game list offset
                            
                            inx                             ; inc input buffer name offset
                            cpx #CL_SaveGameBufName_Len     ; test max
                            bne GetNextNameByte             ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; save name already existing
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get save game name offset
                            and #<CL_SaveGameBufId          ; protect list id values
                            
                            sec                             ; set flag: save name found in list
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextListOff              tya                             ; get save game name offset
                            and #<CL_SaveGameBufId          ; protect list id values
                            
                            clc                             ; 
                            adc #CL_SaveGameBufEntryLen     ; advance offset to next entry
                            tay                             ; 
                            
                            cmp #CL_SaveGameBuf_Len         ; test complete length
                            bne GetNextBufOff               ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; list completely handled - no name entry found
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; set flag: new save name
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveFindFreeSlot      Does    : look for a free slot in the save game list
;                           Expects : 
;                           Returns : .C=0 - no free entry in list
;                                   : .C=1 - a free entry was found in list
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveFindFreeSlot       .block                           ; 
                            ldy #$00                        ; ini save game list offset
GetNextNameOffset           ldx #CL_SaveGameBufName_Len     ; get input buffer name length
                            lda #$a0                        ; get free entry indicator <SHIFT_SPACE>
CheckNextListEntryChar      cmp CL_SaveGameBuf,y            ; test for <SHIFT_SPACE>
                            bne SetNextListOff              ; check: EQ - no: set offset to next entry
                            
                            iny                             ; inc save game list offset
                            
                            dex                             ; dec input buffer name length
                            bne CheckNextListEntryChar      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; exit free entry found
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get save game name offset
                            and #<CL_SaveGameBufId          ; protect list id values
                            
                            sec                             ; set flag: free entry found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextListOff              tya                             ; get save game name offset
                            and #<CL_SaveGameBufId          ; protect list id values
                            
                            clc                             ; 
                            adc #CL_SaveGameBufEntryLen     ; advance offset to next entry
                            tay                             ; 
                            
                            cmp #CL_SaveGameBuf_Len         ; test complete length
                            bne GetNextNameOffset           ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; exit no free entry found
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; set flag: no free entry found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameReturnFlagMode        Does    : return game mode flag
;                           Expects : 
;                           Returns : .C=0 - play
;                                   : .c=1 - demo
; --------------------------------------------------------------------------------------------------------------------- ;
GameReturnFlagMode         .block                           ; 
                            lsr CL_GameMode                 ; shift out mode flag to .C - $00=start_screen $01=demo $02=play 
                            jmp GameOver.DemoWaitInit       ; WaitSomeTime
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLoad                  Does    : load a game from the save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLoad                   .block                           ; 
PrepNextReadSaveGameBlock   jsr ScoreBlockPrepareRead       ; prepare read of the leaderboard block
                            bcs GameReturnFlagMode          ; check: return game mode flag
                            
                            lda #CL_GameMode_Play           ; get play mode
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            jsr GameUniquePlayIdSet         ; get a play ID for this session to avoid disk swap
                            jsr GameSaveShowList            ; show the game save slot selection list
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;    LOAD AND PLAY A GAME
                            .byte " " | $80 ; <SHIFT_SPACE> ;     NAME >        <
                            .byte " " | $80 ; <SHIFT_SPACE> ;        <R/S> TO ABORT
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0c                        ; get initial col value
                            dec CLZ_ScreenRow               ; dec screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; set screen col ($00 - $1b)
                            
                            jsr GameGetPlayerInputAll       ; fill the input buffer with numeric or char values
                            bcc GameLoad                    ; check: load a game from the save game list
                            beq GameReturnFlagMode          ; return game mode flag
                            
                            jsr GameSaveSearchEntry         ; look for the buffer entry in the save game list
                            bcs ListEntryNameFound          ; check: name found in list - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; entry not found error - retry
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameErrorBeep               ; 
                            jsr GameErrorBeep               ; 
                            
                            jmp PrepNextReadSaveGameBlock   ; reload save game block - try next round
; --------------------------------------------------------------------------------------------------------------------- ;
; list entry found - get values
; --------------------------------------------------------------------------------------------------------------------- ;
ListEntryNameFound          clc                             ; name length
                            adc #CL_SaveGameBufName_Len     ; point behind entry name
                            tay                             ; set offset to CL_SaveGameBufLevelGame
; --------------------------------------------------------------------------------------------------------------------- ;
; insert saved values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SaveGameBuf + $00,y      ; get level number reached
                            sta CL_LevelNumGame             ; set game level number 001-050
                            
                            lda CL_SaveGameBuf + $01,y      ; get disk level number
                            pha                             ; save disk level number because of a later list rewrite
                            
                            lda CL_SaveGameBuf + $02,y      ; get number of lives
                            sta CL_NumLives                 ; set number of lives
                            
                            sec                             ; discount a live whith any load
                            sbc #$01                        ; 
                            sta CL_SaveGameBuf + $02,y      ; set new number of lives for next load
                            
                            lda CL_SaveGameBuf + $03,y      ; get scores reached
                            sta CL_Score_Hi                 ; 
                            
                            lda CL_SaveGameBuf + $04,y      ; 
                            sta CL_Score_MidHi              ; 
                            
                            lda CL_SaveGameBuf + $05,y      ; 
                            sta CL_Score_MidLo              ; 
                            
                            lda CL_SaveGameBuf + $06,y      ; 
                            sta CL_Score_Lo                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check for entry auto delet if last live was used up
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_NumLives                 ; get number of lives
                            cmp #$01                        ; test min
                            bne CheckPlayId                 ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; delete this entry from the save game list
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameSaveDelListEntry        ; remove an entry from the save game list
                            
CheckPlayId                 jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr DiskOperationHandler        ; read or write a game data block from disk
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            jsr ScreenPrepareClear          ; clear prepare grafic screen
                            
                            pla                             ; restore CR_SavListLevelD
                            sta CL_LevelNumDisk             ; set disk level number 000-049
                            
                            jsr ColorLevelSelect            ; set a new color any 10th level
                            
                            lda CL_ColorLevel               ; get the actual level color
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            
                            lda #BLACK                      ; get initial value
                            sta CL_ColorStatus              ; set status line color
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            
                            lda #>CL_ScreenGfxPrepare       ; get gfx prepare screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            jsr JingleGotAllGoldInit        ; InitVictoryTune
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get intial value
                            sta CL_GameSpeedCtrl            ; ini game speed
                            sta CL_EnemyBirthCol            ; ini enemy birth column
                            
                            lda #CL_Volume_Max              ; 
                            sta CL_Volume                   ; 
                            sta CL_LevelReload              ; 000-049 - force level reload from disk if <> LR_LevelNoDisk
                            
                            jsr GameUniquePlayIdSet         ; get a play ID for this session to avoid disk swap
                            jmp LevelStart                  ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameClearHighScores       Does    : clear the disk leaderboard block
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameClearHighScores        .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
WaitPlayerInputKey          lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            cmp #LSTX_NONE                  ; test no key pressed
                            bne WaitPlayerInputKey          ; check: EQ - no
                            
                            lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; discard input key
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;   THIS CLEARS THE HIGH
                            .byte " " | $80 ; <SHIFT_SPACE> ;   SCORE FILE OF ALL
                            .byte "t" | $80 ;               ;   ENTRIES.
                            .byte "h" | $80 ;               ;   ARE YOU SURE (Y/N)
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "f" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "o" | $80 ;               ; 
                            .byte "f" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get blank char
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            ldx #CL_KeyNew_None             ; get initial value
                            stx CL_KeyNew                   ; discard input key
                            
                            cmp #$19                        ; test "y"
                            bne GameClearHighScoresX        ; check: EQ - no: exit
                            
                            lda #CL_DiskRead | CL_DiskCheckDemo ; with flag: check for demo mode
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            
                            ldy #$83                        ; ini max score buffer offset
                            lda #$00                        ; ini get initial value
DelNextBoardByte            sta CL_ScoreBuf - $01,y         ; clear a leaderboard table byte
                            
                            dey                             ; dec score buffer offset
                            bne DelNextBoardByte            ; check: min - no: continue
                            
                            lsr CL_LevelNumDisk             ; disk level number 000-049
                            
                            lda #CL_DiskWrite | CL_DiskCheckDemo ; with flag: check for demo mode
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            
GameClearHighScoresX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameCheckGameListId       Does    : check game list block id
;                           Expects : 
;                           Returns : 
;                           Remark  : game list block is cleared if the correct id was not found
; --------------------------------------------------------------------------------------------------------------------- ;
GameCheckGameListId        .block                           ; 
                            lda CL_SaveGameBufIdChar_01     ; 
                            cmp #$c4                        ; test "D"
                            bne IniListIdReset              ; check: EQ - no: - clear and write back
                            
                            lda CL_SaveGameBufIdChar_02     ; 
                            cmp #$ca                        ; test "J"
                            bne IniListIdReset              ; check: EQ - no: - clear and write back
                            
                            lda CL_SaveGameBufIdChar_03     ; 
                            cmp #$c2                        ; test "B"
                            bne IniListIdReset              ; check: EQ - no: clear and write back
                            
                            rts                             ; good list
; --------------------------------------------------------------------------------------------------------------------- ;
; wrong id - clear the save game list and write back
; --------------------------------------------------------------------------------------------------------------------- ;
IniListIdReset              lda #$a0                        ; get <SHIFT_SPACE>
                            ldx #$00                        ; ini buffer offset
ClearNextBufferByte         sta CL_SaveGameBuf,x            ; 
                            
                            inx                             ; inc buffer offset
                            bne ClearNextBufferByte         ; check: max - no: continue
                            
                            lda #$c4                        ; "D"
                            sta CL_SaveGameBufIdChar_01     ; 
                            
                            lda #$ca                        ; "J"
                            sta CL_SaveGameBufIdChar_02     ; 
                            
                            lda #$c2                        ; "B"
                            sta CL_SaveGameBufIdChar_03     ; 
                            
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr DiskOperationHandler        ; read or write a game data block from disk
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreBlockPrepareRead     Does    : prepare read of the leaderboard block
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreBlockPrepareRead      .block                           ; 
                            lda #CL_GameMode_Play           ; get play mode
                            sta CL_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play
                            
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            cmp #$00                        ; test RC
                            bne LoadScoreBlockFail          ; check: <ZERO> - no: set error flag
                            
                            sec                             ; 
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
LoadScoreBlockFail          clc                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreSplitDigitStatusOut  Does    : split a score digit and output the result to status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSplitDigitStatusOut   .block                           ; 
                            jsr ScoreSplitDigit             ; 
                            
                            lda CL_Digit_10                 ; get 10s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get 1s
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameMessageTextShow       Does    : show the level solved msg after all gold was collected
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameMessageTextShow        .block                           ; 
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi ScoreBlockPrepareRead.LoadScoreBlockFail ; check: championship LR - no: old LR
; --------------------------------------------------------------------------------------------------------------------- ;
; no messages in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq ScoreBlockPrepareRead.LoadScoreBlockFail ; check: demo - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; store message len
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_LevelDataBufMsgTxt_Len - $01 ; get length of victory msg
                            stx CL_WorkTextOutputLen        ; set msg len
; --------------------------------------------------------------------------------------------------------------------- ;
; copy level finish message to buffer
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextFinishMsgTextByte    lda CL_LevelDataBufMsgTxt,x     ; get a msg text byte from the disk buffer
                            beq DecFinishMsgLen             ; don't move a $00 - EndOfText value leads to program abend
                            
                            sta TabLevelFinishMsgTextBuf,x  ; fill the msg buffer
                            
DecFinishMsgLen             dex                             ; dec length of victory msg
                            bpl GetNextFinishMsgTextByte    ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; show the level finish message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$10                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            lda #$0d                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr TextOutHandler              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelFinishMsgTextBuf     = *      ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; set message color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_YELLOW_YELLOW           ; get status line color
                            sta CL_ColorStatus              ; set status line color
                            
                            ldx #CL_ScreenMC_MsgColor_Len   ; get colour counter
SetNextFinishMsgTextByte    sta CL_ScreenMC + $03aa,x       ; set colour
                            
                            dex                             ; dec colour counter
                            bpl SetNextFinishMsgTextByte    ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameUniquePlayIdSet       Does    : generate and store a play ID for this session to block a disk swap
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameUniquePlayIdSet        .block                           ; 
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq GameUniquePlayIdSetX        ; check: demo - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; read the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; get and set the ney play id
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda RASTER                      ; VIC($D012) Read : Current Raster Scan Line (Bit 8 in SCROLY = $D011); VIC 2 - $D012 = Read: Raster Scan Line/ Write: Line for Raster IRQ
                            sta CL_UniquePlayID             ; 
                            sta CL_ScoreBufUniquePlayID     ; unique play id disk store
; --------------------------------------------------------------------------------------------------------------------- ;
; write back the leaderboard block containing the new play id
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            
GameUniquePlayIdSetX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameUniquePlayIdCheck     Does    : check the play ID for this session to block a disk swap
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameUniquePlayIdCheck      .block                           ; 
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq GameUniquePlayIdSet.GameUniquePlayIdSetX ; check: demo - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; read the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; check the play id
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_ScoreBufUniquePlayID     ; get play id from disk buffer
                            cmp CL_UniquePlayID             ; test with generated id
                            beq GameUniquePlayIdSet.GameUniquePlayIdSetX ; check: EQ - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; unique play id mismatch error
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #>CL_ScreenGfxDisplay       ; 
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "d" | $80 ;               ; DISK SWAP NOT ALLOWED
                            .byte "i" | $80 ;               ; HIT ANY KEY
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; discard input key
                            
                            jmp ColdStart                   ; ColdStart
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorLevelSelect          Does    : set a new color any 10th level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevelSelect           .block                           ; 
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi GetDefaultColors            ; check: championship LR - no: old LR
                            
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq GetDefaultColors            ; check: demo - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; divide disk level num by 10
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            ldx #$ff                        ; preset -1 - care for start loop inc
CountNextTen                inx                             ; count 10s
                            sec                             ; 
                            sbc #$0a                        ; sub 10
                            bcs CountNextTen                ; check: underflow 
                            
                            lda TabLevelColors,x            ; 
SetNewGameLevelColor        sta CL_ColorLevel               ; set the actual level color
                            
                            lsr a                           ; isolate enemy color
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            jsr ColorSprites                ; 
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; error - set default colors
; --------------------------------------------------------------------------------------------------------------------- ;
GetDefaultColors            lda #HR_CYAN_RED                ; 
                            
                            jmp SetNewGameLevelColor        ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelColors               = *  ; right nibble contains enemy sprite color
                            .byte HR_CYAN_RED       ; color levels 01-09
                            .byte HR_GREEN_LT_RED   ; color levels 10-19
                            .byte HR_CYAN_ORANGE    ; color levels 20-29
                            .byte HR_PURPLE_GREEN   ; color levels 30-39
                            .byte HR_PURPLE_LT_BLUE ; color levels 40-49
; --------------------------------------------------------------------------------------------------------------------- ;
TabLodeRuDiskId             = *       ; 
                            .byte $44 ; d
                            .byte $41 ; a
                            .byte $4e ; n
                            .byte $45 ; e
                            .byte $20 ; <SPACE>
                            .byte $42 ; b
                            .byte $49 ; i
                            .byte $47 ; g
                            .byte $48 ; h
                            .byte $41 ; a
                            .byte $4d ; m
TabLodeRuDiskId_Len         = * - TabLodeRuDiskId - $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataExpand       Does    : expand compressed level disk data
;                           Expects : .X=0 - data needs a copy to prepare hires screen
;                                   : .X=1 - data already copied to prepare hires screen
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataExpand        .block                           ; 
                            stx CL_LevelLoad                ; set flag level disk load control
                            
                            ldx #$ff                        ; get initial value $ff
                            stx CLZ_LodeRuCol               ; ini no loderunner found
                            
                            inx                             ; get initial value $00
                            stx CL_ExitLadderCount          ; ini CL_ExitLadderCount_None
                            stx CL_GoldToCollect            ; ini CL_GoldToCollect_None
                            stx CL_EnemyCount               ; ini CL_EnmyCount_None
                            stx CL_EnemyToMoveNum           ; ini CL_EnemyToMoveNum_None
                            stx CLZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                            stx CLZ_LevelDiskDataOff        ; ini disk level data offset
                            stx CLZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            stx CLZ_ScreenRow               ; ini screen row ($00-$0f)
                            
                            txa                             ; $00
                            ldx #CL_WA_HoleMax              ; get count max entries of hole open time table
IniNextOpenHoleTabEntry     sta CL_WA_HoleOpenTime,x        ; ini hole open time tab
                            
                            dex                             ; dec count entries of hole open time table
                            bpl IniNextOpenHoleTabEntry     ; check: min - no: continue
                            
                            ldx #CL_WA_EnemyBirth_Len       ; get count max entries of enemy rebirth time table
IniNextRibirthTimeTabEntry  sta CL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            dex                             ; dec count of enemy rebirth time table
                            bpl IniNextRibirthTimeTabEntry  ; check: min - no: continue
                            
                            lda #CL_LodeRuState_Alive       ; get loderunner alive
                            sta CL_LodeRuState              ; set loderunner alive
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            cmp CL_LevelReload              ; test with reload
                            beq SetNoDiskLoadRequired       ; check: EQ - yes: level aready loaded - no reload necessary
                            
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr DiskOperationHandler        ; read block from disk
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi SetNoDiskLoadRequired       ; check: championship LR - no: old LR
                            
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq SetNoDiskLoadRequired       ; check: demo - yes: demo level is built in - no load
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            cmp #CL_LevelNumDisk_Max + $01  ; test max
                            bcs SetNoDiskLoadRequired       ; check: GE - yes: no load
; --------------------------------------------------------------------------------------------------------------------- ;
; remove level data obfuscation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #<CL_LevelDataBufMsg + $01  ; get max length level data
GetNextLevelDataByte        lda CL_LevelDataBuf - $01,x     ; get obfuscated level byte
                            eor #$ff                        ; flip all bits
                            sta CL_LevelDataBuf - $01,x     ; set clear level byte
                            
                            dex                             ; dec length level data
                            bne GetNextLevelDataByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set CL_LevelNumDisk=CL_LevelReload - avoids level data reload from disk for the same level number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNoDiskLoadRequired       lda CL_LevelNumDisk             ; get disk level number 000-049
                            sta CL_LevelReload              ; set avoid level data reload
                            
                            jsr ColorLevelSelect            ; set a new color any 10th level
; --------------------------------------------------------------------------------------------------------------------- ;
; expand the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set control level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set control level data row pointer LOlevel control data pointer HI
                            
                            lda #CLZ_ScreenCol_Min          ; get initial value
                            sta CLZ_ScreenCol               ; ini screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; handle compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextNibbleCtrl           lda CLZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
; --------------------------------------------------------------------------------------------------------------------- ;
; get compressed data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LevelDiskDataOff        ; get disk level data offset
                            lda CL_LevelDataBuf,y           ; get a packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; check compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; ....#### - isolate right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           lsr a                           ; .####... - isolate left nibble
                            lsr a                           ; ..####..
                            lsr a                           ; ...####.
                            lsr a                           ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_LevelDiskDataOff        ; inc offset to next disk level byte
                            
ForceProcessingLeftNibble   inc CLZ_WorkLevelDataPartCtrl   ; force .C set the next round - process left nibble
                            
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; care for valid level tile number
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_LevelTileNum_Max        ; test valid byte range of $00-$09
                            bcc StoreUnpackedLevelTile      ; check: LT - yes: valid
                            
                            lda #CL_TileNum_Empty           ; get invalid level tile replacement - store an empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
; store level tile into both level data buffers
; --------------------------------------------------------------------------------------------------------------------- ;
StoreUnpackedLevelTile      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            
                            lda CLZ_ScreenCol               ; get screen col ($00-$1b)
                            cmp #CLZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #CLZ_ScreenRow_Max + $01    ; test max
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; care for hidden ladders/trap doors/gold/enemies/loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LevelSpecialTileHandler     ; handle special level tiles and set up prepare gfx screen
                            bcc GameContinue                ; check: loderunner tile found - yes: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; missing loderunner level data tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bpl GameColdStart               ; check: championship LR - yes
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            beq GameColdStart               ; check: still 1st level - yes: coldstart
; --------------------------------------------------------------------------------------------------------------------- ;
; force restart with 1st level
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_LevelNumDisk_Min        ; get initial value
                            stx CL_LevelNumDisk             ; set disk level number 000-049 - last level completed
; --------------------------------------------------------------------------------------------------------------------- ;
; try to increase the game speed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_GameSpeedCtrl            ; get game speed ($00-$0a)
                            cmp #CL_GameSpeedCtrl_Max       ; test game speed max
                            bcs GameRestart                 ; check: GE - yes: max reached or bypassed - bypass inc
                            
                            inc CL_GameSpeedCtrl            ; make the game a bit difficulter
                            
GameRestart                 dex                             ; set flag CL_LevelLoad_No
                            jmp GameLevelDataExpand         ; expand compressed level disk data
; --------------------------------------------------------------------------------------------------------------------- ;
GameContinue                rts                             ; continue the running game
; --------------------------------------------------------------------------------------------------------------------- ;
; error restart - probably no loderunner level disk
; --------------------------------------------------------------------------------------------------------------------- ;
GameColdStart               jmp ColdStart                   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataCompress     Does    : compress expanded level data and store to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataCompress      .block                           ; 
                            lda #$00                        ; get initial value
                            sta CLZ_LevelDiskDataOff        ; ini disk level data offset
                            sta CLZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            sta CLZ_ScreenRow               ; ini screen row ($00-$0f)
                            
SetNextLevelDataRowPtr      ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #CLZ_ScreenCol_Min          ; get inital value
                            sty CLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextNibbleCtrl           lda CLZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
                            
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CLZ_ImageNumber             ; save as right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           asl a                           ; isolate left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora CLZ_ImageNumber             ; insert right nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; store complete data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LevelDiskDataOff        ; get disk level data offset
                            sta CL_LevelDataBuf,y           ; set packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_LevelDiskDataOff        ; inc disk level data offset
                            
ForceProcessingLeftNibble   inc CLZ_WorkLevelDataPartCtrl   ; will set .C the next round - force left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
                            cpy #CLZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda CLZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #CLZ_ScreenRow_Max + $01    ; test max passed
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; write packed data block to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jmp DiskOperationHandler        ; write level data block to disk and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskOperationHandler      Does    : read or write a game data block from disk
;                           Expects : .A=$01 - Read   $81 - Flag check demo mode
;                                   : .A=$02 - Write  $82 - Flag check demo mode
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskOperationHandler       .block                           ; 
                            pha                             ; save mode - $01=read $02=write $04=init
                            bpl ChkDemoOrGameLevels         ; check: demo check flag set - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reset demo mode check flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore mode - $01=read $02=write $04=init
                            and #$7f                        ; clear bit7
                            pha                             ; save mode - $01=read $02=write $04=init
                            
                            jmp DiskCmdHandler              ; open channels and device for read/write/init commands
; --------------------------------------------------------------------------------------------------------------------- ;
; demo levels are built in - only game levels must be loaded from disk
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDemoOrGameLevels         lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            lsr a                           ; shift out mode flag
                            beq DemoLevelDataHandler        ; check: zero - yes: demo - levels are built in - no load necessary
; --------------------------------------------------------------------------------------------------------------------- ;
; only game levels have to be loaded
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp DiskCmdHandler              ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoLevelDataHandler      Does    : control demo level data selection
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoLevelDataHandler       .block                           ; 
                            pla                             ; remove mode from stack
; --------------------------------------------------------------------------------------------------------------------- ;
; 3 demo levels are built in
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            cmp #CL_LevelNumDisk_Demo_Max   ; test max 3 demo levels - but only one is available now
                            bcc SetNextDemoLevelDataAddress ; check: LT - yes: continue with next demo level data address
; --------------------------------------------------------------------------------------------------------------------- ;
; maximum reached - restart at demo level one
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_LevelNumDisk_Min        ; get restart at level 1
                            sta CL_LevelNumDisk             ; set disk level number 000-049
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data pointer to next demo level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextDemoLevelDataAddress clc                             ; 
                            adc #>TabDemoDataLevel          ; add demo level number do demo level data base address
                            sta smTabDemoDataLevel          ; set address to next level data
                            
                            ldy #$00                        ; get demo level data offset
smTabDemoDataLevel          = * + $02                       ; 
GetNextDemoLevelDataByte    lda TabDemoDataLevel,y          ; get demo level data from $b500/$b600/$b700
                            sta CL_LevelDataBuf,y           ; set next demo level data byte
                            
                            iny                             ; inc demo level data offset
                            bne GetNextDemoLevelDataByte    ; check: max - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreDiskHandler          Does    : read or write the leaderboard block
;                           Expects : .A=$01 - Disk Read   $81 - Flag check demo mode in DiskOperationHandler
;                                   : .A=$02 - Disk Write  $82 - Flag check demo mode in DiskOperationHandler
;                           Returns : .A=CL_ScoreBufCheck_Bad     - loderunner disk ID not found
;                                   : .A=CL_ScoreBufCheck_Mod_No  - loderunner master disk
;                                   : .A=CL_ScoreBufCheck_Mod_Yes - loderunner player level data disk
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreDiskHandler           .block                           ; 
                            tax                             ; save access type - 01=read 02=write
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            pha                             ; save disk level number
                            
                            inc DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; select read buffer
                            inc DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; select write buffer
                            
                            lda #CL_LevelNumDisk_Score      ; get disk level 151 - stores the leaderboard data
                            sta CL_LevelNumDisk             ; set disk level number 151
                            
                            txa                             ; restore access type - 01=read 02=write
                            jsr DiskOperationHandler        ; read leaderboard block from disk
                            
                            pla                             ; restore disk level number
                            sta CL_LevelNumDisk             ; set disk level number 000-049
                            
                            dec DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; reset read buffer
                            dec DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; reset write buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; init check loderunner disk id DANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length of loderunner disk id string
                            
                            lda #$00                        ; get initial value
                            sta CLZ_WorkChkDiskIdResult     ; ini check result
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk id dANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDiskIdChar           lda CL_ScoreBufDiskId,y         ; dANE BIGHAM
                            sta CL_ScoreVersionId           ; finally keeps the 1st char of id string dANE BIGHAM
                            
                            and #$7f                        ; to lower
                            eor TabLodeRuDiskId,y           ; flip with tabled disk id char
                            ora CLZ_WorkChkDiskIdResult     ; insert old check result
                            sta CLZ_WorkChkDiskIdResult     ; set new check result
                            
                            dey                             ; dec disk id length
                            bpl GetNextDiskIdChar           ; check: end of disk id string - no: continue
                            
                            lda CLZ_WorkChkDiskIdResult     ; get check result
                            beq ChkLoderunnerDiskFlag       ; check: disk id correct - yes: loderunner data disk in drive
                            
                            lda #$00                        ; <obsolete>
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "d" | $80 ;               ; DISKETTE IN DRIVE IS
                            .byte "i" | $80 ;               ; NOT A LODE RUNNER DISK:
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_CountIRQs_Msg           ; get initial value
                            sta CL_CountIRQs                ; set wait counter (inc at every IRQ)
                            
WaitNext                    lda CL_CountIRQs                ; get wait counter (inc at every IRQ)
                            bne WaitNext                    ; check: min - no: continue
                            
                            jmp ColdStart                   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; <obsolete>
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLoderunnerDiskFlag       ldx #CL_ScoreBufName_Len_Old    ; preset old loderunner score offset
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi SetScoreOffset              ; check: championship LR - no: old LR
                            
                            ldx #CL_ScoreBufName_Len        ; get championship loderunner score offset
                            
SetScoreOffset              stx CL_ScoreOffset              ; get the version score offset
                            
                            lda #CL_ScoreBufCheck_Mod_No    ; preset initial value
                            
                            ldx CL_ScoreBufDiskFlag         ; 
                            bne ScoreDiskHandlerX           ; check: CL_ScoreBufDiskFlag_Master - no
                            
                            lda #CL_ScoreBufCheck_Mod_Yes   ; 
                            
ScoreDiskHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdHandler            Does    : open channels and device for read/write/init commands
;                           Expects : STACK=mode $01=read $02=write $04=init
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdHandler             .block                           ; 
                            lda #SPENA_ALL_OFF              ; get switch off all sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; set up disk command
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"0"                        ; preset "0"
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            and #$0f                        ; isolate right nibble
                            cmp #$0a                        ; test 10
                            bcc SetDiskSectorNum            ; check: LT - yes: keep "0"
                            
                            ldx #"1"                        ; get "1"
                            
                            sec                             ; 
                            sbc #$0a                        ; convert 0a-0f  to  00-05
                            
SetDiskSectorNum            stx TabDiskCmd_Sec_Hi           ; u1:02 0 03 00 - Disk Sector Hi
                            
                            clc                             ; 
                            adc #"0"                        ; generate digit 0-9
                            sta TabDiskCmd_Sec_Lo           ; u1:02 0 03 00 - Disk Sector Lo
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            lsr a                           ; isolate left nibble
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            clc                             ; 
                            adc #CL_LevelDataStartTrackNum  ; disk level data starts at Track 03 Sector 00
                            jsr ConvertHexToDec             ; Hex2Dec  (1307=100 1308=10 1309=1)
                            
                            lda CL_Digit_10                 ; 
                            clc                             ; 
                            adc #"0"                        ; generate digit 0-9
                            sta TabDiskCmd_Trk_Hi           ; 
                            
                            lda CL_Digit_1                  ; 
                            clc                             ; 
                            adc #"0"                        ; generate digit 0-9
                            sta TabDiskCmd_Trk_Lo           ; 
                            
                            lda #KV_SETNAM_FILENAM_NONE     ; get flag no filename
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #SA_CHANNEL_CMD             ; get channel number: command channel
                            ldx #FA_DISK                    ; get drive number (8)
                            ldy #SA_CHANNEL_CMD             ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            bcs DiskError                   ; check: disk error - yes: DiskError
                            
                            lda #FileNameString_Len         ; get length data set name '#'
                            ldx #<FileNameString            ; get adr filename LO
                            ldy #>FileNameString            ; get adr filename HI
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #$02                        ; get channel number: data
                            ldx #FA_DISK                    ; get drive number (8)
                            ldy #$02                        ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; handle disk access mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore mode - $01=read $02=write $04=init
                            
                            lsr a                           ; shift READ bit to .C
                            bcs DiskCmdExecRead             ; check: READ mode - yes: exec READ
                            
                            lsr a                           ; shift WRITE bit to .C
                            bcc DiskCmdExecInit             ; check: WRITE mode - no: exec INIT
                            
                            jmp DiskCmdExecWrite            ; exec write
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecInit           Does    : initialize a loderunner level data disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecInit            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear packed level data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CL_TileNum_Empty           ; get empty loderunner level data tile
                            tya                             ; ini level data offset
ClearNextBufferByte         sta CL_ScoreBuf,y               ; clear HI score buffer
                            sta CL_LevelDataBuf,y           ; clear packed level data buffer
                            
                            iny                             ; inc buffer offset
                            bne ClearNextBufferByte         ; check: max - no: continue
                            
                            lda #CL_LevelNumDisk_Max_Init   ; get 149 blocks to write
                            sta CL_LevelNumDisk             ; ini disk level number 000-049
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; write 150 empty level blocks
; --------------------------------------------------------------------------------------------------------------------- ;
WriteNextLevelDataBlock     lda #CL_DiskWrite               ; get flag write 150 empty levels to disk
                            jsr DiskOperationHandler        ; write block to disk
                            
                            dec CL_LevelNumDisk             ; dec disk level number 000-049
                            
                            lda CL_LevelNumDisk             ; get disk level number 000-049
                            cmp #$ff                        ; test min
                            bne WriteNextLevelDataBlock     ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with loderunner disk string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length loderunner disk id string
SetNextDiskIdChar           lda TabLodeRuDiskId,y           ; get loderunner disk id=DANE BIGHAM
                            sta CL_ScoreBufDiskId,y         ; set store as loderunner disk id in HI score data block
                            
                            dey                             ; dec length loderunner disk id sting
                            bpl SetNextDiskIdChar           ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with player level id flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; flag CL_DiskUserData
                            sty CL_ScoreBufDiskFlag         ; set indicator store in Highscore block
; --------------------------------------------------------------------------------------------------------------------- ;
; write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; write out the leaderboard block
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskError                 Does    : jump back to start in case of a disk error
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskError                  .block                           ; 
                            jsr DiskCloseChannels           ; close all open channels on disk error
                            jmp StartGraficOut              ; display the start grafic screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecRead           Does    : read a block from disk into packed data buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecRead            .block                           ; 
                            lda #"1"                        ; get load command
                            sta TabDiskCmd_CmdType          ; set load command
                            
                            jsr CLRCHN                      ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: error - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk read command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get ini offset cmd string
PutNextDiskCmdCharRead      lda TabDiskCmd,y                ; get disk command string - u1:02 0 tt .ss
                            beq GoDiskCmdCheckRC            ; check: end of cmd string - yes: check RC
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc cmd string offset
                            jmp PutNextDiskCmdCharRead      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check rc
; --------------------------------------------------------------------------------------------------------------------- ;
GoDiskCmdCheckRC            jsr DiskCmdCheckRC              ; check the disk command return code
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            bcs DiskError                   ; check: disk error - yes: DiskError
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
; --------------------------------------------------------------------------------------------------------------------- ;
; read in disk buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
GetNextDiskByte             jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
smSetDiskReadBufPtr_Hi      = * + $02                       ; 
                            sta CL_LevelDataBuf,y           ; set get store disk data byte
                            
                            iny                             ; inc get byte count
                            bne GetNextDiskByte             ; check: 255 bytes read - no: continue
                            
                            jmp DiskCloseChannels           ; close all open channels on disk error
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecWrite          Does    : write a block from packed data buffer to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWrite           .block                           ; 
                            lda #"2"                        ; get command id write 
                            sta TabDiskCmd_CmdType          ; set u2=write
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; write out data buffer to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini level data pointer
smSetDiskWriteBufPtr_Hi     = * + $02                       ; 
GetNextPackedLevelDataByte  lda CL_LevelDataBuf,y           ; get data byte
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc level data pointer
                            bne GetNextPackedLevelDataByte  ; check: max - no: continue
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk write command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get command string offset
PutNextDiskCmdCharWrite     lda TabDiskCmd,y                ; get disk command string u2:02 0 tt ss
                            beq DiskCmdExecWriteX           ; check: EoC mmarker - yes: exit
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc command string offset
                            jmp PutNextDiskCmdCharWrite     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWriteX           jsr DiskCmdCheckRC              ; check the disk command return code
                            jmp DiskCloseChannels           ; close all open channels on disk error
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; <obsolete>
; --------------------------------------------------------------------------------------------------------------------- ;
FileNameString              .byte "#" ; 
FileNameString_Len          = * - FileNameString ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmd                  = *       ; 
                            .byte "u" ; user command id
TabDiskCmd_CmdType          .byte "1" ; user command type - 1=read  2=write
                            .byte ":" ; 
                            .byte "0" ; channel number
                            .byte "2" ; 
                            .byte " " ; 
                            .byte "0" ; drive number
                            .byte " " ; 
TabDiskCmd_Trk_Hi           .byte "0" ; track number HI
TabDiskCmd_Trk_Lo           .byte "3" ; track number LO
                            .byte " " ; 
TabDiskCmd_Sec_Hi           .byte "0" ; sector number HI
TabDiskCmd_Sec_Lo           .byte "0" ; sector number LO
                            
                            .byte CR  ; <ENTER>
TabDiskCmd_Len              = * - TabDiskCmd ; 
                            
                            .byte $00 ; end of command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdCheckRC            Does    : check the disk command return code
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRC             .block                           ; 
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            sta CLZ_WorkDiskRC              ; set disk RC number 1st part
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            ora CLZ_WorkDiskRC              ; insert disk RC number 2nd part
                            sta CLZ_WorkDiskRC              ; set combined disk RC number
                            
GetNextDiskMsgChar          jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            cmp #CR                         ; test <ENTER>
                            bne GetNextDiskMsgChar          ; check: EQ - no: read rest of the message
                            
                            lda CLZ_WorkDiskRC              ; get combined disk RC number
                            cmp #"0"                        ; test OK
                            beq DiskCmdCheckRCX             ; check: EQ - yes: good end
                            
                            jmp ColdStart                   ; bad end - disk error - restart
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRCX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCloseChannels         Does    : close all open channels on disk error
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCloseChannels          .block                           ; 
                            lda #SA_CHANNEL_CMD             ; 15 - command channel
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291); KERNAL - $FFC3 = Close a Logical File
                            
                            lda #$02                        ; 2 - data channel
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291); KERNAL - $FFC3 = Close a Logical File
                            jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F); KERNAL - $FFE7 = Close all Files
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelSpecialTileHandler   Does    : handle special level tiles and set up prepare gfx screen
;                           Expects : 
;                           Returns : .C=1 - no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
LevelSpecialTileHandler    .block                           ; 
                            ldy #CLZ_ScreenRow_Max          ; get max - start at bottom of screen
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #SPENA_ALL_OFF              ; get switch off sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data row pointers
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init row column offset to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CLZ_ScreenCol_Max          ; get max cols - start at rightmost column 
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get next level data col byte for this row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLevelDataByte        lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            
                            ldx CL_LevelLoad                ; get flag level disk load control
                            beq GoLevelTileOutToScreenPrep  ; check: loaded already - yes: nothing to do but output to prepare screen
; --------------------------------------------------------------------------------------------------------------------- ;
; handle hidden ladders
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LadderExit      ; test hidden ladder
                            bne HandleGold                  ; check: EQ - no: handle gold next
                            
                            ldx CL_ExitLadderCount          ; get actual number of hidden ladders
                            cpx #CL_ExitLadderCount_Max - $03 ; test max
                            bcs SetLevelTileBlank           ; check: GE - yes: do not count and blank it out
; --------------------------------------------------------------------------------------------------------------------- ;
; count hidden ladder and store its position
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_ExitLadderCount          ; inc number of hidden ladders
                            
                            inx                             ; inc table offset
                            lda CLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta CL_WA_ExitLadderRow,x       ; set row numer in hidden ladder row table
                            
                            tya                             ; get hidden ladder column
                            sta CL_WA_ExitLadderCol,x       ; set column number in hidden ladder column table
; --------------------------------------------------------------------------------------------------------------------- ;
; insert a blank level tile into game/ctrl level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelTileBlank           lda #CL_TileNum_Empty           ; get empty tile for hidden ladder/enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
GoLevelTileOutToScreenPrep  beq LevelTileOutToScreenPrep    ; always - branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level gold
; --------------------------------------------------------------------------------------------------------------------- ;
HandleGold                  cmp #CL_TileNum_Gold            ; test gold
                            bne HandleEnemies               ; check: EQ - no: handle enemy next
                            
                            inc CL_GoldToCollect            ; count level gold to collect
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level enemies
; --------------------------------------------------------------------------------------------------------------------- ;
HandleEnemies               cmp #CL_TileNum_Enemy           ; test enemy
                            bne HandleLoderunner            ; check: EQ - no: handle loderunner next
                            
                            ldx CL_EnemyCount               ; get number of enemies ($00-$05)
                            cpx #CL_EnemyCount_Max          ; test max of 5
                            bcs SetLevelTileBlank           ; check: GE - yes: bypass enemy 
                            
                            inc CL_EnemyToMoveNum           ; inc number of enemies to move
                            inc CL_EnemyCount               ; inc number of enemies ($00-$05)
                            
                            inx                             ; inc enemy count for table offset
                            tya                             ; get column number
                            sta CL_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda CLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta CL_SA_EnemyRow,x            ; set enemy save area row
                            
                            lda #$00                        ; get initial value
                            sta CL_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta CL_SA_EnemySprtNum,x        ; ini actual enemy sprite number
                            
                            lda #CL_PosOnImage_Center       ; get centered position
                            sta CL_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            sta CL_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty space
                            sta (CLZ_LevelDataCtrlPtrRow),y ; clear enemy in play level ctrl data ($0a00-$0bc3)
                            
                            lda #CL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #CL_TileNum_Enemy           ; get enemy tile
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargements
; --------------------------------------------------------------------------------------------------------------------- ;
GoSetNextLevelDataRowPtr    bpl SetNextLevelDataRowPtr      ; always - branch enlargement
GoGetNextLevelDataByte      bpl GetNextLevelDataByte        ; always - branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
HandleLoderunner            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne ChkTrapDoorDisplay          ; check: EQ - no: handle trapdoors next
; --------------------------------------------------------------------------------------------------------------------- ;
; take the 1st one only - ignore the rest
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            bpl SetLevelTileBlank           ; check: loderunner found already - yes: blank this one out
                            
                            sty CLZ_LodeRuCol               ; ini actual col loderunner
                            
                            ldx CLZ_ScreenRow               ; get screen row ($00-$0f)
                            stx CLZ_LodeRuRow               ; ini actual row loderunner
                            
                            ldx #CLZ_LodeRuOnImgPosX_Mid    ; get middle
                            stx CLZ_LodeRuOnImgPosX         ; ini loderunner pos on image left/right
                            stx CLZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            ldx #CLZ_LodeRuSprtNumRunRi_00  ; get sprite number run right start
                            stx CLZ_LodeRuSprtNum           ; ini loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty space
                            sta (CLZ_LevelDataCtrlPtrRow),y ; clear loderunner in play level ctrl data ($0a00-$0bc3)
                            
                            lda #CL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #CL_TileNum_LodeRunner      ; get loderunner tile
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; hide tap doors from display
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTrapDoorDisplay          cmp #CL_TileNum_BrickTrap       ; test trap door
                            bne LevelTileOutToScreenPrep    ; check: EQ - no
                            
                            lda #CL_TileNum_BrickSoft       ; get blank trap door gfx substitution
; --------------------------------------------------------------------------------------------------------------------- ;
; output level tile to prepare gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
LevelTileOutToScreenPrep    jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen column down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ScreenCol               ; set next screen col (00-1b) bottom up
                            ldy CLZ_ScreenCol               ; get screen col (00-1b)
                            bpl GoGetNextLevelDataByte      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ScreenRow               ; dec screen row (00-0f) - bottom up
                            ldy CLZ_ScreenRow               ; get screen row (00-0f)
                            bpl GoSetNextLevelDataRowPtr    ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; special level tiles handled - prepare gfx screen set up
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LevelLoad                ; get flag level disk load control
                            beq ScreenCopyDispToPrep        ; check: loaded already - yes: copy display to prepare screen
                            
                            lda CLZ_LodeRuCol               ; get actual col loderunner
                            bpl StatusAreaInit.GoStatusAreaInit ; check: loderunner tile found - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; error end no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set error flag no loderunner tile found
                            rts                             ; exit with error flag set
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenCopyDispToPrep      Does    : copy the display gfx hires screen data to the prepared hires gfx screen 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenCopyDispToPrep       .block                           ; 
                            lda CL_ColorLevel               ; get the actual level color
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            
                            lda #>CL_ScreenGfxDisplay       ; get display hires screen address HI
                            sta CLZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            lda #>CL_ScreenGfxPrepare       ; get prepare hires screen address HI
                            sta CLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            lda #$00                        ; get display/prepare hires screen address LO
                            sta CLZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            sta CLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            tay                             ; ini page offset
GetNextScrnGfxDispByte      lda (CLZ_ScreenGfxDisplayPtr),y ; get screen display byte
                            sta (CLZ_ScreenRowPreparePtr),y ; set screen prepare byte
                            
                            iny                             ; inc page offset
                            bne GetNextScrnGfxDispByte      ; check: page copied - no: continue
                            
                            inc CLZ_ScreenRowPreparePtr_Hi  ; inc screen prepare start of row pointer HI
                            inc CLZ_ScreenRowDisplayPtr_Hi  ; inc screen display start of row pointer LO
                            
                            ldx CLZ_ScreenRowDisplayPtr_Hi  ; get screen display start of row pointer LO
                            cpx #>CL_ScreenGfxPrepareEnd + $01 ; test end of copy reached
                            bcc GetNextScrnGfxDispByte      ; check: end of copy - no: continue
                            
                            clc                             ; set flag all ok
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusAreaInit            Does    : prepare the status rows on both gfx screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusAreaInit             .block                           ; 
                            lda #>CL_ScreenGfxPrepare       ; get gfx prepare screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            jsr ScreenCopyDispToPrep        ; copy prepared hires screen data to display screen
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            bne GameScreenPrepareClear      ; always - clear screen prepare from loderunner/enemy tiles
; --------------------------------------------------------------------------------------------------------------------- ;
GoStatusAreaInit            jmp StatusAreaInit              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq StatusAreaInit              ; <obsolete>
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameScreenPrepareClear    Does    : clear screen prepare from loderunner/enemy tiles
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameScreenPrepareClear     .block                           ; 
                            ldy #CLZ_ScreenRow_Max          ; get max
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
SetNextGameLevelTilePtr     lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #CLZ_ScreenCol_Max          ; get max cols
                            sty CLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextGameLevelTile        lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            beq GetGameLevelTileBlank       ; check: EQ - yes: substitute with a blank
                            
                            cmp #CL_TileNum_Enemy           ; test enemy
                            bne SetNextLevelDataPos         ; check: NE - yes: do not substitute
; --------------------------------------------------------------------------------------------------------------------- ;
; substitute lodrunner/enemy level tiles on prepare screen with blank
; --------------------------------------------------------------------------------------------------------------------- ;
GetGameLevelTileBlank       lda #CL_TileNum_Empty           ; get empty tile substitution
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen column
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataPos         dec CLZ_ScreenCol               ; dec screen col ($00-$1b)
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
                            bpl GetNextGameLevelTile        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ScreenRow               ; dec screen row ($00-$0f)
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            bpl SetNextGameLevelTilePtr     ; check: min - no: continue
                            
                            clc                             ; set flag good end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryHandler         Does    : check if the gamer score is worth an entry on the leaderboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryHandler          .block                           ; 
                            jsr GameNewChampionHandler      ; care for a new champion
; --------------------------------------------------------------------------------------------------------------------- ;
; check zero score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_Score_Lo                 ; combine score bytes
                            ora CL_Score_MidLo              ; 
                            ora CL_Score_MidHi              ; 
                            ora CL_Score_Hi                 ; 
                            beq ScoreEntryHandlerX          ; check: all zero - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; read in leaderbord block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            beq ScoreEntryHandlerX          ; check: CL_ScoreBufCheck_Bad - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard entries to work buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextDiskScoreByte        lda CL_ScoreBuf,y               ; get disk block data
                            sta CL_BufScoreWork,y           ; set work buffer data
                            
                            iny                             ; inc offset
                            bne GetNextDiskScoreByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; test if the score reached qualifies for a new leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; get entry count - start with entry one
GetNextScoreBufferOff       jsr ScoreEntryGetOff            ; get a correct score entry offset for both loderunner versions
                            
                            txa                             ; 
                            clc                             ; 
                            adc CL_ScoreOffset              ; add the version score offset
                            tax                             ; 
                            
                            lda CL_LevelNumGame             ; get game level number 001-050
                            cmp CL_ScoreBufLevel - CL_ScoreBufName_Len,x ; test score board entry - level
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda CL_Score_Hi                 ; get score HI
                            cmp CL_ScoreBufValue_Hi - CL_ScoreBufName_Len,x ; test score board entry - score HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda CL_Score_MidHi              ; get score MID HI
                            cmp CL_ScoreBufValue_Mid_Hi - CL_ScoreBufName_Len,x ; test score board entry - score MID HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda CL_Score_MidLo              ; get score MID LO
                            cmp CL_ScoreBufValue_Mid_Lo - CL_ScoreBufName_Len,x ; test score board entry - score MID LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda CL_Score_Lo                 ; get score LO
                            cmp CL_ScoreBufValue_Lo - CL_ScoreBufName_Len,x ; test score board entry - score LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
IncScoreEntryCount          iny                             ; inc entry count
                            cpy #CL_ScoreBufEntry_Max + $01 ; test max score entries
                            bcc GetNextScoreBufferOff       ; check: max reached - no: continue
                            
ScoreEntryHandlerX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryNew             Does    : insert the new gamer score into the leaderboard
;                           Expects : .Y=leaderboard entry number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryNew              .block                           ; 
                            cpy #CL_ScoreBufEntry_Max       ; test bottom of scrore entries
                            beq GetScoreEntryOff            ; check: EQ - yes: no insertion for enry 10 - simply overwrite
                            
                            sty CLZ_ScoreBoardOff           ; set number of new entry
; --------------------------------------------------------------------------------------------------------------------- ;
; open a score buffer slot for insertion of the new candidate
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CL_ScoreBufEntry_Max - $01 ; get max entries to move
GetNextScoreEntryOff        jsr ScoreEntryGetOff            ; get a correct score entry offset for both loderunner versions
                            
                            lda CL_ScoreOffset              ; get the version score offset
                            clc                             ; 
                            adc #CL_ScoreBufName_Len_Diff   ; add the difference between LR and CL
                            sta CLZ_WorkScoreEntryLen       ; set count
                            sta smScoreGetAdr               ; adapt the score fetch address
; --------------------------------------------------------------------------------------------------------------------- ;
; free a buffer entry for insertion by moving the entries one position down
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSourceByte           lda CL_ScoreBuf,x               ; get source
smScoreGetAdr               = * + $01                       ; 
                            sta CL_ScoreBuf,x               ; set target - move data one position down
                            
                            inx                             ; inc score buffer entry row offset
                            
                            dec CLZ_WorkScoreEntryLen       ; dec score buffer entry length
                            bne GetNextSourceByte           ; check: entry length min - no: continue
                            
                            cpy CLZ_ScoreBoardOff           ; test row offset of new entry
                            beq GetScoreEntryOff            ; 
                            
                            dey                             ; number of new entry not reached
                            bne GetNextScoreEntryOff        ; check: move next entry
; --------------------------------------------------------------------------------------------------------------------- ;
; get a version specific offset
; --------------------------------------------------------------------------------------------------------------------- ;
GetScoreEntryOff            jsr ScoreEntryGetOff            ; get a correct score entry offset for both loderunner versions
                            
                            lda CL_ScoreOffset              ; get the version score offset
                            sta CL_InputBufferPtr           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the new entry
; --------------------------------------------------------------------------------------------------------------------- ;
ClearNextEntryByte          lda #$a0                        ; <SHIFT_SPACE>
                            sta CL_ScoreBuf,x               ; 
                            
                            inx                             ; 
                            dec CL_InputBufferPtr           ; 
                            bne ClearNextEntryByte          ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new scorers data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LevelNumGame             ; get game level number 001-050
                            sta CL_ScoreBuf,x               ; 
                            
                            lda CL_Score_Hi                 ; 
                            sta CL_ScoreBufValue_Hi - CL_ScoreBufName_Len,x ; 
                            
                            lda CL_Score_MidHi              ; 
                            sta CL_ScoreBufValue_Mid_Hi - CL_ScoreBufName_Len,x ; 
                            
                            lda CL_Score_MidLo              ; 
                            sta CL_ScoreBufValue_Mid_Lo - CL_ScoreBufName_Len,x ; 
                            
                            lda CL_Score_Lo                 ; 
                            sta CL_ScoreBufValue_Lo - CL_ScoreBufName_Len,x ; 
                            
                            sty CLZ_WorkScoreNewEntryNum    ; save number of new entry
; --------------------------------------------------------------------------------------------------------------------- ;
; show new scores
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScoreShowLeaderboard        ; ShowScores
                            
                            lda CLZ_WorkScoreNewEntryNum    ; 
                            clc                             ; 
                            adc #$04                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            ldx #CL_InputBufferCheck_Char   ; preset old LR char check only
                            
                            lda #$07                        ; preset CL column
                            
                            ldy CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi SetOutCol                   ; check: championship LR - no: old LR
                            
                            sec                             ; 
                            sbc #$03                        ; adapt to LR column
                            
                            ldx #CL_InputBufferCheck_Both   ; get new CL check
                            
SetOutCol                   sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            lda CL_ScoreOffset              ; get the version score offset
                            sta CL_InputBufMaxLen           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get the new scorers name
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get input check flags
                            jsr GameGetPlayerInput          ; fill the input buffer with values of a given type
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the new scorers name from input buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_WorkScoreNewEntryNum    ; restore number of new entry
                            jsr ScoreEntryGetOff            ; get a correct score entry offset for both loderunner versions
                            
                            stx smScoreBuffOutAdr           ; 
                            
                            ldx CL_ScoreOffset              ; get the version score offset
                            dex                             ; dec the version score offset
GetNextInputBufChar         lda CL_InputBuffer,x            ; get a name byte
smScoreBuffOutAdr           = * + $01                       ; 
                            sta CL_ScoreBuf,x               ; set the name byte
                            
                            dex                             ; dec input buf char count
                            bpl GetNextInputBufChar         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; save the updated score buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini buffer offset
GetNextScoreBufByte         lda CL_ScoreBuf,y               ; get source bute
                            sta CL_BufScoreWorkNew,y        ; set target byte
                            
                            iny                             ; inc buffer offset
                            bne GetNextScoreBufByte         ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get leaderboard from disk with check
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskRead                ; get flag read score from disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            beq ScoreEntryNewX              ; check: OK - no
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard data back - prevent manipulations
; --------------------------------------------------------------------------------------------------------------------- ;
; check the disk data 1st
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextSaveScoreByte        lda CL_ScoreBuf,y               ; get new leaderboard byte from save buffer
                            cmp CL_BufScoreWork,y           ; test with leaderboard work buffer
                            bne RestoreOldScores            ; check: EQ - no: manipulated - restore old scores
                            
                            iny                             ; inc offset
                            bne GetNextSaveScoreByte        ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; restore scores from save buffer
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextBufByteNew           lda CL_BufScoreWorkNew,y        ; get saved score byte
                            sta CL_ScoreBuf,y               ; restore score byte
                            
                            iny                             ; inc offset
                            bne GetNextBufByteNew           ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; write scores back to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
                            
ScoreEntryNewX              jmp GameOver.DemoWaitInit       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; restore old scores
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreOldScores            ldy #$00                        ; ini offset
GetNextWorkScoreByte        lda CL_BufScoreWork,y           ; get work score byte
                            sta CL_ScoreBuf,y               ; restore score byte
                            
                            iny                             ; inc offset
                            bne GetNextWorkScoreByte        ; check: max - no: continue
                            
                            jmp GameOver.DemoWaitInit       ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreShowLeaderboard      Does    : show the leaderboard of 10 entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowLeaderboard       .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;     CHAMPIONSHIP LODE RUNNER
                            .byte " " | $80 ; <SHIFT_SPACE> ;           HIGH SCORES
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ;       NAME   LEVEL  SCORE
                            .byte "c" | $80 ;               ;     -------- ----- --------
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get initial value
                            sta CLZ_ScoreBoardRank          ; ini actual rank
                            
ScoreNextEntryOut           cmp #CL_ScoreBufEntry_Max       ; test 10th entry
                            bne GetChar_ShiftBlank          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; rank 10 starts with a "1"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get 1 - start rank 10 with a "1"
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda #$00                        ; get 0 - continue rank 10 with a "0"
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            jmp GetChar_Dot                 ; seperator dot
; --------------------------------------------------------------------------------------------------------------------- ;
; rank digits 1-9 start with a blank
; --------------------------------------------------------------------------------------------------------------------- ;
GetChar_ShiftBlank          lda #$a0                        ; rank 1-9 - start with <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            lda CLZ_ScoreBoardRank          ; get actual rank
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
GetChar_Dot                 lda #$ae                        ; "."
                            jsr TextOutCharHandler          ; control the output of a single char
; --------------------------------------------------------------------------------------------------------------------- ;
; blank out the gap between rank and name
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; preset gap count championship LR
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bpl SetGapLen_01                ; check: championship LR - yes
                            
                            ldy #$04                        ; get gap count old LR
                            
SetGapLen_01                sty CL_InputBufferPtr           ; set versioned gap length
                            
GetNextChar_ShiftBlank_01   lda #$a0                        ; get <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            dec CL_InputBufferPtr           ; dec versioned gap length
                            bne GetNextChar_ShiftBlank_01   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get score offset for this rank
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScoreBoardRank          ; actual rank
                            jsr ScoreEntryGetOff            ; get a correct score entry offset for both loderunner versions
                            
                            stx CLZ_ScoreBoardOff           ; set score board offset
                            
                            lda CL_ScoreOffset              ; get the version score offset
                            sta CL_InputBufferPtr           ; set score buffer offset
                            
                            clc                             ; 
                            adc CLZ_ScoreBoardOff           ; add version score board offset
                            tay                             ; 
                            
                            lda CL_ScoreBuf,y               ; get version score board value
                            bne GetNextScorerNameChar       ; check: <ZERO> - no
                            
                            jmp GoScoreSetNextRow           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer name or initials
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScorerNameChar       ldy CLZ_ScoreBoardOff           ; score board offset
                            lda CL_ScoreBuf,y               ; 
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            inc CLZ_ScoreBoardOff           ; inc score board offset
                            dec CL_InputBufferPtr           ; dec name length of input buffer
                            bne GetNextScorerNameChar       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; blank out the gap between name and level reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$02                        ; preset gap count championship LR 
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bpl SetGapLen_02                ; check: championship LR - yes
                            
                            ldy #$04                        ; get gap count old LR
                            
SetGapLen_02                sty CL_InputBufferPtr           ; set versioned gap length
                            
GetNextChar_ShiftBlank_02   lda #$a0                        ; <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            dec CL_InputBufferPtr           ; dec versioned gap length
                            bne GetNextChar_ShiftBlank_02   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer level reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScoreBoardOff           ; score board offset
                            lda CL_ScoreBuf,y               ; 
                            jsr ConvertHexToDec             ; Hex2Dec  (1307=100 1308=10 1309=1)
                            
                            lda CL_Digit_100                ; 
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_10                 ; 
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; 
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
; fix gap between level and score
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer score reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScoreBoardOff           ; get score board offset
                            lda CL_ScoreBufValue_Hi - CL_ScoreBufName_Len,y ; 
                            jsr ScoreSplitDigit             ; split a byte compressed decimal into two bytes
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy CLZ_ScoreBoardOff           ; score board offset
                            lda CL_ScoreBufValue_Mid_Hi - CL_ScoreBufName_Len,y ; 
                            jsr ScoreSplitDigit             ; split a byte compressed decimal into two bytes
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy CLZ_ScoreBoardOff           ; score board offset
                            lda CL_ScoreBufValue_Mid_Lo - CL_ScoreBufName_Len,y ; 
                            jsr ScoreSplitDigit             ; split a byte compressed decimal into two bytes
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy CLZ_ScoreBoardOff           ; score board offset
                            lda CL_ScoreBufValue_Lo - CL_ScoreBufName_Len,y ; 
                            jsr ScoreSplitDigit             ; split a byte compressed decimal into two bytes
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
GoScoreSetNextRow           jsr TextCharOutNewLine          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; inc leaderboard rank
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScoreBoardRank          ; inc rank
                            lda CLZ_ScoreBoardRank          ; get next rank
                            cmp #$0b                        ; test max
                            bcs ShowLeaderboard             ; check: GE - yes: finished
                            
                            jmp ScoreNextEntryOut           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ShowLeaderboard             lda #$10                        ; get output row number
                            jmp ScoreShowTopScorer          ; show a possible top scorers message and score
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryGetOff          Does    : get a correct score entry offset for both loderunner versions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryGetOff           .block                           ; 
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bpl GetOffset_CL                ; check: championship LR - yes
                            
                            ldx TabScoreEntryOff_LR - $01,y ; old LR
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetOffset_CL                ldx TabScoreEntryOff_CL - $01,y ; get CL scrore entry offset
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreEntryOff_LR         = *       ; 
                            .byte $00 * CL_ScoreBufEntry_Len_Old ; $00
                            .byte $01 * CL_ScoreBufEntry_Len_Old ; $08
                            .byte $02 * CL_ScoreBufEntry_Len_Old ; $10
                            .byte $03 * CL_ScoreBufEntry_Len_Old ; $18
                            .byte $04 * CL_ScoreBufEntry_Len_Old ; $20
                            .byte $05 * CL_ScoreBufEntry_Len_Old ; $28
                            .byte $06 * CL_ScoreBufEntry_Len_Old ; $30
                            .byte $07 * CL_ScoreBufEntry_Len_Old ; $38
                            .byte $08 * CL_ScoreBufEntry_Len_Old ; $40
                            .byte $09 * CL_ScoreBufEntry_Len_Old ; $48
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreEntryOff_CL         = *       ; 
                            .byte $00 * CL_ScoreBufEntry_Len     ; $00
                            .byte $01 * CL_ScoreBufEntry_Len     ; $0d
                            .byte $02 * CL_ScoreBufEntry_Len     ; $1a
                            .byte $03 * CL_ScoreBufEntry_Len     ; $27
                            .byte $04 * CL_ScoreBufEntry_Len     ; $34
                            .byte $05 * CL_ScoreBufEntry_Len     ; $41
                            .byte $06 * CL_ScoreBufEntry_Len     ; $4e
                            .byte $07 * CL_ScoreBufEntry_Len     ; $5b
                            .byte $08 * CL_ScoreBufEntry_Len     ; $68
                            .byte $09 * CL_ScoreBufEntry_Len     ; $75
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreShowTopScorer        Does    : eventually show the top scorere message and score
;                           Expects : .A=screen row
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowTopScorer         .block                           ; 
                            sta CLZ_ScreenRow               ; 
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi ScoreShowTopScorerX         ; check: championship LR - no: old LR
; --------------------------------------------------------------------------------------------------------------------- ;
; check for a top scorer victory score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_ScoreBufTopScore_Hi      ; check top scorer score
                            ora CL_ScoreBufTopScore_Mid_Hi  ; 
                            ora CL_ScoreBufTopScore_Mid_Lo  ; 
                            ora CL_ScoreBufTopScore_Lo      ; 
                            beq ScoreShowTopScorerX         ; nobody passed the last level so far
                            
                            ldx #$00                        ; get initial value
                            stx CL_WorkTextOutputLen        ; ini output offset
                            stx CLZ_ScreenCol               ; ini screen col ($00 - $1b)
                            stx CLZ_WorkTopMsgCheck         ; ini top message check value
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
; --------------------------------------------------------------------------------------------------------------------- ;
; output a possible top scorer victory message
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextTopMsgByte           lda CL_ScoreBufTopMsg,x         ; get top scorere message byte
                            pha                             ; save msg text char
                            
                            eor #$a0                        ; flip with <SHIFT_SPACE>
                            ora CLZ_WorkTopMsgCheck         ; insert old msg check value
                            sta CLZ_WorkTopMsgCheck         ; set new msg check value
                            
                            pla                             ; restore msg text char
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            inc CL_WorkTextOutputLen        ; inc output offset
                            ldx CL_WorkTextOutputLen        ; get output offset
                            cpx #CL_ScoreBufTopMsg_Len      ; test max
                            bcc GetNextTopMsgByte           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; check the top scorer victory message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_WorkTopMsgCheck         ; get top srorer message check
                            beq ScoreShowTopScorerX         ; check: msg available - no: still blank
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00 - $1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output a possible top scorer victory score if a message was set
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_ScoreBufTopScore_Hi      ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            lda CL_ScoreBufTopScore_Mid_Hi  ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            lda CL_ScoreBufTopScore_Mid_Lo  ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
                            lda CL_ScoreBufTopScore_Lo      ; 
                            jsr ScoreSplitDigitStatusOut    ; split a score digit an output to status row
                            
ScoreShowTopScorerX         rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreEntryOff_LR_Unused  = *                                  ; 
                            .byte $00 * CL_ScoreBufEntry_Len_Old ; $00
                            .byte $00 * CL_ScoreBufEntry_Len_Old ; $00
                            .byte $01 * CL_ScoreBufEntry_Len_Old ; $08
                            .byte $02 * CL_ScoreBufEntry_Len_Old ; $10
                            .byte $03 * CL_ScoreBufEntry_Len_Old ; $18
                            .byte $04 * CL_ScoreBufEntry_Len_Old ; $20
                            .byte $05 * CL_ScoreBufEntry_Len_Old ; $28
                            .byte $06 * CL_ScoreBufEntry_Len_Old ; $30
                            .byte $07 * CL_ScoreBufEntry_Len_Old ; $38
                            .byte $08 * CL_ScoreBufEntry_Len_Old ; $40
                            .byte $09 * CL_ScoreBufEntry_Len_Old ; $48
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; InputKeySubstitute        Does    : get a raw input char substitution value
;                           Expects : .A=raw char
;                           Returns : .A=raw char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
InputKeySubstitute         .block                           ; 
                            cmp #$82                        ; test <CURSOR LEFT>
                            bne GetKeySubstTabValue         ; check: EQ - no
                            
                            lda #$07                        ; get <CURSOR UP> replacement value
                            
GetKeySubstTabValue         tay                             ; set key as key substitution table offset
                            lda TabKeySubstValue,y          ; get key substitution table value
                            ora #$80                        ; set bit7
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabKeySubstValue            = *       ; 
                            .byte $00 ; $00 - <INS/DEL
                            .byte $0d ; $01 - <RETURN>
                            .byte $15 ; $02 - <CURSOR LEFT>
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $03 - F7          - ignore
                            .byte $ff ; $04 - F1          - ignore
                            .byte $ff ; $05 - F3          - ignore
                            .byte $ff ; $06 - F5          - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $08 ; $07 - <CURSOR UP>
                            .byte $33 ; $08 - 3
                            .byte $57 ; $09 - W
                            .byte $41 ; $0a - A
                            .byte $34 ; $0b - 4
                            .byte $5a ; $0c - Z
                            .byte $53 ; $0d - S
                            .byte $45 ; $0e - E
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $0f - SHIFT Left  - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $35 ; $10 - 5
                            .byte $52 ; $11 - R
                            .byte $44 ; $12 - D
                            .byte $36 ; $13 - 6
                            .byte $43 ; $14 - C
                            .byte $46 ; $15 - F
                            .byte $54 ; $16 - T
                            .byte $58 ; $17 - X
                            .byte $37 ; $18 - 7
                            .byte $59 ; $19 - Y
                            .byte $47 ; $1a - G
                            .byte $38 ; $1b - 8
                            .byte $42 ; $1c - B
                            .byte $48 ; $1d - H
                            .byte $55 ; $1e - U
                            .byte $56 ; $1f - V
                            .byte $39 ; $20 - 9
                            .byte $49 ; $21 - I
                            .byte $4a ; $22 - J
                            .byte $30 ; $23 - 0
                            .byte $4d ; $24 - M
                            .byte $4b ; $25 - K
                            .byte $4f ; $26 - O
                            .byte $4e ; $27 - N
                            .byte $2b ; $28 - +
                            .byte $50 ; $29 - P
                            .byte $4c ; $2a - L
                            .byte $2d ; $2b - 
                            .byte $2e ; $2c - .
                            .byte $3a ; $2d - :
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $2e - @           - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $2c ; $2f - ,
                            .byte $5c ; $30 - £
                            .byte $2a ; $31 - *
                            .byte $3b ; $32 - ;
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $33 - CLR/HOME    - ignore
                            .byte $ff ; $34 - SHIFT RIGHT - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $3d ; $35 - =
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $36 - ARROW UP    - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $2f ; $37 - /
                            .byte $31 ; $38 - 1
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $39 - ARROW LEFT  - ignore
                            .byte $ff ; $3a - CTRL        - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $32 ; $3b - 2
                            .byte $20 ; $3c - SPACE
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $3d - C=          - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $51 ; $3e - Q
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $3f - RUN/STOP    - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameNewChampionHandlerX   Does    : GameNewChampionHandler bad exit point
;                           Expects : 
;                           Returns : .C=0 - no new champion
; --------------------------------------------------------------------------------------------------------------------- ;
GameNewChampionHandlerX    .block                           ; 
                            clc                             ; set flag good end
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameNewChampionHandler    Does    : care for a new champion
;                           Expects : 
;                           Returns : .C=0 - no new champion
;                                   : .C=1 - a new champion was born
; --------------------------------------------------------------------------------------------------------------------- ;
GameNewChampionHandler     .block                           ; 
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda CL_ScoreVersionId           ; keeps the 1st char of id string dANE BIGHAM
                            bmi GameNewChampionHandlerX     ; check: championship LR - no: old LR - bad exit
                            
                            lda CL_LevelNumGame             ; get game level number 001-050
                            cmp #CL_LevelNumGame_Max        ; test 051
                            bcc GameNewChampionHandlerX     ; check: LT - yes: no champion until now - bad exit
; --------------------------------------------------------------------------------------------------------------------- ;
; there was a new champion who solved the last level
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #>CL_ScreenGfxDisplay       ; get gfx display screen
                            sta CLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            lda #HR_YELLOW_CYAN             ; 
                            jsr ColorLevel                  ; fill the multicolor hires screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "-" | $80 ;               ; ----- CONGRATULATIONS -----
                            .byte "-" | $80 ;               ;          YOU ARE A
                            .byte "-" | $80 ;               ;    LODE RUNNER CHAMPION
                            .byte "-" | $80 ;               ; ----- CONGRATULATIONS -----
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_ScoreBufTopScore_Hi      ; get saved old best score HI
                            cmp CL_Score_Hi                 ; test with new score
                            beq CheckScore_Mid_Hi           ; check: EQ - yes: check next
                            bcs GoSecretCodeHandling        ; check: GE - yes: secret code input
                            
                            jmp OutTopScoreMsg              ; new top score
; --------------------------------------------------------------------------------------------------------------------- ;
CheckScore_Mid_Hi           lda CL_ScoreBufTopScore_Mid_Hi  ; get saved old best score mid HI
                            cmp CL_Score_MidHi              ; test with new score
                            beq CheckScore_Mid_Lo           ; check: EQ - yes: check next
                            bcs GoSecretCodeHandling        ; check: GE - yes: secret code input
                            
                            jmp OutTopScoreMsg              ; new top score
; --------------------------------------------------------------------------------------------------------------------- ;
CheckScore_Mid_Lo           lda CL_ScoreBufTopScore_Mid_Lo  ; get saved old best score mid LO
                            cmp CL_Score_MidLo              ; test with new score
                            beq CheckScore_Lo               ; check: EQ - yes: check next
                            bcs GoSecretCodeHandling        ; check: GE - yes: secret code input
                            
                            jmp OutTopScoreMsg              ; new top score
; --------------------------------------------------------------------------------------------------------------------- ;
CheckScore_Lo               lda CL_ScoreBufTopScore_Lo      ; get saved old best score LO
                            cmp CL_Score_Lo                 ; test with new score
                            bcc OutTopScoreMsg              ; check: LT - yes
                            
GoSecretCodeHandling        jmp SecretCodeHandling          ; no new top score - only secret code input
; --------------------------------------------------------------------------------------------------------------------- ;
; new top score message
; --------------------------------------------------------------------------------------------------------------------- ;
OutTopScoreMsg              lda #$20                        ; <obsolete>
                            
                            lda #HR_GREEN_GREEN             ; get colour value
                            ldx #$a0                        ; ini champion msg text screen area length
SetNextChampTextColor       sta CL_ScreenStartGfx + $c8,x   ; color text 'you are a lode runner champion'
                            
                            dex                             ; dec champion msg text screen area length
                            bne SetNextChampTextColor       ; check: min - no: continue
                            
                            lda #$00                        ; 
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            lda #$09                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "y" | $80 ;               ; YOUR SCORE IS THE BEST EVER
                            .byte "o" | $80 ;               ;  ENTER YOUR VICTORY MESSAGE
                            .byte "u" | $80 ;               ;    >                   <
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "v" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; get the top scrorer victory message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$04                        ; get start column number
                            sta CLZ_ScreenCol               ; set screen col ($00 - $1b)
                            
                            lda #CL_InputBufferLen          ; get buffer length
                            sta CL_InputBufMaxLen           ; set buffer length
                            
                            jsr GameGetPlayerInputAll       ; fill the input buffer with numeric or char values
                            beq SecretCodeHandling          ; secret code input
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the top scrorer victory message text
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_InputBufferLen          ; get initial value
GetNextInputBufByte         lda CL_InputBuffer,x            ; copy msg to high score data
                            sta CL_ScoreBufTopMsg,x         ; 
                            
                            dex                             ; dec input buffer length
                            bpl GetNextInputBufByte         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the top scrorer score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_Score_Lo                 ; copy score to high score data
                            sta CL_ScoreBufTopScore_Lo      ; 
                            
                            lda CL_Score_MidLo              ; 
                            sta CL_ScoreBufTopScore_Mid_Lo  ; 
                            
                            lda CL_Score_MidHi              ; 
                            sta CL_ScoreBufTopScore_Mid_Hi  ; 
                            
                            lda CL_Score_Hi                 ; 
                            sta CL_ScoreBufTopScore_Hi      ; 
                            
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; handle secrect code input
; --------------------------------------------------------------------------------------------------------------------- ;
; clear previous message
; --------------------------------------------------------------------------------------------------------------------- ;
SecretCodeHandling          lda #$09                        ; get row number for 'your score ...'
                            jsr ScoreCLearOutputArea        ; clear the given rows output columns
                            
                            lda #$0b                        ; get row number for 'Enter your ..."
                            jsr ScoreCLearOutputArea        ; clear the given rows output columns
                            
                            lda #$0d                        ; get row number for <VICTORY MSG>
                            jsr ScoreCLearOutputArea        ; clear the given rows output columns
                            
                            lda #$0a                        ; get row number for next message
                            sta CLZ_ScreenRow               ; set screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "d" | $80 ;               ; DO YOU WANT TO KNOW YOUR
                            .byte "o" | $80 ;               ; SECRET PASSWORD (Y/N)
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "w" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; ask for the secret code input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            ldx #CL_KeyNew_None             ; get initial value
                            stx CL_KeyNew                   ; discard input key
                            
                            cmp #$19                        ; test "y"
                            beq OutSerialInfoMsg            ; check: EQ - yes
                            
                            sec                             ; set flag good end
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle secret code input
; --------------------------------------------------------------------------------------------------------------------- ;
OutSerialInfoMsg            lda #$0a                        ; 
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "c" | $80 ;               ; CAREFULLY TYPE IN THE SERIAL
                            .byte "a" | $80 ;               ; NUMBER ON YOUR CHAMPIONSHIP
                            .byte "r" | $80 ;               ;     REGISTRATION CARD
                            .byte "e" | $80 ;               ;           >     <
                            .byte "f" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "n" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "<" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; serial code input handler
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0b                        ; get initial value
                            sta CLZ_ScreenCol               ; screen col ($00 - $1b)
                            
                            lda #CL_SerialNumber_Len        ; get serial number length
                            sta CL_InputBufMaxLen           ; set serial number length
                            
                            lda #CL_InputBufferCheck_Num    ; 
                            jsr GameGetPlayerInput          ; fill the input buffer with values of a given type
                            jsr GameUniquePlayIdCheck       ; check the play ID for this session to avoid disk swap
                            
                            lda CL_ScoreBufSerNumCount      ; get actual serial input count
                            cmp #CL_ScoreBufSerNumCount_Max ; test max
                            bcs OutUniqueSecretPswdMsg      ; check: GE - yes
                            
                            inc CL_ScoreBufSerNumCount      ; inc serial input count
; --------------------------------------------------------------------------------------------------------------------- ;
; write back serial number input count
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; read or write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; convert input numbers to binary
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$03                        ; get input buffer length - omit the first digit
GetNextSerialNumByte        lda CL_SerialNumDigit_02,x      ; 
                            sec                             ; 
                            sbc #$b0                        ; correct input value to $00-$09
                            sta CL_SerialNumDigit_02,x      ; 
                            
                            dex                             ; dec input buffer length
                            bpl GetNextSerialNumByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; generate secret code char 1
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SerialNumDigit_02        ; get number 2
                            clc                             ; 
                            adc CL_SerialNumDigit_03        ; add number 3
                            tax                             ; set as table index
                            
                            lda TabCcomputerVendorNames,x   ; get a char from 'Apple Commodore Atari'
                            sta TabSecretCodeChar_01        ; set secret code char 1
; --------------------------------------------------------------------------------------------------------------------- ;
; generate secret code char 2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SerialNumDigit_03        ; get input number 3
                            clc                             ; 
                            adc CL_SerialNumDigit_04        ; add input number 4
                            tax                             ; set as index
                            
                            lda TabCcomputerVendorNames,x   ; get a char from 'Apple Commodore Atari'
                            sta TabSecretCodeChar_02        ; set secret code char 2
; --------------------------------------------------------------------------------------------------------------------- ;
; generate secret code char 3
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SerialNumDigit_04        ; get input number 4
                            clc                             ; 
                            adc CL_SerialNumDigit_05        ; add input number 5
                            tax                             ; 
                            
                            lda TabCcomputerVendorNames,x   ; Apple Commodore Atari
                            sta TabSecretCodeChar_03        ; set secret code char 3
; --------------------------------------------------------------------------------------------------------------------- ;
; generate secret code char 4
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SerialNumDigit_05        ; get input number 5
                            clc                             ; 
                            adc CL_SerialNumDigit_02        ; add input number 2
                            tax                             ; 
                            
                            lda TabCcomputerVendorNames,x   ; get a char from 'Apple Commodore Atari'
                            sta TabSecretCodeChar_04        ; set secret code char 4
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
OutUniqueSecretPswdMsg      jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #$06                        ; get msg row number
                            sta CLZ_ScreenRow               ; set screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "b" | $80 ;               ; BELOW IS YOUR UNIQUE SECRET
                            .byte "e" | $80 ;               ; PASSWORD.  WRITE IT ON YOUR
                            .byte "l" | $80 ;               ; REGISTRATION CARD RIGHT NOW
                            .byte "o" | $80 ;               ;  AND MAIL IT TO BRODERBUND
                            .byte "w" | $80 ;               ;     AS SOON AS POSSIBLE
                            .byte " " | $80 ; <SHIFT_SPACE> ;          >CQADI<
                            .byte "i" | $80 ;               ;         HIT  A KEY
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "q" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "p" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "w" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte ">" | $80 ;               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "c" | $80 ;               ; 
TabSecretCodeChar_01        .byte "q" | $80 ;               ; 
TabSecretCodeChar_02        .byte "a" | $80 ;               ; 
TabSecretCodeChar_03        .byte "d" | $80 ;               ; 
TabSecretCodeChar_04        .byte "i" | $80 ;               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "<" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            jsr GameWaitBlinkCursor         ; blink the cursor while waiting for player input
                            
                            lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; discard input key
                            
                            sec                             ; set flag good end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabCcomputerVendorNames      = *      ; 
                            .byte "a" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveHandler         Does    : control the loderunner moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandler          .block                           ; 
                            lda #CL_LodeRuGetGold_Picked    ; get flag gold collected completely
                            sta CL_LodeRuGetGold            ; set flag get gold  $00=just gets it
; --------------------------------------------------------------------------------------------------------------------- ;
; check shooting first
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq LodeRuMoves                 ; check: shoot - no: move him
                            bpl GoLodeRuShootRight          ; check: shoot right - yes
                            
                            jmp LodeRuShootLeft             ; shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuShootRight          jmp LodeRuShootRight            ; shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoves                 ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile loderunner is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)  = data 'under' lr
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            bne ChkOnImagePosY_Left         ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is in the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #CLZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is left of the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
ChkOnImagePosY_Left         lda CLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #CLZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            bcc LodeRuFallsDown             ; check: LT - yes: below center
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is on bottom row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            cpy #CLZ_ScreenRow_Max          ; test max rows
                            beq GoStopFallingStartMoving    ; check: EQ - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is empty - let him fall down then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty tile
                            beq LodeRuFallsDown             ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne LodeRuFallsDown             ; check: EQ - no: loderunner falls down
                            
GoStopFallingStartMoving    jmp StopFallingStartMoving      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuFallsDown             lda #CL_LodeRuFallsDown_Yes     ; get flag loderunner falls down
                            sta CL_LodeRuFallsDown          ; set loderunner falls down
; --------------------------------------------------------------------------------------------------------------------- ;
; step fall beep down 
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CL_TuneBeepFall             ; dec fall beep
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #CLZ_LodeRuSprtNumFallLe    ; get sprite number fall left
                            
                            ldx CLZ_LodeRuShootMode         ; get shoot mode
                            bmi SetLodeRuSpriteNum          ; check: CLZ_LodeRuShootMode_Front - yes
                            
                            lda #CLZ_LodeRuSprtNumFallRi    ; get sprite number fall right
                            
SetLodeRuSpriteNum          sta CLZ_LodeRuSprtNum           ; set loderunner sprite number
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc CLZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image
                            
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #CLZ_LodeRuOnImgPosY_Max + $01 ; test beyond max
                            bcs SetOnImagePosY_Start        ; check: GE - yes: reinit to start
                            
                            jsr LodeRuGetGold               ; pic up and score the gold
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
SetOnImagePosY_Start        lda #CLZ_LodeRuOnImgPosY_Min    ; get min
                            sta CLZ_LodeRuOnImgPosY         ; set loderunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetLevelGameTile            ; check: EQ - no
                            
                            lda #CL_TileNum_Empty           ; get empty tile substitution
                            
SetLevelGameTile            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row below old loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set the game level tile under new loderunner row to loderunner tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda #CL_TileNum_LodeRunner      ; get loderunner
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; end of loderunner fall down
; --------------------------------------------------------------------------------------------------------------------- ;
StopFallingStartMoving      lda CL_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
                            bne GetEndOfFall                ; check: end of fall - yes <obsolete>
                            
GetEndOfFall                lda #CL_LodeRuFallsDown_No      ; get end of fall
                            sta CL_LodeRuFallsDown          ; set end of fall
; --------------------------------------------------------------------------------------------------------------------- ;
; check move direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions up/down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_JoystickMoveDirY         ; get move direction up/down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesUp            cmp #CL_JoystickMoveDirY_Up     ; test move up
                            bne ChkLodeRuMovesDown          ; check: EQ - no: check move down
                            
                            jsr LodeRunMoveUp               ; try to move him up
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved up
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesDown          cmp #CL_JoystickMoveDirY_Do     ; test move down
                            bne ChkLodeRuShootLeft          ; check: EQ - no: check shoot left
                            
                            jsr LodeRuMoveDown              ; try to move him down
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootLeft          cmp #CL_JoystickShoot_Le        ; test shoot left
                            bne ChkLodeRuShootRight         ; check: EQ - no: check shoot right
                            
                            jsr LodeRuShootLeftInit         ; try to shoot left
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootRight         cmp #CL_JoystickShoot_Ri        ; test shoot right
                            bne GetLodeRuMoveDirLeRi        ; check: EQ - no: check moves left/right
                            
                            jsr LodeRuShootRightInit        ; try to shoot right
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions left/right
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuMoveDirLeRi        lda CL_JoystickMoveDirX         ; get get move direction left/right
                            cmp #CL_JoystickMoveDirX_Le     ; test move left
                            bne ChkLodeRuMovesRight         ; check: EQ - no: check move right
                            
                            jmp LodeRuMoveLeft              ; try to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesRight         cmp #CL_JoystickMoveDirX_Ri     ; test move right
                            bne LodeRuMoveHandlerX          ; check: EQ - no: exit
                            
                            jmp LodeRuMoveRight             ; try to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandlerX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveLeft            Does    : try to move loderunner left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeft             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on right side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #CLZ_LodeRuOnImgPosX_Mid + $01 ; test loderunner right of image center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on max left col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuMoveLeftImpossible    ; check: max left - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile left of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move left
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeftImpossible    rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #CLZ_LodeRuShootMode_Front  ; get shoot to front of loderunner
                            sta CLZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            dec CLZ_LodeRuOnImgPosX         ; loderunner pos on image left/right = one step left
                            bpl GoLodeRuGetGold             ; check: move from actual to next left field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #CL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_LodeRuCol               ; dec actual col loderunner
                            dey                             ; dec column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_LodeRunner      ; get loderunner
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner max PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_LodeRuOnImgPosX_Max    ; get max right
                            sta CLZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            bne GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_LodeRuSprtNumRunLe_00  ; get sprite numbers move left min
                            ldx #CLZ_LodeRuSprtNumRunLe_02  ; get sprite numbers move left max
                            bne SetNextSpriteNumber         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole left
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #CLZ_LodeRuSprtNumPoleLe_00 ; get sprite numnumber hang along a pole left min
                            ldx #CLZ_LodeRuSprtNumPoleLe_02 ; get sprite numnumber hang along a pole left max
                            
SetNextSpriteNumber         jsr LodeRuMoveSpriteNumRotate   ; rotate sprite number between minimum and maximum values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveRight           Does    : try to move loderunner right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRight            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on left side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #CLZ_LodeRuOnImgPosX_Mid    ; test loderunner left of image center
                            bcc GoGetLodeRuPosXY            ; check: LT - yes: left of center
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lodreunner is an max right col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            cpy #CLZ_ScreenCol_Max          ; test max right
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move right 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRightImpossible   rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #CLZ_LodeRuShootMode_Back   ; get shoot to back of loderunner
                            sta CLZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            inc CLZ_LodeRuOnImgPosX         ; inc loderunner pos on image left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cmp #CLZ_LodeRuOnImgPosX_Max + $01 ; test max PosX
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #CL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_LodeRuCol               ; inc actual col loderunner
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_LodeRunner      ; get loderunner
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner min PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_LodeRuOnImgPosX_Min    ; get min right
                            sta CLZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            beq GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_LodeRuSprtNumRunRi_00  ; get sprite numbers move right min
                            ldx #CLZ_LodeRuSprtNumRunRi_02  ; get sprite numbers move right max
                            bne GoGoSetNextSpriteNumber     ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole right
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #CLZ_LodeRuSprtNumPoleRi_00 ; get sprite numnumber hang along a pole right min
                            ldx #CLZ_LodeRuSprtNumPoleRi_02 ; get sprite numnumber hang along a pole right max
                            
GoGoSetNextSpriteNumber     jsr LodeRuMoveSpriteNumRotate   ; rotate sprite number between minimum and maximum values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRunMoveUp             Does    : try to move loderunner up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRunMoveUp              .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq GetLodeRuImagePosY          ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #CLZ_LodeRuOnImgPosY_Mid + $01 ; test loderunner above the image center
                            bcc LodeRuMoveUpImpossible      ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile beyond loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3) + 1 = data below lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile beyond loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq GoGetLodeRuPosXY            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; no ladder/blocked/on top row already - impossible to move up
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveUpImpossible      sec                             ; exit with flag no move up possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          ldy CLZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #CLZ_LodeRuOnImgPosY_Mid + $01 ; test below center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on top of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            beq LodeRuMoveUpImpossible      ; check: top of screen - yes: no further move up possible
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo - $01,y  ; get expanded level data row pointer lo
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi - $01,y ; get expanded level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game level tile above loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) - 1 = data above lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            dec CLZ_LodeRuOnImgPosY         ; loderunner pos on image up/down = one step up
                            bpl GoLodeRuGetGold             ; check: move from actual to next up field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #CL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_LodeRuRow               ; dec actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda #CL_TileNum_LodeRunner      ; get loderunner
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            lda #CLZ_LodeRuOnImgPosY_Max    ; get max PosY
                            sta CLZ_LodeRuOnImgPosY         ; ini loderunner vertical PosY on image
                            bne GetSpriteNumLimitsMoveUpDo  ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number ladder
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumLimitsMoveUpDo  lda #CLZ_LodeRuSprtNumLadder_00 ; get sprite numbers climb up/do min
                            ldx #CLZ_LodeRuSprtNumLadder_01 ; get sprite numbers climb up/do max
                            jsr LodeRuMoveSpriteNumRotate   ; rotate sprite number between minimum and maximum values
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                            
                            clc                             ; set flag move up was successfulgood end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveDown            Does    : try to move loderunner down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDown             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cpy #CLZ_LodeRuOnImgPosY_Mid    ; test above center of screen image
                            bcc GetLodeRuImagePosY          ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on the bottom of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            cpy #CLZ_ScreenRow_Max          ; test bottom of screen
                            bcs LodeRuMoveDownImpossible    ; check: GE - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveDownImpossible    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne GetLodeRuImagePosY          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked/on bottom row already - impossible to move down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDownImpossible    sec                             ; exit with flag no move down possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc CLZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image - one step down
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #CLZ_LodeRuOnImgPosY_Max + $01 ; test still on screen image
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #CL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda #CL_TileNum_LodeRunner      ; get loderunner
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init lodrunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_LodeRuOnImgPosY_Min    ; get min
                            sta CLZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            jmp LodeRunMoveUp.GetSpriteNumLimitsMoveUpDo ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jmp LodeRunMoveUp.GoLodeRuGetGold ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftX          Does    : switch off loderunner shoot left/right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftX           .block                           ; 
                            jmp LodeRuShootLeft.SetLodeRuShootFinish ; set flag shoot finished and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftInit       Does    : init try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftInit        .block                           ; 
                            lda #CL_LodeRuShoot_Le          ; get shoot left
                            sta CL_LodeRuShoot              ; ini shoot
                            sta CL_JoystickMoveDirY         ; ini movedir Y
                            sta CL_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabImageNumShootSparkLe_Min; get initial value
                            sta CLZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeft           Does    : try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeft            .block                           ; 
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            bcs LodeRuShootLeftX            ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on leftmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuShootLeftX            ; check: leftmost position - yes: no room left for shoot left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile below left of loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below left of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootLeftX            ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile left of loderunner is empty - an enemy may interrupt the process
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one position left
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #CL_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoLe   ; check: EQ - no: blocked no shoot left possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
                            lda #CLZ_LodeRuSprtNumRunLe_00  ; preset sprite number run left start
                            
                            cpx #CLZ_ShootStepCtrl_Switch_Le; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no
                            
                            lda #CLZ_LodeRuSprtNumShootLe   ; get sprite number shoot left
                            
SetLodeRuSpriteNum          sta CLZ_LodeRuSprtNum           ; set sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkLe_Max; test maximum loderunner shoot step image table offset
                            beq LodeRuShootLeftFinish       ; check: EQ - yes: open a hole in shoot direction
                            
                            cpx #TabImageNumShootSparkLe_Min; test minimum loderunner shoot step image table offset
                            beq GetImageShootSpark          ; check: EQ - yes: get appropriate spark image number
                            
                            lda TabImageNumShootSpark - $01,x ; get image number shoot spark
                            pha                             ; save image number shoot spark
                            
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one column left
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save image number shoot spark
                            
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one col left
                            stx CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabImageNumShootMeltGround,x; get image shoot melts ground
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot left
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked left/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/left for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoLe   ldy CLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one col left
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output no shoot finish brick to left col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_BrickSoft       ; get normal brick - unsuccesful finish shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: min - yes: done
                            
                            dex                             ; dec loderunner shoot step image table offset
                            lda TabImageNumShootSpark,x     ; get previous spark image number
                            pha                             ; save spark image number
                            
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one row up
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #CL_LodeRuShoot_No          ; get flag shoot no
                            sta CL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot left possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftFinish       ldx CLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one position left
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightX         Does    : exit point of LodeRuShootRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightX          .block                           ; 
                            jmp LodeRuShootRight.SetLodeRuShootFinish ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightInit      Does    : init try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightInit       .block                           ; 
                            lda #CL_LodeRuShoot_Ri          ; get shoot right
                            sta CL_LodeRuShoot              ; ini shoot
                            sta CL_JoystickMoveDirY         ; ini movedir Y
                            sta CL_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabImageNumShootSparkRi_Min; get initial value
                            sta CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRight          Does    : try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRight           .block                           ; 
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            cpy #CLZ_ScreenRow_Max          ; test max
                            bcs LodeRuShootRightX           ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on rightmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            cpy #CLZ_ScreenCol_Max          ; test rightmost position
                            bcs LodeRuShootRightX           ; check: GE - yes: no room left for shoot right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile below right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below right of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootRightX           ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile right of loderunner is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one position right
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #CL_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoRi   ; check: EQ - no: blocked no shoot right possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda #CLZ_LodeRuSprtNumRunRi_00  ; get sprite number run right start
                            
                            cpx #CLZ_ShootStepCtrl_Switch_Ri; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no 
                            
                            lda #CLZ_LodeRuSprtNumShootRi   ; get sprite number shoot right
                            
SetLodeRuSpriteNum          sta CLZ_LodeRuSprtNum           ; set loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkRi_Max; test max
                            beq LodeRuShootRightFinish      ; check: EQ - yes
                            
                            cpx #TabImageNumShootSparkRi_Min; test min
                            beq GetImageShootSpark          ; check: EQ - yes
                            
                            lda TabImageNumShootSpark - $01,x ; get image number shoot spark
                            pha                             ; save image number shoot spark
                            
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            stx CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; setp screen row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground - pointer is in the 2nd half of the table - needs subtraction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabImageNumShootMeltGround - TabImageNumShootSparkRi_Min,x; get image shoot melts ground
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot right
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked right/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/right for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoRi   ldy CLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one col right
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot finish brick to right col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_BrickSoft       ; get normal brick - finished shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx CLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkRi_Min; test minimum loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: EQ - yes: min reached - finished
                            
                            dex                             ; 
                            lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx CLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; set on column right
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore shoot spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #CL_LodeRuShoot_No          ; get flag shoot no
                            sta CL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot right possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightFinish      ldx CLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one position right
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteLodeRu          = *       ; 
                            .byte $0b ; $00 - Run  Le 00
                            .byte $0c ; $01 - Run  Le 01
                            .byte $0d ; $02 - Run  Le 02
                            .byte $18 ; $03 - Pole Le 00
                            .byte $19 ; $04 - Pole Le 01
                            .byte $1a ; $05 - Pole Le 02
                            .byte $0f ; $06 - Fire Le
                            .byte $13 ; $07 - Fall Le
                            .byte $09 ; $08 - Run  Ri 00 = Level Tile Loderunner
                            .byte $10 ; $09 - Run  Ri 01
                            .byte $11 ; $0a - Run  Ri 02
                            .byte $15 ; $0b - Pole Ri 00
                            .byte $16 ; $0c - Pole Ri 01
                            .byte $17 ; $0d - Pole Ri 02
                            .byte $25 ; $0e - Fire Ri
                            .byte $14 ; $0f - Fall Ri
                            .byte $0e ; $10 - Ladder 00
                            .byte $12 ; $11 - Ladder 01
; --------------------------------------------------------------------------------------------------------------------- ;
; convert an image number into a image count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootSpark       = *       ; shoot image number tables left/right
TabImageNumShootSparkLe     = *       ; 
TabImageNumShootSparkLe_Min = * - TabImageNumShootSpark ; start of table left
                            .byte $1b ; $00 - shot spark le    00
                            .byte $1b ; $01 - shot spark le    00
                            .byte $1c ; $02 - shot spark le    01
                            .byte $1c ; $03 - shot spark le    01
                            .byte $1d ; $04 - shot spark le/ri 02
                            .byte $1d ; $05 - shot spark le/ri 03
                            .byte $1e ; $06 - shot spark le/ri 03
                            .byte $1e ; $07 - shot spark le/ri 03
                            .byte $00 ; $08 - empty space
                            .byte $00 ; $09 - empty space
                            .byte $00 ; $0a - empty space
                            .byte $00 ; $0b - empty space
TabImageNumShootSparkLe_Max = * - TabImageNumShootSpark ; end of table left
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootSparkRi     = *       ; 
TabImageNumShootSparkRi_Min = * - TabImageNumShootSpark ; start of table right
                            .byte $26 ; $00 - shot spark ri    00
                            .byte $26 ; $01 - shot spark ri    00
                            .byte $27 ; $02 - shot spark ri    01
                            .byte $27 ; $03 - shot spark ri    01
                            .byte $1d ; $04 - shot spark le/ri 02
                            .byte $1d ; $05 - shot spark le/ri 02
                            .byte $1e ; $06 - shot spark le/ri 03
                            .byte $1e ; $07 - shot spark le/ri 03
                            .byte $00 ; $08 - empty space
                            .byte $00 ; $09 - empty space
                            .byte $00 ; $0a - empty space
                            .byte $00 ; $0b - empty space
TabImageNumShootSparkRi_Max = * - TabImageNumShootSpark ; end of table right
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootMeltGround  = *       ; 
                            .byte $1f ; $0c - melt ground phase 00
                            .byte $1f ; $0d - melt ground phase 00
                            .byte $20 ; $0e - melt ground phase 01
                            .byte $20 ; $0f - melt ground phase 01
                            .byte $21 ; $00 - melt ground phase 02
                            .byte $21 ; $01 - melt ground phase 02
                            .byte $22 ; $02 - melt ground phase 03
                            .byte $22 ; $03 - melt ground phase 03
                            .byte $23 ; $04 - melt ground phase 04
                            .byte $23 ; $05 - melt ground phase 04
                            .byte $24 ; $06 - melt ground phase 05
                            .byte $24 ; $07 - melt ground phase 05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHandler               Does    : control the game demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHandler                .block                           ; 
                            lda CL_KeyNew                   ; get keyboard interaction
                            bne DemoEnd                     ; check: player keybord interaction - yes: end demo
                            
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne DemoRun                     ; check: player joystick interaction - no: continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
; player interaction - end demo with sudden death
; --------------------------------------------------------------------------------------------------------------------- ;
DemoEnd                     lsr CLZ_DemoNoFunction          ; reset flag - used but has no function
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death - kill of LR immediately ends the demo
; --------------------------------------------------------------------------------------------------------------------- ;
; test input keys
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$aa                        ; test <CTRL> + l(oad)
                            beq GoDemoWaitPlayerInput       ; check: EQ - yes: check input
                            
                            cmp #$01                        ; test <ENTER>
                            bne DemoGetNumLivesMax          ; check: EQ - no: reset to max
                            
GoDemoWaitPlayerInput       jmp GameOver.DemoWaitPlayerInput ; wait and test player demo input
; --------------------------------------------------------------------------------------------------------------------- ;
; set to $01 - if last live is used up the demo ends immediately
; --------------------------------------------------------------------------------------------------------------------- ;
DemoGetNumLivesMax          lda #CL_NumLivesDemo            ; get initial value
                            sta CL_NumLives                 ; ini demo number of lives
                            
                            rts                             ; return to GameInputHandler
; --------------------------------------------------------------------------------------------------------------------- ;
; continue the demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoRun                     lda CLZ_DemoMoveDuration        ; get duration demo move
                            bne DemoMoveContinue            ; check: not ended yet
; --------------------------------------------------------------------------------------------------------------------- ;
; old move has ended - get a new one
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini demo move table offset
                            lda (CLZ_DemoMoveDataPtr),y     ; get demo move type
                            sta CLZ_DemoMoveType            ; set demo move type (l/r/u/d/fire)
                            
                            iny                             ; inc demo move table offset
                            lda (CLZ_DemoMoveDataPtr),y     ; get demo move duration
                            sta CLZ_DemoMoveDuration        ; set demo move duration
; --------------------------------------------------------------------------------------------------------------------- ;
; advance demo move data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_DemoMoveDataPtr_Lo      ; get demo data pointer LO
                            clc                             ; 
                            adc #TabDemoMoveEntry_Len       ; point to next demo data pair
                            sta CLZ_DemoMoveDataPtr_Lo      ; set demo data pointer LO
                            
                            lda CLZ_DemoMoveDataPtr_Hi      ; get demo data pointer HI
                            adc #$00                        ; add .C
                            sta CLZ_DemoMoveDataPtr_Hi      ; set demo data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; continue actual demo move
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMoveContinue            lda CLZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            and #$0f                        ; isolate right nibble for up/do moves
                            tax                             ; set up/do move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta CL_JoystickMoveDirY         ; set demo move up/do
                            
                            lda CLZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            lsr a                           ; isolate left nibble for left/right moves
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            tax                             ; set le/ri move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta CL_JoystickMoveDirX         ; set demo move le/ri
                            
                            dec CLZ_DemoMoveDuration        ; dec duration demo move
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoJoystickMove         = *                             ; 
                            .byte CL_JoystickMoveDirY_Up    ; $00 - $21
                            .byte CL_JoystickMoveDirX_Le    ; $01 - $22
                            .byte CL_JoystickMoveDirY_Do    ; $02 - $25
                            .byte CL_JoystickMoveDirX_Ri    ; $03 - $2a
                            .byte CL_JoystickShoot_Ri       ; $04 - $26
                            .byte CL_JoystickShoot_Le       ; $05 - $1e
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameInputHandler          Does    : 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameInputHandler           .block                           ; 
                            lda CL_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play
                            cmp #CL_GameMode_Demo           ; shift out mode flag
                            beq DemoHandler                 ; check: demo - yes: control demo
; --------------------------------------------------------------------------------------------------------------------- ;
; no demo - get key
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CL_KeyNew                   ; get new key entered
                            bne IniNewKey                   ; check: pressed - yes
                            
                            lda CL_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #CL_ControllerType_Keyboard ; test keyboard
                            beq GameInputHandlerX           ; check: EQ - yes
                            
GoJoystickControl           jmp GameSetJoystickAction       ; get and set joystick shoot or move directions
; --------------------------------------------------------------------------------------------------------------------- ;
IniNewKey                   lda #CL_KeyNew_None             ; get initial value
                            sta CL_KeyNew                   ; ini new key input
                            
                            stx CLZ_WorkKeyNew              ; save new key entered
                            
                            ldy #$ff                        ; preset -1 to allow loop start inc
SetNextIngameKeyTabOff      iny                             ; 
                            lda TabIGC_CmdChar,y            ; get in game keys tab value  (U F Run/Stop R A J K + - Z D)
                            beq ChkControllerType           ; check: EoT command key - yes: no legal command key found
                            
                            cmp CLZ_WorkKeyNew              ; test with new key entered
                            bne SetNextIngameKeyTabOff      ; check: EQ - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch in game key routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            asl a                           ; *2
                            tay                             ; 
                            
                            lda TabIGC_CmdAddress + $01,y   ; get ingame key routine address HI
                            pha                             ; push as return address HI
                            
                            lda TabIGC_CmdAddress + $00,y   ; get ingame key routine address LO
                            pha                             ; push as return address LO
                            
                            rts                             ; dispatch command
; --------------------------------------------------------------------------------------------------------------------- ;
ChkControllerType           lda CL_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #CL_ControllerType_Joystick ; test joystick
                            beq GoJoystickControl           ; check: EQ - yes
                            
                            ldx CLZ_WorkKeyNew              ; get new key entered
                            stx CL_JoystickMoveDirY         ; set jostick move Y
                            stx CL_JoystickMoveDirX         ; set jostick move X
                            
GameInputHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_NotDispatched         Does    : in game cmd: increase life counter
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_NotDispatched          .block                           ; 
                            inc CL_GameSpeedCtrl            ; speed up
                            inc CL_NumLives                 ; 
                            
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Pause                 Does    : in game cmd: pause the game until next RUN/STOP is pressed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Pause                  .block                           ; 
GetNextPauseKey             jsr GetNewKey                   ; 
                            
                            cmp #$03                        ; test F7
                            bne CheckChar_RunStop           ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the cheat mode flag with the key value of F7 ($07)
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CL_CheatMode                ; set flag cheat mode on after <RUN/STOP> and F7
                            
CheckChar_RunStop           cmp #$3f                        ; test <RUN/STOP>
                            bne GetNextPauseKey             ; check: EQ - no
                            
                            jmp GameInputHandler            ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Resign                Does    : in game cmd: resign
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Resign                 .block                           ; 
                            jmp GameOver                    ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Suicide               Does    : in game cmd: commit suicide
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Suicide                .block                           ; 
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetJoystick           Does    : in game cmd: set input to joystick
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetJoystick            .block                           ; 
                            lda #CL_ControllerType_Joystick ; get joystick
                            sta CL_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetKeyboard           Does    : in game cmd: set input to keyboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetKeyboard            .block                           ; 
                            lda #CL_ControllerType_Keyboard ; get keyboard
                            sta CL_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DecSpeed              Does    : in game cmd: decrease game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DecSpeed               .block                           ; 
                            lda CL_GameSpeed                ; get game speed for decrease
                            cmp #CL_GameSpeed_Min           ; test min
                            beq IGC_IncSpeed.IGC_IncSpeedX  ; check: EQ - yes: bypass decrease
                            
                            dec CL_GameSpeed                ; slow down
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncSpeed              Does    : in game cmd: increase game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncSpeed               .block                           ; 
                            lda CL_GameSpeed                ; get game speed for increase
                            cmp #CL_GameSpeed_Max           ; test max
                            beq IGC_IncSpeedX               ; check: EQ - yes: bypass increase
                            
                            inc CL_GameSpeed                ; speed up
                            
IGC_IncSpeedX               jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_ShootMode             Does    : in game cmd: toggle shoot mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_ShootMode              .block                           ; 
                            lda CL_LodeRuShootMode          ; 
                            eor #$ff                        ; toggle shoot mode
                            sta CL_LodeRuShootMode          ; 
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; GameSetJoystickAction     Does    : get and set joystick shoot or move directions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetJoystickAction      .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne ChkJoystickMoves            ; check: shoot - no: check move directions
; --------------------------------------------------------------------------------------------------------------------- ;
; was shoot - handle mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuShootMode         ; get shoot mode
                            eor CL_LodeRuShootMode          ; toggle shoot mode
                            bpl ShootLeft                   ; check: shoot mode CLZ_LodeRuShootMode_Back - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; shoot right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_JoystickShoot_Ri        ; get shoot right
                            sta CL_JoystickMoveDirY         ; set shoot right Y
                            sta CL_JoystickMoveDirX         ; set shoot right X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; shoot left and exit
; --------------------------------------------------------------------------------------------------------------------- ;
ShootLeft                   lda #CL_JoystickShoot_Le        ; get shoot left
                            sta CL_JoystickMoveDirY         ; set shoot left Y
                            sta CL_JoystickMoveDirX         ; set shoot left X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick directional moves
; --------------------------------------------------------------------------------------------------------------------- ;
ChkJoystickMoves            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            sta CLZ_WorkJoystickMove        ; save CIA value
                            
                            and #CIAPRA_JOY_DO              ; Bit 1: Joystick 2 - Down  0=pressed
                            beq GetJoystickMove_Down        ; check: down - yes: set down
                            
                            lda CLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_UP              ; Bit 0: Joystick 2 - Up    0=pressed
                            beq GetJoystickMove_Up          ; check: up - yes: set up
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move up_down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_JoystickMove_None       ; get no move
                            stx CL_JoystickMoveDirY         ; ini move up_down
                            beq ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Up          ldx #CL_JoystickMoveDirY_Up     ; get move up
                            stx CL_JoystickMoveDirY         ; set move up
                            bne ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Down        ldx #CL_JoystickMoveDirY_Do     ; get move down
                            stx CL_JoystickMoveDirY         ; set move down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkMoves_Left_Right         lda CLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_RI              ; Bit 3: Joystick 2 - Right 0=pressed
                            beq GetJoystickMove_Right       ; check: right - yes: set right
                            
                            lda CLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_LE              ; Bit 2: Joystick 2 - Left  0=pressed
                            beq GetJoystickMove_Left        ; check: left - yes: set left
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move left_right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CL_JoystickMove_None       ; get move none
                            stx CL_JoystickMoveDirX         ; set move none
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Right       ldx #CL_JoystickMoveDirX_Ri     ; get move right
                            stx CL_JoystickMoveDirX         ; set move right
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Left        ldx #CL_JoystickMoveDirX_Le     ; get move left
                            stx CL_JoystickMoveDirX         ; set move left
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdChar              = *       ; 
                            .byte $3f ; RUN/STOP - Pause the game
                            .byte $91 ; R        - Resign the game
                            .byte $8a ; A        - Commit Suizide
                            .byte $a2 ; J        - Set Joystick Control
                            .byte $a5 ; K        - Set Keyboard Control
                            .byte $2b ; +        - Inc Game Speed
                            .byte $28 ; -        - Dec Game Speed
                            .byte $92 ; D        - Toggle Shoot Mode
; --------------------------------------------------------------------------------------------------------------------- ;
; special cheat commands - press and hold <CTRL> + <Commodore> + arrow keys
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $b9 ;          - inc lives --> <CTRL> + <C=> + arrow left - winvice: <CTRL> + <TAB> + <^>
                            .byte $b6 ;          - inc level --> <CTRL> + <C=> + arrow up   - winvice: <CTRL> + <TAB> + <END>
                            
                            .byte $00 ; end of game command table
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdAddress           = *                       ; 
                            .word IGC_Pause       - 1 ; 
                            .word IGC_Resign      - 1 ; 
                            .word IGC_Suicide     - 1 ; 
                            .word IGC_SetJoystick - 1 ; 
                            .word IGC_SetKeyboard - 1 ; 
                            .word IGC_IncSpeed    - 1 ; 
                            .word IGC_DecSpeed    - 1 ; 
                            .word IGC_ShootMode   - 1 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .word IGC_IncLives    - 1 ; cheat: increase lives count
                            .word IGC_IncLevel    - 1 ; cheat: switch to next level
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetImageAndPosXY    Does    : get loderunner image number and PosXY
;                           Expects : 
;                           Returns : .A=loderunner image number
;                                   : .X=loderunner PosX
;                                   : .Y=loderunner PosY
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetImageAndPosXY     .block                           ; 
                            ldx CLZ_LodeRuCol               ; adr col loderunner
                            ldy CLZ_LodeRuOnImgPosX         ; lr pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; 
                            
                            stx CLZ_WorkImgOffsetPosX       ; image number
                            
                            ldy CLZ_LodeRuRow               ; actual row loderunner
                            ldx CLZ_LodeRuOnImgPosY         ; lr pos on image up/down
                            jsr ScreenAddGfxOnImagePosY     ; 
                            
                            ldx CLZ_LodeRuSprtNum           ; lr sprite number
                            lda TabNumSpriteLodeRu,x        ; lr images tab
                            ldx CLZ_WorkImgOffsetPosX       ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGold             Does    : let loderunner pick up a piece of gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGold               .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosX         ; get loderunner on image PosX
                            cmp #CLZ_LodeRuOnImgPosX_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner on image PosY
                            cmp #CLZ_LodeRuOnImgPosY_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner is PosX/PosY centered
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Gold            ; test gold
                            bne LodeRuGetGoldX              ; check: EQ - no: exit
                            
                            lsr CL_LodeRuGetGold            ; set flag lodrunner just gets gold
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare a randomized got gold jingle
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$10                        ; get bottom limit
                            ldy #$20                        ; get upper limit
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            
                            sta TabGoldJinglePart_01 + $01  ; set 1st tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_02 + $01  ; set 2nd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_03 + $01  ; set 3rd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_04 + $01  ; set 4th tune data pointer voice 2
                            
                            jsr LodeRuSetGetGoldJingle      ; jingle data must follow directly
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart           = *       ; 
TabGoldJinglePart_01        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $b0 ; tune s/r/volume  (not used)
TabGoldJinglePart_Len       = * - TabGoldJinglePart ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_02        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_03        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $90 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_04        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
                            
                            .byte $00 ; end of tune marker
; --------------------------------------------------------------------------------------------------------------------- ;
; discount picked up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CL_GoldToCollect            ; discount gold to collect
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row/col to loderunner row/col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy CLZ_LodeRuCol               ; get actual col loderunner
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty space
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #CL_TileNum_Gold            ; get gold
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; score gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>CL_Score_Gold             ; score add value HI - gold scores 250 points
                            lda #<CL_Score_Gold             ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                            
LodeRuGetGoldX              rts                             ; exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveSpriteNumRotate Does    : rotate sprite number between minimum and maximum values
;                           Expects : .A=sprite number min
;                                   : .X=sprite number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveSpriteNumRotate  .block                           ; 
                            inc CLZ_LodeRuSprtNum           ; inc sprite number to next phase
                            
                            cmp CLZ_LodeRuSprtNum           ; test lower limit
                            bcc ChkUpperLimit               ; check: LT - yes: check max
                            
SetToMinValue               sta CLZ_LodeRuSprtNum           ; reset to min value
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpx CLZ_LodeRuSprtNum           ; test upper limit
                            bcc SetToMinValue               ; check: LT - yes: reset to lower limit
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCaughtHandler       Does    : control loderunner caught by an enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCaughtHandler        .block                           ; 
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            lda CLZ_LodeRuEnemyCollision    ; get sprite collision  $01=lr caught
                            beq LodeRuCaughtHandlerX        ; check: caught - no: exit
                            
                            lda CL_LodeRuGetGold            ; get flag gold  $00=just gets it
                            beq LodeRuCaughtHandlerX        ; check: just picking up gold - yes
                            
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
LodeRuCaughtHandlerX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosX     Does    : center loderunnner on screen image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosX      .block                           ; 
                            lda CLZ_LodeRuOnImgPosX         ; get loderunner PosX on image
                            cmp #CLZ_LodeRuOnImgPosX_Mid    ; test center
                            bcc IncPosX                     ; check: LT - yes: left of center
                            beq LodeRuCenterImagePosXX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; right of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_LodeRuOnImgPosX         ; GT - dec loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; left of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosX                     inc CLZ_LodeRuOnImgPosX         ; inc loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosXX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosY     Does    : center loderunnner on screen image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosY      .block                           ; 
                            lda CLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #CLZ_LodeRuOnImgPosY_Mid    ; test center
                            bcc IncPosY                     ; check: LT - yes: above center
                            beq LodeRuCenterImagePosYX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; below center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_LodeRuOnImgPosY         ; GT - dec loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; above center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosY                     inc CLZ_LodeRuOnImgPosY         ; lower - inc loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosYX      rts                             ; equal - nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootFinish         Does    : open a hole in shoot direction - shoot finished successfully
;                           Expects : .X=colum number
;                           Returns : .C=1 - success
;                                   : .C=0 - failed
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootFinish          .block                           ; 
                            lda #CL_LodeRuShoot_No          ; get initial value
                            sta CL_LodeRuShoot              ; ini shoot to off
                            
                            ldy CLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step to row below loderunner
                            
                            stx CLZ_ScreenCol               ; set screen col ($00-$1b)
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store an empty level tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #CL_TileNum_Empty           ; get emtpy tile
                            jsr ScreenImageOutToPrepare     ; clear tile under loderunner
                            
                            dec CLZ_ScreenRow               ; set screen row above hole
                            lda #CL_TileNum_Empty           ; get empty tile
                            jsr ScreenImageOutToDisplay     ; clear tile above hole
                            inc CLZ_ScreenRow               ; restore screen row to hole
                            
                            ldx #$ff                        ; preset WA offset to -1 to allow next inx
; --------------------------------------------------------------------------------------------------------------------- ;
; search a free slot in open hole time work area
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextHoleOpenTimeOff      inx                             ; inc WA offset
                            cpx #CL_WA_HoleMax              ; test max WA length
                            beq LodeRuOpenShootHoleX        ; check: EQ - yes: max slots reached - exit fault
                            
                            lda CL_WA_HoleOpenTime,x        ; get hole open time tab
                            bne SetNextHoleOpenTimeOff      ; check: already used - yes: continue search
; --------------------------------------------------------------------------------------------------------------------- ;
; a free slot found - occupy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta CL_WA_HoleRow,x             ; save in hole row tab
                            
                            lda CLZ_ScreenCol               ; get screen col ($00-$1b)
                            sta CL_WA_HoleCol,x             ; save in hole column tab
                            
                            lda #CL_WA_HoleOpenTime_Ini     ; get initial value
                            sta CL_WA_HoleOpenTime,x        ; ini hole open time tab entry
                            
                            sec                             ; set flag success
                            
LodeRuOpenShootHoleX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncLevel              Does    : in game cmd: cheat - select next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncLevel               .block                           ; 
                            lda SHFLAG                      ; <SHIFT> key indicator - $01=shift $02=commodore $04=ctrl
                            and #$06                        ; isolate <CTRL> + <C=>
                            cmp #$06                        ; test <CTRL> + <C=>
                            bne IGC_IncLevelX               ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check cheat flag set in IGC_Pause with F7
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_CheatMode                ; get cheat mode - set after <RUN/STOP> and <F7>
                            beq IGC_IncLevelX               ; check: EQ - no: exit
                            
                            inc CL_NumLives                 ; inc to compensate the kill with lsr Lr_Alive
; --------------------------------------------------------------------------------------------------------------------- ;
; select next level
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_LevelNumGame             ; inc game level number 001-050
                            inc CL_LevelNumDisk             ; inc disk level number 000-049
; --------------------------------------------------------------------------------------------------------------------- ;
 ; force load of new level
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
IGC_IncLevelX               rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncLives              Does    : in game cmd: cheat - inc number of lives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncLives               .block                           ; 
                            lda SHFLAG                      ; <SHIFT> key indicator - $01=shift $02=commodore $04=ctrl
                            and #$06                        ; isolate <CTRL> + <C=>
                            cmp #$06                        ; test <CTRL> + <C=>
                            bne IGC_IncLivesX               ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check cheat flag set in IGC_Pause with F7
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_CheatMode                ; get cheat mode set after <RUN/STOP> and F7
                            beq IGC_IncLivesX               ; check: flag cheat mode set - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; inc and display number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_NumLives                 ; inc number of lives
                            bne OutNewLivesNum              ; check: max - no
                            
                            dec CL_NumLives                 ; correct to max
                            
OutNewLivesNum              jsr StatusOutLives              ; StatusOutLives
                            
IGC_IncLivesX               jmp GameInputHandler            ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveHandler          Does    : control all enemy moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveHandler           .block                           ; 
                            ldx CL_EnemyCount               ; get number of enemies ($00-$05)
                            beq EnemyMoveHandlerX           ; check: is there any enemy to move - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; handle enemy zero page move control tab offset - values were calculated from game speed/enemy count in MainLoopInit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyMoveCycleOff       ; inc offset actual enemy move cycle values
                            
                            ldy CLZ_EnemyMoveCycleOff       ; get offset actual enemy move cycle values
                            cpy #CLZ_EnemyMoveCycleOff_Max  ; test max
                            bcc GetNextMoveCycle            ; check: LT - yes: try a move
                            
                            ldy #CLZ_EnemyMoveCycleOff_Min  ; get initial value
                            sty CLZ_EnemyMoveCycleOff       ; ini offset enemy move cycle values
; --------------------------------------------------------------------------------------------------------------------- ;
; get an enemy move control table value
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextMoveCycle            lda CLZ_EnemyMoveCycle,y        ; get enemy move cycle value
                            sta CLZ_EnemyMoveCycleWork      ; set enemy move cycle work
                            
ShiftNextMoveEnableBit      lsr CLZ_EnemyMoveCycleWork      ; shift out an enemy move control bit
                            bcc GetEnemyMoveCtrlFlags       ; check: was move bit set - no: check if finished
                            
                            jsr EnemyMove                   ; move an enemy if move bit was set
                            
                            lda CL_LodeRuState              ; get loderunner heartbeat
                            beq EnemyMoveHandlerX           ; check: still alive - no: was caught - exit
                            
GetEnemyMoveCtrlFlags       lda CLZ_EnemyMoveCycleWork      ; get enemy move cycle work
                            bne ShiftNextMoveEnableBit      ; check: still move bits available - yes: continue
                            
EnemyMoveHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; offset to table values calculated in MainLoopInit: CL_GameSpeedCtrl + CL_EnemyCount
; actual values store in zero page CLZ_EnemyMoveCycle
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCycles          = *             ; 
TabEnemyMoveCycle_01        = * + $00       ; 
TabEnemyMoveCycle_02        = * + $01       ; 
TabEnemyMoveCycle_03        = * + $02       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_00  = *             ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_01  = *             ; values for default speed and max 5 enemies
                            .byte %00000000 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_02  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_03  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_04  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
TabEnemyMoveCyclesBlock_05  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_06  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_07  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_08  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_09  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0a  = *             ; max game speed
                            .byte %00000111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0b  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0c  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0d  = *             ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0e  = *             ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0f  = *             ; max game speed + max enemy number
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_10  = *             ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_11  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_12  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_13  = *             ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_14  = *             ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteEnemy           = *       ; 
                            .byte $08 ; $00 - Run  Le 00 = Level Tile Enemy
                            .byte $2b ; $01 - Run  Le 01
                            .byte $2c ; $02 - Run  Le 02
                            .byte $30 ; $03 - Pole Le 00
                            .byte $31 ; $04 - Pole Le 01
                            .byte $32 ; $05 - Pole Le 02
                            .byte $36 ; $06 - Fall Le
                            .byte $28 ; $07 - Run  Ri 00
                            .byte $29 ; $08 - Run  Ri 01
                            .byte $2a ; $09 - Run  Ri 02
                            .byte $2d ; $0a - Pole Ri 00
                            .byte $2e ; $0b - Pole Ri 01
                            .byte $2f ; $0c - Pole Ri 02
                            .byte $35 ; $0d - Fall Ri
                            .byte $33 ; $0e - Ladder 00
                            .byte $34 ; $0f - Ladder 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMove                 Does    : select and move the next enemy
;                           Expects : 
;                           Returns : 
;                           Remark  : 1st: check if enemy is still locked up in a hole
;                                   :      continue getting him out
;                                   : 2nd: check the tile under enemy
;                                   :      Ladder/Pole                      --> EnemyMoveDispatcher
;                                   : 3rd: check the tile below enemy
;                                   :      Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                                   :      BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMove                  .block                           ; 
                            inc CL_EnemyToMoveNum           ; inc count to next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate the enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CL_EnemyCount               ; get number of enemies ($00-$05)
                            cpx CL_EnemyToMoveNum           ; test with number of enemy to move
                            bcs RestoreEnemyStatus          ; check: GE - no: max not reached - bypass reset
                            
                            ldx #CL_EnemyToMoveNum_Min      ; get reset to first enemy
                            stx CL_EnemyToMoveNum           ; init enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
; reactivate the selected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyStatus          jsr EnemyMoveStatusRestore      ; restore enemy status from save area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is still captured in a hole or still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyHoleGoldTime       ; get either has gold or locked in a hole time
                            bmi EnemyMovable                ; check: still carries gold - yes
                            beq EnemyMovable                ; check: gold/hole time up - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; positive - enemy is still trapped in a hole - reduce the in hole time
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyHoleGoldTime       ; discount enemy is locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; test in hole time final seconds - eventually shiver/get him out
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            cpy #CLZ_EnemyHoleGoldTime_Shake; test 1st mark - start shaking out of hole
                            bcs ChkEnemyRebirthTime         ; check: GE - yes: bring him back to live
                            
                            jmp EnemyShiverOutOfHole        ; exit - shiver enemy out of hole
; --------------------------------------------------------------------------------------------------------------------- ;
; test enemy rebirth time - eventually continue waiting for rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyRebirthTime         ldx CL_EnemyToMoveNum           ; get number of enemy to move
                            lda CL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq GoEnemyDisplayAndDisable    ; check: did rebirth time ran out - yes: display and disable him
                            
                            jmp EnemyMoveStatusSave         ; store his status to save area again
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyDisplayAndDisable    jmp EnemyDisplayAndDisable      ; display enemy and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy not locked up in a hole
;           actual row: Ladder/Pole                      --> EnemyMoveDispatcher - on a pole enemy must be centerd first
; row below actual row: Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                       BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovable                ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> dispatch next enemy move
; Pole   --> fall down to image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a ladder - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him immediately
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a pole - wait for image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            bne ChkEnemyOnImageCenter       ; check: EQ - no: test image center position for a fall
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a pole - wait for image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Mid     ; test center
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy tile position - let him fall further down if not
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyOnImageCenter       lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Mid     ; test center
                            bcc EnemyFallDownHandler        ; check: LT - yes: still above center so let him fall
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is below the image center - check if on last row - end of fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            cpy #CLZ_ScreenRow_Max          ; test enemy on max row already
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: end of fall - dispatch next enemy move
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data ptr LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data ptr LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data ptr HI
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty      --> let enemy fall down
; LodeRunner --> let enemy fall down
; Enemy      --> dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is empty - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a loderunner - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> dispatch next enemy move
; SolidBrick  --> dispatch next enemy move
; Ladder      --> dispatch next enemy move
; All other   --> let enemy fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a normal brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a solid brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a ladder - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne EnemyFallDownHandler        ; check: EQ - no: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch next enemy move if he stands on a BrickSoft/BrickHard/Ladder/Enemy
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveDispatcher       jmp EnemyMoveDispatcher         ; try to move this enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDownHandler      Does    : control enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDownHandler       .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
                            
                            lda #CLZ_EnemySprtNum_Fall_Le   ; preset sprite number fall left
                            
                            ldy CLZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            bmi SetEnemySprtNum             ; check: left - yes
                            
                            lda #CLZ_EnemySprtNum_Fall_Ri   ; get sprite number fall right
; --------------------------------------------------------------------------------------------------------------------- ;
; set the view dir dependend sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemySprtNum             sta CLZ_EnemySprtNum            ; set actual enemy sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; step enemy on screen image down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyOnImgPosY          ; step actual enemy on image down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy has left the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Max + $01 ; test max
                            bcs EnemyFallDown               ; check: GE - yes: enemy has left this screen image downwards
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy is in the center of the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Mid     ; test center
                            bne EnemyDisplayAndDisable      ; check: EQ - no: wait - display and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy has fallen into a hole
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> captured in a hole - init timer - score digging in
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a normal brick - yes: captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne EnemyDisplayAndDisable      ; check: EQ - no: display and disable him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy sitting in a hole still has gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl IniEnemyHoleTime            ; check: still carries gold - no
; --------------------------------------------------------------------------------------------------------------------- ;
; timer is negative - enemy still has gold for some reason
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CL_GoldToCollect            ; some gold has vanished - discount gold to collect
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy in hole time value
; --------------------------------------------------------------------------------------------------------------------- ;
IniEnemyHoleTime            lda CL_EnemyInHoleTime          ; get initial time value taken from TabEnemyInHoleTime
                            sta CLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; a digged in enemy scores 75 points
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>CL_Score_EnemyDigIn       ; score add value HI
                            lda #<CL_Score_EnemyDigIn       ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyDisplayAndDisable    Does    : display enemy and deactivate enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDisplayAndDisable     .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDown             Does    : let an enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDown              .block                           ; 
                            lda #CLZ_EnemyOnImgPosY_Min     ; get intial value 
                            sta CLZ_EnemyOnImgPosY          ; ini actual enemy pos on image up/down
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a normal brick - yes: empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne CopyCtrlTileToGameTile      ; check: NE - yes: skip replacemanet
; --------------------------------------------------------------------------------------------------------------------- ;
; replace ctrl normal brick tile by empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty tile substitution
                            
CopyCtrlTileToGameTile      sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; let enemy fall down - step enemy row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyRow                ; let enemy fall down a row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> caught - set loderunner death flag
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is loderunner - yes: caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne GetCtrlDataTile             ; check: NE - yes: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; loderunner caught - set CL_LodeRuState_Death
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlDataTile             lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> locked up in a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: locked up in a hole - drop gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne InsEnemyTileIntoGameData    ; check: NE - yes: not in hole - deactivate him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; if an enemy is directly on a normal brick in ctrl data - captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl InsEnemyTileIntoGameData    ; check: still locked in hole - yes: deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy has fallen into a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            dey                             ; step one row up
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen col to enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; the tile directly above an enemy must be empty - otherwise his gold cannot be dropped
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> drop the gold he carries
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is empty - yes: drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq EnemyDropsHisGold           ; check: EQ - yes: drop gold to it
; --------------------------------------------------------------------------------------------------------------------- ;
; loose this piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CL_GoldToCollect            ; a piece of gold was lost
                            jmp ResetLevelDataPointer       ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; drop gold directly above enemy 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDropsHisGold           lda #CL_TileNum_Gold            ; get gold
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #CL_TileNum_Gold            ; get gold
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
ResetLevelDataPointer       ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize enemy in hole timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyHoleGoldTime_None ; get initial value
                            sta CLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; insert enemy tile number to game data - deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
InsEnemyTileIntoGameData    lda #CL_TileNum_Enemy           ; get enemy 
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyShiverOutOfHole      Does    : shiver the enemy in a hole just before he leaves
;                           Expects : .Y=enemy in hole time (here: $0c-$07 - counted down)
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyShiverOutOfHole       .block                           ; 
                            cpy #CLZ_EnemyHoleGoldTime_Shake_X ; test shake out of hole phase end
                            bcc EnemyMoveDispatcher         ; check: lower - yes: get him out
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; use the remaining CLZ_EnemyHoleGoldTime ($0c-$07) value as offset for TabEnemyShake
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            lda TabEnemyShake - CLZ_EnemyHoleGoldTime_Shake_X,y ; get shiver out of hole value
                            sta CLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyShake               = *       ; let enemy shiver from left to right before leaving a hole
                            .byte $02 ; $05 - $07 - offset exit value - CLZ_EnemyHoleGoldTime_Shake_X
                            .byte $01 ; $04 - $08
                            .byte $02 ; $03 - $09
                            .byte $03 ; $02 - $0a
                            .byte $02 ; $01 - $0b
                            .byte $01 ; $00 - $0c
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDispatcher       Does    : get an enemy move direction proposal and call the approriate move handler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDispatcher        .block                           ; 
                            ldx CLZ_EnemyCol                ; actual enemy col
                            ldy CLZ_EnemyRow                ; actual enemy row
                            
                            jsr EnemyMoveGetDirProposal     ; get a possible enemy move direction
                            
                            asl a                           ; 
                            tay                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; push enemy move dir routine to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemyMoveDir + $01,y     ; 
                            pha                             ; 
                            
                            lda TabEnemyMoveDir + $00,y     ; 
                            pha                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveDir             = *                          ; 
                            .word EnemyMoveStatusSave   -1 ; $00 - CL_EnemyMoveDir_None - save enemy status to save area
                            
                            .word EnemyMoveLeftHandler  -1 ; $01 - CL_EnemyMoveDir_Le
                            .word EnemyMoveRightHandler -1 ; $02 - CL_EnemyMoveDir_Ri
                            .word EnemyMoveUpHandler    -1 ; $03 - CL_EnemyMoveDir_Up
                            .word EnemyMoveDownHandler  -1 ; $04 - CL_EnemyMoveDir_Do
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpBlocked        Does    : deactivate this enemy - eventually count up enemy locked in a hole time
;                                   : enemy does not move anymore and is fixed in this positions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpBlocked         .block                           ; 
                            lda CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq EnemyMoveUpBlockedX         ; check: in hole time up - yes
                            bmi EnemyMoveUpBlockedX         ; check: still carries gold - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; correct enemy in hole time to CLZ_EnemyHoleGoldTime_Shake_X ($07) again
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyHoleGoldTime       ; count up enemy locked in a hole time
                            
EnemyMoveUpBlockedX         jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpHandler        Does    : try to move enemy up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpHandler         .block                           ; 
                            ldy CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #CLZ_EnemyOnImgPosY_Mid + $01 ; test beyond center
                            bcs MoveUpPrepare               ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved up a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if already on top row
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq EnemyMoveUpBlocked          ; check: top row - yes: care for timer - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; step one row up
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> path up blocked - move up impssible
; BrickHard  --> path up blocked - move up impssible
; BrickTrap  --> path up blocked - move up impssible
; BrickEnemy --> path up blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a normal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a trap door - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile above enemy is suitable for a move up
; --------------------------------------------------------------------------------------------------------------------- ;
MoveUpPrepare               jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image position up a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            bpl EnemyMoveUpPickGold         ; check: max up: no: eventually pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #CL_TileNum_Empty           ; get empty space substitution
                            
SetGameDataTile             sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new row number one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyRow                ; dec actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get data tile on enemy col of new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #CL_TileNum_Enemy           ; get enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image to max PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyOnImgPosY_Max     ; get max PosY
                            sta CLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            bne EnemyMoveSpriteUpDo         ; always - handle enemy sprite images for move up or down
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpPickGold       Does    : eventually let the enemy pick up gold - enemy move up/down exit point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpPickGold        .block                           ; 
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteUpDo       Does    : handle enemy sprite images for move up or down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteUpDo        .block                           ; 
                            lda #CLZ_EnemySprtNum_Ladder_00 ; get sprite num min
                            ldx #CLZ_EnemySprtNum_Ladder_01 ; get sprite num max
                            jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDownHandler      Does    : try to move enemy down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownHandler       .block                           ; 
                            ldy CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #CLZ_EnemyOnImgPosY_Mid     ; test beyond center
                            bcc MoveDownPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved down a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on bottom row - yes: disable him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #CLZ_ScreenRow_Max          ; test bottom row
                            bcs EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row below enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; step one row down
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickHard  --> path down blocked - exit - move down impssible
; BrickEnemy --> path down blocked - exit - move down impssible
; BrickSoft  --> path down blocked - exit - move down impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne MoveDownPrepare             ; check: EQ - no: not blocked - try to move down
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownDisable        jmp EnemyMoveStatusSave         ; exit - save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile below enemy is suitable for a move down
; --------------------------------------------------------------------------------------------------------------------- ;
MoveDownPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos down a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Max + $01 ; test max down
                            bcc GoEnemyMoveUpPickGold       ; check: LT - yes: eventualy pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #CL_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new row number one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyRow                ; inc actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on col of new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #CL_TileNum_Enemy           ; get enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on image to min PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyOnImgPosY_Min     ; get min PosY
                            sta CLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            jmp EnemyMoveSpriteUpDo         ; handle enemy sprite images for move up or down
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveUpPickGold       jmp EnemyMoveUpPickGold         ; eventually pick up gold - handle sprite images
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveLeftHandler      Does    : try to move enemy left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftHandler       .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #CLZ_EnemyOnImgPosX_Mid + $01 ; test beyond center
                            bcs MoveLeftPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            beq EnemyMoveLeftDisable        ; check: already max left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of new col left of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path left blocked - move left impssible
; BrickSoft  --> path left blocked - move left impssible
; BrickHard  --> path left blocked - move left impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is an enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col left of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col left of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new col left of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            bne MoveLeftPrepare             ; check: EQ - no: all free - try to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftDisable        jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile left of enemy is suitable for a move left
; --------------------------------------------------------------------------------------------------------------------- ;
MoveLeftPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #CLZ_EnemyViewDir_Le        ; get view dir left
                            sta CLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos left a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            bpl EnemyMoveLeftWithGold       ; check: max left: no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let this enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #CL_TileNum_Empty           ; get empty space substitution
                            
SetGameDataTile             sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyCol                ; dec actual enemy col
                            dey                             ; dec row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy new col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
SetEnemyImageNum            lda #CL_TileNum_Enemy           ; get enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image max PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyOnImgPosX_Max     ; get 
                            sta CLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            bne EnemyMoveLeftWithoutGold    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveLeftWithGold       jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftWithoutGold    ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get run sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemySprtNum_Run_Le_00 ; get run sprite num min
                            ldx #CLZ_EnemySprtNum_Run_Le_02 ; get run sprite num max
                            bne EnemyMoveSpriteLeft         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get hang sprite
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumPole            lda #CLZ_EnemySprtNum_Pole_Le_00; get pole sprite num min
                            ldx #CLZ_EnemySprtNum_Pole_Le_02; get pole sprite num max
                            
EnemyMoveSpriteLeft         jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveRightHandler     Does    : try to move enemy right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightHandler      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #CLZ_EnemyOnImgPosX_Mid     ; test beyond center
                            bcc MoveRightPrepare            ; check: LT - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            cpy #CLZ_ScreenCol_Max          ; test max right
                            beq EnemyMoveRightDisable       ; check: already max right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path right blocked - move right impssible
; BrickSoft  --> path right blocked - move right impssible
; BrickHard  --> path right blocked - move right impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is an enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            bne MoveRightPrepare            ; check: EQ - no: not blocked - try to move right
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightDisable       jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile right of enemy is suitable for a move right
; --------------------------------------------------------------------------------------------------------------------- ;
MoveRightPrepare            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #CLZ_EnemyMoveDir_Le        ; get move dir left
                            sta CLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos right a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            lda CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #CLZ_EnemyOnImgPosX_Max + $01 ; test max right
                            bcc EnemyMoveRightWithGold      ; check: LT - no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let this enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #CL_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_EnemyCol                ; inc actual enemy col
                            iny                             ; inc row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CL_LodeRuState              ; set CL_LodeRuState_Death
                            
SetEnemyImageNum            lda #CL_TileNum_Enemy           ; get enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image min PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyOnImgPosX_Min     ; get 
                            sta CLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            beq EnemyMoveRightWithoutGold   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveRightWithGold      jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightWithoutGold   ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get run sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemySprtNum_Run_Ri_00 ; get run sprite num min
                            ldx #CLZ_EnemySprtNum_Run_Ri_02 ; get run sprite num max
                            bne EnemyMoveSpriteRight        ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get hang sprite
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumPole            lda #CLZ_EnemySprtNum_Pole_Ri_00; get pole sprite num min
                            ldx #CLZ_EnemySprtNum_Pole_Ri_02; get pole sprite num max
                            
EnemyMoveSpriteRight        jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDirProposal   Does    : return an enemy move direction for the move dispatcher
;                           Expects : .X=actual enemy col number (from CLZ_EnemyCol)
;                                   : .Y=actual enemy row number (from CLZ_EnemyRow)
;                           Returns : .A=enemy move direction
;                           Remark  : 1st - test if the enemy is locked up in a hole
;                                           --> Return move dir up
;                                   : 2nd - test if enemy/loderunner rows are same
;                                   :       test on which side of the loderunner this enemy is located
;                                   :       loop until scan col left/right EQ loderunner col
;                                   :         if loderunner col is reached    <-- return move dir left/right
;                                   :         if col is without a Ladder/Pole
;                                   :           check col on row below enemy row
;                                   :           if col is Empty/BrickTrap     <-- exit to enemy/loderunner rows differ
;                                   :             no move le/ri if an Empty/BrickTrap uncovered by a Ladder/Pole is in his way
;                                   : 3rd - enemy/loderunner rows differ
;                                   :       --> EnemyMoveGetMaxColLeRi - game data: col before BrickSoft/BrickSolid  OR   (cares for holes)
;                                                                        ctrl data: 1st col pair without top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder  OR
;                                                                                   CL_ScreenCols_Min/CL_ScreenCols_Max
;                                   :       --> EnemyMoveScanGoal      - see if enemy can be moved down or right
;                                   :       --> EnemyMoveScanWingLeft  - scan left  side of enemy for a possible move left
;                                   :       --> EnemyMoveScanWingRight - scan right side of enemy for a possible move up
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDirProposal    .block                           ; 
                            stx CLZ_EnemyMoveColStart       ; set fix actual enemy col - copied from CLZ_EnemyCol
                            sty CLZ_EnemyMoveRowStart       ; set fix actual enemy row - copied from CLZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st: look if the enemy is locked up in a hole
;        game data tile under the enemy is empty
;        ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            bne ChkEnemyAndLodeRuRowSame    ; check: EQ - no: test if this enemy is on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is locked up in a hole - check: enemy carries gold/locked in a hole timer is expired
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq ChkEnemyAndLodeRuRowSame    ; check: still in hole  - no : check if on loderunner row
                            bmi ChkEnemyAndLodeRuRowSame    ; check: still has gold - yes: check if on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; positive: exit with move_up - get this enemy up out of the hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_EnemyMoveDir_Up         ; get move up - step enemy climb out of hole
                            rts                             ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd: look if loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
ChkEnemyAndLodeRuRowSame    ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            cpy CLZ_LodeRuRow               ; test actual row loderunner
                            beq EnemyAndLodeRuRowSame       ; check: EQ - yes: both on same row
                            
                            jmp EnemyAndLodeRuRowDiffer     ; loderunner and enemy are not on the same row
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowSame       ldy CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            sty CLZ_EnemyMoveLodeRuColGap   ; ini col gap between enemy and loderunner
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; test on which side of the loderunner the enemy is located
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
                            cpy CLZ_LodeRuCol               ; test actual col loderunner
                            bcs ScanNextEnemyColLeft        ; check: loderunner left of enemy - no: right
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the left side of loderunner - check if it is possible to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl data tiles right from enemy col towards loderunner col for Ladder/Pole
;   an enemy does not move right if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColRight       inc CLZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan of row below actual row
; Pole   --> continue with next col right - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next ctrl tile right on enemy is a ladder - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile right of enemy is a pole - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile right of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles right below enemy row from enemy col to loderunner col
;   an enemy does not move right if a hole/trap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is Empty - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is BrickTrap - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan right has reached loderunner col - exit with enemy move_right
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColRight    ldy CLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
                            cpy CLZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColRight       ; check: NE - yes: continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan right towards loderunner col finished - return move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_EnemyMoveDir_Ri         ; get enemy move_right
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the right side of loderunner - check if it is possible to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left from enemy col towards loderunner col for Ladder/Pole
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColLeft        dec CLZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from left
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan of row below actual row
; Pole   --> continue with next col left - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a ladder - skip scan below - check if loderunner column is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a pole - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: bottom reached - move left is possible 
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile left of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left below of enemy from enemy col to loderunner col
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is Empty - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is BrickTrap - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan left has reached loderunner col - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColLeft     ldy CLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
                            cpy CLZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColLeft        ; check: NE - yes: continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; scan left towards loderunner col finished - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_EnemyMoveDir_Le         ; get enemy move_left
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd: loderunner and enemy are not on same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowDiffer     lda #CLZ_EnemyMoveDir_Ini       ; get initial value
                            sta CLZ_EnemyMoveDir            ; ini actual enemy move direction
                            
                            lda #CLZ_EnemyMoveDistMin_Ini   ; get initial value - guarantees a successful 1st check
                            sta CLZ_EnemyMoveDistMin        ; ini enemy move target max distance
                            
                            ldx CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; Set      : CLZ_EnemyMoveMaxCol_Le = max col left  for 
;          : CLZ_EnemyMoveMaxCol_Ri = max col right for 
;          : 
; which is : col before blocking BrickSoft/BrickSolid  OR
;          : col pair without (top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder)  OR
;          : min screen col/max screen col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveGetMaxColLeRi      ; scan game/ctrl data for enemy max left/right move columns
; --------------------------------------------------------------------------------------------------------------------- ;
; for this enemy the playfield is now split into three parts
;   goal       - scan one enemy col position
;   left  wing - scan cols from enemy max col left  towards enemy col
;   right wing - scan cols from enemy max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveScanGoal           ; scan row/col pos of enemy for a possible move down or right
                            jsr EnemyMoveScanWingLeft       ; scan left  side  of enemy for a possible move left
                            jsr EnemyMoveScanWingRight      ; scan right side  of enemy for a possible move up
                            
                            lda CLZ_EnemyMoveDir            ; return the enemy move direction found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeftX    Does    : exit point of EnemyMoveScanWingLeft
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeftX     .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeft     Does    : scan left side of enemy for a possible move left
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Le EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_left
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_left
;                                   : step EnemyMoveMaxCol_Le towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeft      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col left towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColLeft          ldy CLZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from CLZ_EnemyCol
                            beq EnemyMoveScanWingLeftX      ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            cpy #CLZ_ScreenRow_Max          ; test bottom row
                            beq CheckOnRow_Top              ; check: EQ - yes: skip scan of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move left - continue with top row handling
; BrickHard --> skip evaluation move left - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: skip set move left
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Le        ; get move dir left
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Le       ; check: top row - yes: step scan col to the right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move left - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col left on enemy row is a ladder - yes: evaluate a new move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Le       ; check: EQ - no: skip move evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            ldx CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Le       ; check: GE - yes: advance col position from left towards enemy
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Le        ; get move dir left
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Le       inc CLZ_EnemyMoveMaxCol_Le      ; step scan col to the next column right
                            
                            jmp GetNextScanColLeft          ; continue scan from max col left to actual enemy col
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRightX   Does    : exit point of EnemyMoveScanWingRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRightX    .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRight    Does    : scan right side of enemy for a possible move up
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Ri EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_up
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_up
;                                   : step EnemyMoveMaxCol_Ri towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRight     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColRight         ldy CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from CLZ_EnemyCol
                            beq EnemyMoveScanWingRightX     ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            beq CheckOnRow_Top              ; check: EQ - yes: bottom reached - check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move up - continue with top row handling
; BrickHard --> skip evaluation move up - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: check if on top row
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Up        ; get move dir up
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Ri       ; check: max up reached - yes: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move up - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col right on enemy row is a ladder - yes: evaluate a new move up
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Ri       ; check: EQ - no: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            ldx CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Ri       ; check: GE - yes: reduce scan col to next pos right
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Up        ; get move dir up
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from right towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Ri       dec CLZ_EnemyMoveMaxCol_Ri      ; dec enemy possible max col right
                            jmp GetNextScanColRight         ; continue scan right
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanGoal         Does    : scan enemy col position on enemy row for a possible move down or right
;                           Expects : 
;                           Returns : 
;                           Remark  : scan tile of enemy col on enemy row
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_down
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_right
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoal          .block                           ; 
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #CLZ_ScreenRow_Max          ; test bottom row
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: further down impossible - check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from CLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip scan down - continue with scan up
; BrickHard --> skip scan down - continue with scan up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a solid brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckEnemyOnRow_Top         ; check: GE - yes: check if on top row
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_down for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Do        ; get enemy move down
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - exit routine
; --------------------------------------------------------------------------------------------------------------------- ;
CheckEnemyOnRow_Top         ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            beq EnemyMoveScanGoalX          ; check: top row - yes: skip row test - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne EnemyMoveScanGoalX          ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get max top row for enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            ldy CLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from CLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx CLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from CLZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from target col or from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs EnemyMoveScanGoalX          ; check: GE - yes: skip set new move dir
                            
                            sta CLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_right for the new min distance
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyMoveDir_Ri        ; get move dir right
                            sta CLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoalX          rts                             ; 
                            
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDistance      Does    : get enemy distance from target col or loderunner row
;                           Expects : .A=enemy target row - max is the actual loderunner row
;                                   : .X=enemy target col
;                           Returns : enemy target row and loderunner row same  : .A=distance enemy col from enemy max col le/ri
;                                   : enemy target row and loderunner row differ: .A=distance enemy row from loderunner row with up/do marker added
;                           Remark  : called from EnemyMoveScanGoal      with .A=EnemyMoveGetMaxRowBot .X=CLZ_EnemyMoveColStart
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=CLZ_EnemyMoveColStart
;                                   : called from EnemyMoveScanWingLeft  with .A=EnemyMoveGetMaxRowBot .X=CLZ_EnemyMoveMaxCol_Le
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=CLZ_EnemyMoveMaxCol_Le
;                                   : called from EnemyMoveScanWingRight with .A=EnemyMoveGetMaxRowBot .X=CLZ_EnemyMoveMaxCol_Ri
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=CLZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDistance       .block                           ; 
                            sta CLZ_WorkEnemyParmSave       ; save a possible row subtraction value
                            
                            cmp CLZ_LodeRuRow               ; test enemy target row with actual loderunner row
                            bne ChkTargRowBelowLodeRuRow    ; check: EQ - no: check if higher/lower loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max target row is same as loderunner row - choose direction le/ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpx CLZ_EnemyCol                ; test enemy target col with actual enemy col
                            bcc EnemyIsRightOfTargetCol     ; check: taget col LT - yes: 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is left of target col - subtract actual enemy col from target col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get enemy target col
                            sec                             ; 
                            sbc CLZ_EnemyCol                ; sub actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is right of target col - subtract target col from actual enemy col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyIsRightOfTargetCol     stx CLZ_WorkEnemyParmSave       ; save enemy target col for subtraction
                            
                            lda CLZ_EnemyCol                ; get actual enemy col
                            sec                             ; 
                            sbc CLZ_WorkEnemyParmSave       ; sub enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max row and actual loderunner row differ - choose direction up/do
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTargRowBelowLodeRuRow    bcc EnemyTargRowAboveLodeRuRow  ; check: enemy target row LT actual loderunner row - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is below actual loderunner row - subtract loderunner row from target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc CLZ_LodeRuRow               ; sub actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is below actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $02                  ; add move up marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with up value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is above actual loderunner row - subtract target row from loderunner row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyTargRowAboveLodeRuRow  lda CLZ_LodeRuRow               ; get actual row loderunner
                            sec                             ; 
                            sbc CLZ_WorkEnemyParmSave       ; sub enemy target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is above actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $01                  ; add move down marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with down value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTopX    Does    : exit point - return enemy row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTopX     .block                           ; 
                            lda CLZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTop     Does    : return the maximum top row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row up
;                           Remark  : entered if this enemy has reached a ladder on his way up
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=CLZ_EnemyMoveColStart  .Y=CLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=CLZ_EnemyMoveMaxCol_Le .Y=CLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=CLZ_EnemyMoveMaxCol_Ri .Y=CLZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row up at the given enemy col
;                                   :   loop until scan row LT top row
;                                   :     tile of scan row is NOT a Ladder                    --> exit with actual scan row
;                                   :     tile of scan row is     a Ladder
;                                   :       step scan row one up
;                                   : 
;                                   :     tile left of scan col on scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile left of scan col on decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   : 
;                                   :     tile right of scan col on row below decreased scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile right of decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTop      .block                           ; 
                            sty CLZ_EnemyMoveScanRow        ; ini scan row to enemy row
                            stx CLZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextCtrlDataPtr          lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne EnemyMoveGetMaxRowTopX      ; check: EQ - no: exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; step scan row one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_EnemyMoveScanRow        ; step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
                            beq ScanTargetCol_Ri            ; check: already max left - yes: start check right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row - row above actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get new actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on decreased row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left of scan col on decreased row is Pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            bne ScanTargetCol_Ri            ; check: EQ - no: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Le     ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            sty CLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=CLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is GT enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy CLZ_EnemyMoveScanCol        ; get scan col
                            cpy #CLZ_ScreenCol_Max          ; test already max right
                            beq ChkEndOfScanTop             ; check: EQ - yes: end of scan right - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get decreased scan row
                            
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: max scan row LE LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            bne ChkEndOfScanTop             ; check: EQ - no: skip LR exit check - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Ri     ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            sty CLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=CLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner row is below enemy row right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: top row reached - end of scan - exit with .A=CLZ_EnemyMoveScanRow
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfScanTop             ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #CLZ_ScreenRow_Min + $01    ; test top row
                            bcc ReturnMoveTargetRowTop      ; check: LT - yes: exit
                            
                            jmp SetNextCtrlDataPtr          ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowTop      tya                             ; return top row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda CLZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; return point for EnemyMoveGetMaxRowBot if scan below reveals a BrickSoft/BrickHard
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveScanRow           lda CLZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowBot     Does    : return the maximum bottom row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row down
;                           Remark  : entered if this enemy has reached a pole or a ladder on his way down
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=CLZ_EnemyMoveColStart  .Y=CLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=CLZ_EnemyMoveMaxCol_Le .Y=CLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=CLZ_EnemyMoveMaxCol_Ri .Y=CLZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row down at the given enemy col
;                                   :   loop until scan row GT bottom row
;                                   :     tile of row below scan row is a BrickSoft/BrickHard --> exit with scan row  
;                                   :     tile of scan row is Empty
;                                   :       step scan row one down -       if max row reached --> exit with bottom row
;                                   : 
;                                   :     tile left of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile left of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   : 
;                                   :     tile right of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile right of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowBot      .block                           ; 
                            sty CLZ_EnemyMoveScanRow        ; ini scan row from enemy row
                            stx CLZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
ChkNextTargetCtrlDataRowPos lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> exit with actual scan row
; BrickHard --> exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3Q
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> advance actual scan row - check: bottom row reached - yes: exit with ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq AdvanceEnemyMoveTargetRow   ; check: EQ - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #CLZ_ScreenCol_Min          ; test max col left
                            beq ScanTargetCol_Ri            ; check: EQ - yes: check scan col max right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne ScanTargetCol_Ri            ; check: EQ - no: start scan col right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Le     ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            sty CLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=CLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=CLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; pole check right done with TabCtrlLevelDataRow_Hi and TabCtrlLevelDataRow_Hi + $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: advance scan row - check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy CLZ_EnemyMoveScanCol        ; get scan col
                            cpy #CLZ_ScreenCol_Max          ; test max right
                            bcs AdvanceEnemyMoveTargetRow   ; check: GE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to next tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            bne AdvanceEnemyMoveTargetRow   ; check: NE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Ri     ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            sty CLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=CLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy CLZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=CLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is LT loderunner row - step scan row further down
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMoveTargetRow   inc CLZ_EnemyMoveScanRow        ; step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: bottom row reached - end of scan - exit with .A=CLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #CLZ_ScreenRow_Max + $01    ; test max row passed
                            bcs ReturnMoveTargetRowBottom   ; check: GE - yes: get max row and exit
                            
                            jmp ChkNextTargetCtrlDataRowPos ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowBottom   lda #CLZ_ScreenRow_Max          ; get bottom scan row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda CLZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxColLeRi    Does    : scan game/ctrl data of enemy col on enemy row for the max left/right move col
;                                   : 
;                                   ;   scan game data: return col before BrickSoft/BrickSolid  OR   (game data cares for holes)
;                                   ;   scan ctrl data: return 1st col pair without top Ladder/Pole  AND  without bottom BrickSoft/BrickSolid/Ladder
;                                   ;   none of these : return CL_ScreenCols_Min/CL_ScreenCols_Max
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : CLZ_EnemyMoveMaxCol_Le = max col left
;                                   : CLZ_EnemyMoveMaxCol_Ri = max col right
;                           Remark  : loop until scan col EQ max col left
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - start scan right
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - start scan right
;                                   :   dec CLZ_EnemyMoveMaxCol_Le
;                                   : 
;                                   : loop until scan col EQ max col right
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - exit routine
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - exit routine
;                                   :   inc CLZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxColLeRi     .block                           ; 
                            stx CLZ_EnemyMoveMaxCol_Le      ; ini enemy max col left  to actual col of this enemy
                            stx CLZ_EnemyMoveMaxCol_Ri      ; ini enemy max col right to actual col of this enemy
                            sty CLZ_EnemyMoveMaxRow         ; ini enemy max row       to actual row of this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col left reached - yes: exit scan left - start looking for max col right
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColLeft     lda CLZ_EnemyMoveMaxCol_Le      ; get actual scan max col left
                            beq GetNextEnemyScanColRight    ; check: max screen col left reached - yes: start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to next position left of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan left - start scan right
; BrickHard --> stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a normal brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a solid brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col left of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan row below enemy row
; Pole   --> continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a ladder - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a pole - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to tile one left below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; BrickHard --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; Ladder    --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; All other --> finalize scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a normal brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a solid brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a ladder - yes: continue with next col left - else: exit scan left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Le            ; check: EQ - no: done - adapt scan left max - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; step to next col position left - check: max left reached - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Le       dec CLZ_EnemyMoveMaxCol_Le      ; step actual enemy max col to the left
                            bpl GetNextEnemyScanColLeft     ; always - never gets negative
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan left - set final column left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Le            dec CLZ_EnemyMoveMaxCol_Le      ; set final possible enemy max col left
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col right reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColRight    lda CLZ_EnemyMoveMaxCol_Ri      ; get actual scan max col right
                            cmp #CLZ_ScreenCol_Max          ; test max screen col right reached
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to next position right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan right - exit scan routine
; BrickHard --> stop scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a normal brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - stop col scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a solid brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col right of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan row below enemy row
; Pole   --> continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a ladder - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a pole - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #CLZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy CLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to tile one right below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; BrickHard --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Ladder    --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Other     --> finalize scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a normal brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: normal - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a solid brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: solid - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a ladder - yes: continue with next col right - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Ri            ; check: EQ - no: mark scan right max - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col position right - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Ri       inc CLZ_EnemyMoveMaxCol_Ri      ; inc actual enemy max col right
                            bpl GetNextEnemyScanColRight    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan right - set final col right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Ri            inc CLZ_EnemyMoveMaxCol_Ri      ; actual enemy possible col right
                            
EnemyMoveGetMaxColLeRiX     rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetScrnGfxPosXY  Does    : get the enemy image gfx screen position
;                           Expects : 
;                           Returns : .A=enemy image number
;                                   : .X=enemy image gfx screen horizontal offset
;                                   : .Y=enemy image gfx screen vertical offset
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetScrnGfxPosXY   .block                           ; 
                            ldx CLZ_EnemyCol                ; get actual enemy col
                            ldy CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; add horizontal gfx screen image offset
                            
                            stx CLZ_WorkImgOffsetPosX       ; save horizontal offset
                            
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            ldx CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            jsr ScreenAddGfxOnImagePosY     ; add vertical gfx screen image offset
                            
                            ldx CLZ_EnemySprtNum            ; get actual enemy sprite number
                            lda TabNumSpriteEnemy,x         ; get image number
                            ldx CLZ_WorkImgOffsetPosX       ; restore horizontal offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMovePickUpGold       Does    : eventually let enemy pick up gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGold        .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is centered completely
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #CLZ_EnemyOnImgPosX_Mid     ; test centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
                            
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Mid     ; test  centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile directly under this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under enemy is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Gold            ; test gold
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: level tile is not gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy has gold timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_EnemyHoleGoldTime       ; get enemy has gold time - counted up to $00
                            bmi EnemyMovePickUpGoldX        ; check: already carries gold - yes: do not pick up another
; --------------------------------------------------------------------------------------------------------------------- ;
; let this enemy get a piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
; randomly init enemy carries gold timer with last rebirth column value .honz.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_EnemyHoleGoldTime_Ini  ; ini enemy has gold time
                            sec                             ; 
                            sbc CL_EnemyBirthCol            ; sub enemy rebirth column - make it even more negative
                            sta CLZ_EnemyHoleGoldTime       ; set enemy has gold time - counted up to $00
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get clear gold
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #CL_TileNum_Gold            ; get gold
                            jmp ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGoldX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDropGold         Does    : eventually let enemy drop his gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDropGold          .block                           ; 
                            lda CLZ_EnemyHoleGoldTime       ; get enemy carries gold time - counted up to $00
                            bpl EnemyMoveDropGoldX          ; check: carries gold - no: already dropped or none
                            
                            inc CLZ_EnemyHoleGoldTime       ; inc enemy carries gold time - counted up to $00
                            bne EnemyMoveDropGoldX          ; check: hold gold time up - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy has grown tired of carrying around his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyRow                ; get actual enemy row
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; drop the gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_EnemyCol                ; get actual enemy col
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if designated place is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
                            cmp #CL_TileNum_Empty           ; test empty space
                            bne RestoreEnemyHasGoldTime     ; check: EQ - no: drop impossible - restore timer and exit
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Gold            ; get gold
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
; --------------------------------------------------------------------------------------------------------------------- ;
; display dropped gold                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Gold            ; get tile number gold
                            jmp ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; revert previous inc of enemy carries gold timer - is only discounted if the gold is droppable
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyHasGoldTime     dec CLZ_EnemyHoleGoldTime       ; restore enemy has gold time - counted up to $00
                            
EnemyMoveDropGoldX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteNumRotate  Does    : rotate enemy sprite numbers between minimum and maximum values
;                           Expects : .A=test sprite range number min
;                                   : .X=test sprite range number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteNumRotate   .block                           ; 
                            inc CLZ_EnemySprtNum            ; inc enemy sprite number to next phase
                            
                            cmp CLZ_EnemySprtNum            ; test actual enemy sprite number min
                            bcc ChkSpriteNumberMax          ; check: LT - yes: out of min range
                            
SetSpriteNumber             sta CLZ_EnemySprtNum            ; set min enemy sprite number
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkSpriteNumberMax          cpx CLZ_EnemySprtNum            ; test actual enemy sprite number max
                            bcc SetSpriteNumber             ; check: LT - yes
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosX  Does    : eventually step the enemy towards the center of the image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosX   .block                           ; 
                            lda CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #CLZ_EnemyOnImgPosX_Mid     ; test center
                            bcc StepEnemyRight              ; check: LT - yes: step right to center
                            beq EnemyMoveCenterImagePosXX   ; check: EQ - yes: exit
                            
                            dec CLZ_EnemyOnImgPosX          ; enemy is right of center - step him left
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyRight              inc CLZ_EnemyOnImgPosX          ; enemy is left of center - step him right
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosXX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosY  Does    : eventually step the enemy towards the center of the image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosY   .block                           ; 
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #CLZ_EnemyOnImgPosY_Mid     ; test center
                            bcc StepEnemyDown               ; check: LT - yes: step down to center
                            beq EnemyMoveCenterImagePosYX   ; check: EQ - yes: exit
                            
                            dec CLZ_EnemyOnImgPosY          ; enemy is below the center - step him up
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyDown               inc CLZ_EnemyOnImgPosY          ; enemy is above the center - step him down
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosYX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; EnemyMoveStatusSave       Does    : save enemy status to save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusSave        .block
                            ldx CL_EnemyToMoveNum           ; get active enemy number
                            
                            lda CLZ_EnemyCol                ; get actual enemy col
                            sta CL_SA_EnemyCol,x            ; save actual enemy col
                            
                            lda CLZ_EnemyRow                ; get actual enemy row
                            sta CL_SA_EnemyRow,x            ; save actual enemy row
                            
                            lda CLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            sta CL_SA_EnemyPosOnImgPosX,x   ; save enemy pos on image left/right tab
                            
                            lda CLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            sta CL_SA_EnemyPosOnImgPosY,x   ; save enemy pos on image up/down tab
                            
                            lda CLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            sta CL_SA_EnemyHoleGoldTime,x   ; save enemy either has gold or locked in a hole time
                            
                            lda CLZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            sta CL_SA_EnemyViewDir,x        ; save enemy move dir 
                            
                            lda CLZ_EnemySprtNum            ; get actual enemy sprite number
                            sta CL_SA_EnemySprtNum,x        ; save actual enemy sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveStatusRestore    Does    : restore enemy status from save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusRestore     .block                           ; 
                            ldx CL_EnemyToMoveNum           ; get activation enemy number
                            
                            lda CL_SA_EnemyCol,x            ; get enemy save area column
                            sta CLZ_EnemyCol                ; set actual enemy col
                            
                            lda CL_SA_EnemyRow,x            ; get saved adr row enemy
                            sta CLZ_EnemyRow                ; set actual enemy row
                            
                            lda CL_SA_EnemyPosOnImgPosX,x   ; get saved  pos on image left/right tab
                            sta CLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            lda CL_SA_EnemyPosOnImgPosY,x   ; get saved  pos on image up/down tab
                            sta CLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            lda CL_SA_EnemySprtNum,x        ; get saved  enemy sprite number
                            sta CLZ_EnemySprtNum            ; set actual enemy sprite number
                            
                            lda CL_SA_EnemyViewDir,x        ; get saved enemy move dir
                            sta CLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
                            
                            lda CL_SA_EnemyHoleGoldTime,x  ; get enemy either has gold or locked in a hole time
                            sta CLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameCloseHoles            Does    : close open holes and eventually kill a trapped loderunner/enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHoles             .block                           ; 
                            jsr EnemyRebirth                ; step an enemy back to life
; --------------------------------------------------------------------------------------------------------------------- ;
; advance enemmy birth column
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_EnemyBirthCol            ; inc enemy rebirth column
                            lda CL_EnemyBirthCol            ; get enemy rebirth column
                            cmp #CL_EnemyBirthCol_Max       ; test max column number
                            bcc GetOpenHolesMaxOff          ; check: LT - yes
                            
                            lda #CL_EnemyBirthCol_Min       ; get initial value
                            sta CL_EnemyBirthCol            ; ini enemy rebirth column
; --------------------------------------------------------------------------------------------------------------------- ;
; scan open hole times work area
; --------------------------------------------------------------------------------------------------------------------- ;
GetOpenHolesMaxOff          ldx #CL_WA_HoleMax              ; get max number of open holes
GetNextOpenHoleTime         lda CL_WA_HoleOpenTime,x        ; get next hole open time tab entry
                            
                            stx CLZ_HoleOpenTimeTabOff      ; save open holes time tab offset
                            
                            bne DecCloseHoleOpenTime        ; check: closed already - no: tick time down
                            
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; tick open hole times down
; --------------------------------------------------------------------------------------------------------------------- ;
DecCloseHoleOpenTime        dec CL_WA_HoleOpenTime,x        ; dec open hole time count
                            beq CloseHoleComplete           ; check: open time out - yes: complete close
; --------------------------------------------------------------------------------------------------------------------- ;
; set open hole column and row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_WA_HoleCol,x             ; get hole column tab entry
                            sta CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda CL_WA_HoleRow,x             ; get hole row tab entry
                            sta CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 01 finished
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_WA_HoleOpenTime,x        ; get open hole time count
                            cmp #CL_WA_HoleOpenTimeStep_01  ; test 1st step close already passed
                            bne ChkCloseSecondStep          ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_ImageNumber_Hole_Close ; get image close hole 1st step
                            
CloseHoleNextStep           jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #CL_TileNum_Empty           ; get empty tile
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
GoSetNextOpenHoleTabPtr     jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 02 finished
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCloseSecondStep          cmp #CL_WA_HoleOpenTimeStep_02  ; test 2nd step close already passed
                            bne GoSetNextOpenHoleTabPtr     ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CLZ_ImageNumber_Hole_Close + $01 ; get image close hole 2nd step
                            bne CloseHoleNextStep           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole complete - check if occupied by loderunner or an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CloseHoleComplete           ldx CLZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            ldy CL_WA_HoleRow,x             ; get hole row tab entry
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row of open hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CL_WA_HoleCol,x             ; get hole column tab
                            sty CLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile on closed hole row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            bne ChkLodeRuInHole             ; check: EQ - no: contains loderunner or an enemy
                            
                            jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuInHole             cmp #CL_TileNum_LodeRunner      ; test loderunner
                            bne ChkEnemyInHole              ; check: EQ - no: test enemy
                            
                            lsr CL_LodeRuState              ; trapped in hole - set CL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyInHole              cmp #CL_TileNum_Enemy           ; test enemy
                            beq EnemyKill                   ; check: EQ - yes: kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Gold            ; test gold
                            bne GoGameCloseHolesFinish      ; check: EQ - no
                            
                            dec CL_GoldToCollect            ; some gold was lost - dec gold to collect
                            
GoGameCloseHolesFinish      jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; kill an enemy trapped in the closed hole
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyKill                   lda #CL_TileNum_BrickSoft       ; get normal brick
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #CL_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx CL_EnemyCount               ; get number of enemies ($00-$05)
GetNextEnemyCol             lda CL_SA_EnemyCol,x            ; get enemy save area column
                            cmp CLZ_ScreenCol               ; test screen col ($00-$1b)
                            beq GetNextEnemyRow             ; check: enemy hole column found - yes
                            
                            jmp SetNextEnemyNum             ; set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyRow             lda CL_SA_EnemyRow,x            ; get enemy save area row
                            cmp CLZ_ScreenRow               ; test screen row ($00-$0f)
                            bne SetNextEnemyNum             ; check: enemy hole row found - no: set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy hole column and row found - disable enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemySpriteDisable,x     ; get disable enemy sprite tab
                            and SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_SA_EnemyHoleGoldTime,x   ; get enemy either has gold or locked in a hole time
                            bpl EnemyHasGoldReset           ; check: enemy had gold: no
                            
                            dec CL_GoldToCollect            ; enemy still had gold - discount
                            
EnemyHasGoldReset           lda #CL_SA_EnemyHoleGoldTime_Ini; get intitial value
                            sta CL_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            stx CL_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            ldx CL_EnemyToMoveNum           ; get number of enemy to move
; --------------------------------------------------------------------------------------------------------------------- ;
; find a place for enemy rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; get start with 2nd row
                            sty CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to next rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRebirthRow           ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get next level ctrl data tile on rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CL_EnemyBirthCol            ; get enemy rebirth column
GetNextLevelCtrlTile        lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CL_TileNum_Empty           ; test empty space
                            beq EnemyRevivePosSave          ; check: EQ - yes: success - found a place - revive this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; advance to next col
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CL_EnemyBirthCol            ; inc enemy rebirth column
                            
                            ldy CL_EnemyBirthCol            ; get enemy rebirth column
                            cpy #CL_EnemyBirthCol_Max       ; test max column number
                            bcc GetNextLevelCtrlTile        ; check: LT - yes: get next level ctrl tile
; --------------------------------------------------------------------------------------------------------------------- ;
; all columns for this row are checked unsuccessfully - restart with the next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #CL_EnemyBirthCol_Min       ; get start column number
                            sta CL_EnemyBirthCol            ; ini enemy rebirth column
                            
                            beq GetNextRebirthRow           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; save revive position
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRevivePosSave          tya                             ; get rebirth column number
                            sta CL_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda CLZ_ScreenRow               ; get rebirth screen row ($00-$0f)
                            sta CL_SA_EnemyRow,x            ; set enemy save area row
; --------------------------------------------------------------------------------------------------------------------- ;
; init and score enemy resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_WA_EnemyBirthStep_Ini   ; get rebirth start value
                            sta CL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            lda #CL_PosOnImage_Center       ; get centered position
                            sta CL_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
                            sta CL_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            
                            lda #CLZ_EnemySprtNum_Run_Le_00 ; get initial value
                            sta CL_SA_EnemySprtNum,x        ; set actual enemy sprite number
                            
                            ldy #>CL_Score_EnemyRebirth     ; score add value LO - a reborn enemy scores 75 points
                            lda #<CL_Score_EnemyRebirth     ; score add value HI
                            jsr StatusOutScore              ; score and update status row
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; count down enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyNum             dex                             ; number of enemies
                            beq GameCloseHolesFinish        ; check: all processed - yes: finish close hole
                            
                            jmp GetNextEnemyCol             ; continue resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesFinish        lda #CL_TileNum_BrickSoft       ; get normal brick
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #CL_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; check if all open holes are processed
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextOpenHoleTabPtr       ldx CLZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            dex                             ; dec open holes time tab offset
                            bmi GameCloseHolesX             ; check: all open holes processed - yes: exit
                            
                            jmp GetNextOpenHoleTime         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyRebirth              Does    : step an enemy back to life
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRebirth               .block                           ; 
                            ldx CL_EnemyCount               ; get number of enemies ($00-$05)
                            beq GameCloseHoles.GameCloseHolesX ; check: none - yes: exit
                            
                            lda CL_EnemyToMoveNum           ; get number of enemy to move
                            pha                             ; save number of enemy to move
                            
GetNextEnemyRebirthTime     lda CL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq DecNumberOfEnemyToMove      ; check: rebirth time up - yes
                            
                            stx CL_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            
                            lda #CL_SA_EnemyHoleGoldTime_Ini; get initial value
                            sta CL_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            lda CL_SA_EnemyCol,x            ; get enemy save area column
                            sta CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda CL_SA_EnemyRow,x            ; get enemy save area row
                            sta CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            dec CL_WA_EnemyBirthTime,x      ; dec enemy rebirth step time
                            beq EnemyResurrection           ; check: min - yes: reactivate resurrected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy rebirth step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            cmp #CL_WA_EnemyBirthStep_01    ; test first step rebirth
                            bne ChkRebirthStepTwo           ; check: already passed - no
                            
                            lda #CLZ_ImageNumber_Rebirth    ; get first step rebirth
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            
                            lda #CLZ_ImageNumber_Rebirth    ; get first step rebirth
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp GetNumberOfEnemyToMove      ; try next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy rebirth step 02
; --------------------------------------------------------------------------------------------------------------------- ;
ChkRebirthStepTwo           cmp #CL_WA_EnemyBirthStep_02    ; test time second step rebirth
                            bne DecNumberOfEnemyToMove      ; check: already passed - no
                            
                            lda #CLZ_ImageNumber_Rebirth + $01 ; get second step rebirth
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            
                            lda #CLZ_ImageNumber_Rebirth + $01 ; get second step rebirth
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
GetNumberOfEnemyToMove      ldx CL_EnemyToMoveNum           ; get number of enemy to move
                            
DecNumberOfEnemyToMove      dex                             ; count down enemy number
                            bne GetNextEnemyRebirthTime     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore number of enemy to move
                            sta CL_EnemyToMoveNum           ; set number of enemy to move
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyResurrection         Does    : reactivate a reborn enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyResurrection          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get resurrection position from EnemyRevivePosSave - set game data row pointer to screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; increase enemy rebirth time directly in work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CL_EnemyToMoveNum           ; get number of enemy to move
                            inc CL_WA_EnemyBirthTime,x      ; enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; get level game tile on rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if this tile in level game data is still empty - should be
; --------------------------------------------------------------------------------------------------------------------- ;
                            bne EnemyRebirth.DecNumberOfEnemyToMove ; check: empty - no: process next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; a free rebirth place was found - insert reborn enemy to game level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Enemy           ; get enemy
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear enemy image on both hires screens
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #CL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; init reborn enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value 
                            ldx CL_EnemyToMoveNum           ; get number of enemy to move
                            sta CL_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta CL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; display reborn enemy tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Enemy           ; get enemy tile number
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; enable reborn enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx CL_EnemyToMoveNum           ; get number of enemy to move
                            lda TabEnemySpriteEnable,x      ; get enable enemy sprite tab
                            ora SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            jmp EnemyRebirth.DecNumberOfEnemyToMove ; go set next enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteEnable        = *       ; 
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $10 ; ...#....
                            .byte $40 ; .#......
                            .byte $80 ; #.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteDisable       = *       ; 
                            .byte $00 ; ........
                            .byte $fb ; #####.##
                            .byte $f7 ; ####.###
                            .byte $ef ; ###.####
                            .byte $bf ; #.######
                            .byte $7f ; .#######
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GraficScreenClearBoth     Does    : clear the display and prepare screen hires screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GraficScreenClearBoth      .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            jsr ScreenPrepareClear          ; clear prepare grafic screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusAreaSetup           Does    : display the status row with separator and text
;                           Expects : 
;                           Returns : 
;                           Remark  : calculate a game checksum inbetween
;                                   : protects the copy protection routine
;                                   : destroy gfx data pointer on wrong result
; --------------------------------------------------------------------------------------------------------------------- ;
StatusAreaSetup            .block                           ; 
                            ldx #$22                        ; get length of status row separator line
; --------------------------------------------------------------------------------------------------------------------- ;
; ChecksumBuild: init build checksum data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>CopyProtection            ; protect the copy protection routine from changes
                            sta ChecksumBuild.smCheckSumDataPtr_Hi ; set checksum data pointer
                            
                            lda CLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cmp #>CL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq SeparatorOutToPrepScreen    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0a                        ; get grafic byte for separator line left end
                            sta CL_StatusRowSepDisp_Le_00   ; set left end 0
                            sta CL_StatusRowSepDisp_Le_01   ; set left end 1
                            sta CL_StatusRowSepDisp_Le_02   ; set left end 2
                            sta CL_StatusRowSepDisp_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta CL_StatusRowSepDisp_Ri_00   ; set right end 0
                            sta CL_StatusRowSepDisp_Ri_01   ; set right end 1
                            sta CL_StatusRowSepDisp_Ri_02   ; set right end 2
                            sta CL_StatusRowSepDisp_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusDispMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepDispMid_Lo    = * + $01                       ; 
smAdrStatusSepDispMid_Hi    = * + $02                       ; 
SetNextStatusDispMidPart    sta CL_StatusRowSepDisp_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusDispMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance display screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepDispMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepDispMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusDispMidCount       ; check: overflow - no
                            inc smAdrStatusSepDispMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusDispMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusDispMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>CL_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Hi    ; set start address HI
                            lda #<CL_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Lo    ; set start address LO
                            bne StatusLineTextOut           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output prepare screen status row separater line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
SeparatorOutToPrepScreen    lda #$0a                        ; get grafic byte for separator line left end
                            sta CL_StatusRowSepPrep_Le_00   ; set left end 0
                            sta CL_StatusRowSepPrep_Le_01   ; set left end 1
                            sta CL_StatusRowSepPrep_Le_02   ; set left end 2
                            sta CL_StatusRowSepPrep_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta CL_StatusRowSepPrep_Ri_00   ; set right end 0
                            sta CL_StatusRowSepPrep_Ri_01   ; set right end 1
                            sta CL_StatusRowSepPrep_Ri_02   ; set right end 2
                            sta CL_StatusRowSepPrep_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusPrepMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepPrepMid_Lo    = * + $01                       ; 
smAdrStatusSepPrepMid_Hi    = * + $02                       ; 
SetNextStatusPrepMidPart    sta CL_StatusRowSepPrep_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusPrepMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance preparation screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepPrepMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepPrepMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusPrepMidCount       ; check: overflow - no
                            inc smAdrStatusSepPrepMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusPrepMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusPrepMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>CL_StatusRowSepPrep_Mi_00 ; restore old value HI
                            sta smAdrStatusSepPrepMid_Hi    ; 
                            
                            lda #<CL_StatusRowSepPrep_Mi_00 ; restore old value LO
                            sta smAdrStatusSepPrepMid_Lo    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; write out the status row text
; --------------------------------------------------------------------------------------------------------------------- ;
StatusLineTextOut           lda #CL_StatusRowNumber         ; get status row row number
                            sta CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #CLZ_ScreenCol_Min          ; get initial value
                            sta CLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "s" | $80 ;               ; SCORE        MEN    LEVEL
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ChecksumBuild             Does    : build a checksum over a selected game binary part to prevent game modifications
;                           Expects : 
;                           Returns : destroyed grafic pointer on bad checksum
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild              .block                           ; 
                            ldy #CopyProtection.ChecksumBuild_End - CopyProtection.ChecksumBuild_Start ; init checksum byte count
                            lda #CL_ChecksumCalc_Start      ; 
AddNextChecksumValue        clc                             ; 
smCheckSumDataPtr_Hi        = * + $02                       ; 
                            adc ChkCharSubstitution.smChkCharSubstitution,y ; 
                            eor #CL_ChecksumCalc_Flip       ; 
                            dey                             ; 
                            bpl AddNextChecksumValue        ; check: 
                            
                            sta CL_CheckSum                 ; 
                            
                            cmp #CL_ChecksumCalc_Result     ; test 
                            beq SetGoodDataPointer          ; 
                            
                            inc ScreenImageGetBytes.smTileDataPtr ; 
                            
SetGoodDataPointer          lda RER                         ; Kernal: Flag TAPE READ ERROR
                            sta smCheckSumDataPtr_Hi        ; 
                            
                            jsr StatusOutLives              ; 
                            jsr StatusOutLevel              ; 
                            
                            lda #$00                        ; set no score to add
                            tay                             ; 
                            jmp StatusOutScore              ; AddDisplayScore (ac=1s yr=100s) - display only - no score to add
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLives            Does    : write out number of lives to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLives             .block                           ; 
                            lda CL_ColorStatus              ; get status line color
                            bne StatusOutLivesX             ; check: BLACK - no
                            
                            lda CL_NumLives                 ; get value to be converted
                            
                            ldx #CLZ_ScreenCol_Status_Lives ; get screen output col
; --------------------------------------------------------------------------------------------------------------------- ;
; entered from StatusOutLevel
; --------------------------------------------------------------------------------------------------------------------- ;
StatusRowOut                stx CLZ_ScreenCol               ; set screen output col (00-1b)
                            
                            jsr ConvertHexToDec             ; result in CL_Digit_100/CL_Digit_10/CL_Digit_1
                            
                            lda #CLZ_ScreenRow_Status       ; get status separator row number
                            sta CLZ_ScreenRow               ; set screen row (00-0f)
                            
                            lda CL_Digit_100                ; get digit 100 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLevel            Does    : write out the level number to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLevel             .block                           ; 
                            lda CL_LevelNumGame             ; get game level number 001-050
                            ldx #CLZ_ScreenCol_Status_Level ; get output column
                            
                            bne StatusOutLives.StatusRowOut ; always write out number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
; <obsolete> - never reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$14                        ; get score text output col
                            sta CLZ_ScreenCol               ; set screen col ($00 - $1b)
                            
                            lda #$10                        ; get score text output row
                            sta CLZ_ScreenRow               ; screen row ($00 - $0f)
                            
                            jsr TextOutHandler              ; TextOut
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp StatusOutLevel              ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLivesX           Does    : exit point for StatusOutLives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLivesX            .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutScore            Does    : update the games status row with the actual score
;                           Expects : .A=score add value LO
;                                   : .Y=score add value HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutScore             .block                           ; 
                            clc                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; decimal add the new score
; --------------------------------------------------------------------------------------------------------------------- ;
                            sed                             ; sed decimal flag
                            adc CL_Score_Lo                 ; .A has 10s
                            sta CL_Score_Lo                 ; set score 
                            
                            tya                             ; .Y has 100s
                            adc CL_Score_MidLo              ; 
                            sta CL_Score_MidLo              ; set score
                            
                            lda #$00                        ; add carry
                            adc CL_Score_MidHi              ; 
                            sta CL_Score_MidHi              ; set score
                            
                            lda #$00                        ; add carry
                            adc CL_Score_Hi                 ; 
                            sta CL_Score_Hi                 ; set score
                            cld                             ; clear decimal flag
                            
                            lda #CLZ_ScreenCol_Status_Score ; get score output column
                            sta CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda #CLZ_ScreenRow_Status       ; get status separator row number
                            sta CLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda CL_Score_Hi                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda CL_Digit_1                  ; get digit 1 part - use only right nibble discard left nibble
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Score_MidHi              ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Score_MidLo              ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Score_Lo                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda CL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda CL_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreSplitDigit           Does    : split a byte compressed decimal into two bytes
;                           Expects : .A=BCD coded digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSplitDigit            .block                           ; 
                            sta CL_Digit_10                 ; set store score byte - digit 10 part
                                                              
                            and #$0f                        ; isolate right nibble
                            sta CL_Digit_1                  ; set digit 1 part
                                                              
                            lda CL_Digit_10                 ; get digit 10 part
                            lsr a                           ; isolate left  nibble
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            sta CL_Digit_10                 ; set digit 10 part
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ConvertHexToDec           Does    : set up a three char decimal value from a hex digit
;                           Expects : .A=hex value
;                           Returns : result in CL_Digit_100/CL_Digit_10/CL_Digit_1
; --------------------------------------------------------------------------------------------------------------------- ;
ConvertHexToDec            .block                           ; 
                            ldx #$00                        ; get init value
                            stx CL_Digit_10                 ; ini digit 10 part
                            stx CL_Digit_100                ; ini digit 100 part
                            
Count_100s                  cmp #$64                        ; test 100
                            bcc Count_10s                   ; check: underflow - yes: stop counting 100s
                            
                            inc CL_Digit_100                ; count digit 100 part
                            
                            sbc #$64                        ; sub 100
                            bne Count_100s                  ; always
                            
Count_10s                   cmp #$0a                        ; test 10
                            bcc Count_1s                    ; check: underflow - yes: stop counting 10s
                            
                            inc CL_Digit_10                 ; count digit 10 part
                            
                            sbc #$0a                        ; sub 10
                            bne Count_10s                   ; always
                            
Count_1s                    sta CL_Digit_1                  ; set remaining digit 1 count
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutDigitHandler     Does    : output a digit to the status row of the selected gfx screen
;                                   : the loderunner char values are slightly higher than the PETSCII ones
;                           Expects : .A=decimal value
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutDigitHandler      .block                           ; 
                            clc                             ; 
                            adc #CLZ_ImageNumber_Digit      ; make it a digit image
                            
                            ldx CLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>CL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq OutToScreenPrepare          ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
OutToScreenPrepare          jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ChkCharSubstitution       Does    : prepare a text char for output
;                           Expects : .A=char to check
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCharSubstitution        .block                           ; 
                            sec                             ; 
smChkCharSubstitution       = * + $01                       ; 
                            sbc #$75                        ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharPrepare           Does    : prepare a text char for output
;                           Expects : .A=char to check
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharPrepare            .block                         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check digit characters
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #"0" | $80                  ; test "0"
                            bcc ChkCharValues               ; check: LT - yes
                            
                            cmp #"9" + $01 | $80            ; test "0"
                            bcc ChkCharSubstitution         ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check characters
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCharValues               cmp #"a" | $80                  ; test <SHIFT> + A
                            bcc IniSubstitutionValue        ; check: LT - yes
                            
                            cmp #"z" | $80 + $01            ; test <SHIFT + Z + 1
                            bcc SubSubstitutionValue        ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
IniSubstitutionValue        ldx #$7c                        ; get dislocation value of LR "A" and PETSCII "A"
                            
                            cmp #" " | $80                  ; test <SHIFT_SPACE>
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
; --------------------------------------------------------------------------------------------------------------------- ;
; get start value
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"z" | $80 + $01            ; get substitution start value
                            
                            cmp #">" | $80                  ; test <SHIFT> + ">"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"." | $80                  ; test <SHIFT> + "."
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"(" | $80                  ; test <SHIFT> + "("
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #")" | $80                  ; test <SHIFT> + ")"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"/" | $80                  ; test <SHIFT> + "/"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"-" | $80                  ; test <SHIFT> + "-"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"<" | $80                  ; test <SHIFT> + "<"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
; --------------------------------------------------------------------------------------------------------------------- ;
; replace all undefined characters with a blank - but the value of $10 is wrong (Loderunner image run right 01)
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #$00                        ; get substitution value for all others
                            lda #$10                        ; get substitution value for all others
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSubstitutionValue        txa                             ; set selected substitution value
                            
SubSubstitutionValue        sec                             ; 
                            sbc #$7c                        ; sub dislocation value of LR "A" and PETSCII "A"
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutCharHandler        Does    : control the output of a single char
;                           Expects : .A=output char
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutCharHandler         .block                           ; 
                            cmp #$8d                        ; test <NEWLINE>
                            beq TextCharOutNewLine          ; check: EQ - yes
                            
                            jsr TextCharPrepare             ; prepare and substitute char for output
                            
                            ldx CLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>CL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq CharOutToScreenPrep         ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CharOutToScreenPrep         jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc CLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharOutNewLine        Does    : set text cursor to start of a new line
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharOutNewLine         .block                           ; 
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #CLZ_ScreenCol_Min          ; get initial value
                            sta CLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreCLearOutputArea      Does    : clear the given rows output columns
;                           Expects : .A=row number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreCLearOutputArea       .block                           ; 
                            sta CLZ_ScreenRow               ; set screen row ($00 - $0f)
                            
                            lda #$00                        ; get initial value
                            sta CLZ_ScreenCol               ; ini screen col ($00 - $1b)
                            
                            lda #$1c                        ; get output length
                            sta CL_WorkTextOutputLen        ; set output length
                            
GetNextChar_Shift_Blank     lda #$a0                        ; get <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            dec CL_WorkTextOutputLen        ; dec output length
                            bne GetNextChar_Shift_Blank     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutHandler            Does    : control the output of a $00 terminated text string
;                           Expects : 
;                           Returns : 
;                           Remark  : returns to the statement directly behind the EoT marker $00
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutHandler             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start with the text directly following the subroutine call
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; pull the text start address LO from stack
                            sta CLZ_InputTextOutPtr_Lo      ; set input text pointer LO
                            
                            pla                             ; pull the text start address HI from stack
                            sta CLZ_InputTextOutPtr_Hi      ; set input text pointer HI
                            bne IncTextPointer              ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output the text bytes until EoT
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextTextByte             ldy #$00                        ; get offset
                            lda (CLZ_InputTextOutPtr),y     ; get text byte
                            beq PrepareReturn               ; check: EoT - yes: end of text
                            
                            jsr TextOutCharHandler          ; control the output of a single char
                            
IncTextPointer              inc CLZ_InputTextOutPtr_Lo      ; inc input text pointer LO
                            bne GetNextTextByte             ; check: overflow - no 
                            inc CLZ_InputTextOutPtr_Hi      ; inc input text pointer HI
                            bne GetNextTextByte             ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push actual text pointer as new return address to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
PrepareReturn               lda CLZ_InputTextOutPtr_Hi      ; get input text end pointer HI
                            pha                             ; push the text end address HI to the stack
                            
                            lda CLZ_InputTextOutPtr_Lo      ; get input text end pointer LO
                            pha                             ; push the text end address LO to the stack
                            
                            rts                             ; return behind the input text EoT marker
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameErrorBeep             Does    : output an error beep signal
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameErrorBeep              .block                           ; 
                            sei                             ; disable interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$60                        ; get beep
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set beep output timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$38                        ; get wait time HI
                            ldx #$00                        ; get wait time LO
DecNextBeepTime             dex                             ; dec wait time LO
                            bne DecNextBeepTime             ; check: min - no: continue
                            
                            dey                             ; dec wait time HI
                            bne DecNextBeepTime             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            cli                             ; ensable interrupts
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameWaitBlinkCursor       Does    : blink the cursor while waiting for player input
;                           Expects : .A=character to blink
;                           Returns : .A=player input key
; --------------------------------------------------------------------------------------------------------------------- ;
GameWaitBlinkCursor        .block                           ; 
                            sta CL_DisplayChr               ; save char under cursor
                            
GetNextWaitTimeInitValue    lda #$00                        ; get intitial value
                            sta CL_WaitTime_Lo              ; set wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta CL_WaitTime_Hi              ; set wait timer HI
                            
                            lda #CLZ_ImageNumber_Blank      ; preset clear blank
                            
                            ldx CL_DisplayChr               ; restore char under cursor
                            bne CharImageOutToScreen        ; check: char - yes: bypass substitution
                            
                            lda #CLZ_ImageNumber_Blank_Rev  ; get char substitution reversed blank
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 01 - display blank
; --------------------------------------------------------------------------------------------------------------------- ;
CharImageOutToScreen        jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
ChkNextPlayerAction_Blank   jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec CL_WaitTime_Lo              ; dec wait time LO
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
                            
                            dec CL_WaitTime_Hi              ; dec wait time HI
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 02 - display char under cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_DisplayChr               ; get byte under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #$00                        ; get initial value
                            sta CL_WaitTime_Lo              ; ini wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta CL_WaitTime_Hi              ; ini wait timer HI
                            
ChkNextPlayerAction         jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec CL_WaitTime_Lo              ; dec timer LO
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            dec CL_WaitTime_Hi              ; dec timer HI
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            jmp GetNextWaitTimeInitValue    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SavePlayerInput             pha                             ; save player input key
; --------------------------------------------------------------------------------------------------------------------- ;
; redisplay character under cursor in case of a player input in the blank blink phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_DisplayChr               ; get redisplay chr under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            pla                             ; restore player input key
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerCheckInput          Does    : look for player input
;                           Expects : 
;                           Returns : .C=0 - flag no player action
;                                   : .C=1 - flag player action
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerCheckInput           .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick moves
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #CIAPRA_JOY_MOVE            ; isolate joystick move bits: bit3=right  bit2=left  bit1=down  bit0=up
                            eor #CIAPRA_JOY_MOVE            ; reverse move bits - now 1=pressed
                            bne SetFlagPlayerReacted        ; check: pressed move - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick fire
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            beq SetFlagPlayerReacted        ; check: pressed fire - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_KeyNew                   ; get actual key
                            bne SetFlagPlayerReacted        ; check: new key - yes
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; flag no player action
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerReacted        sec                             ; flag player action
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToDisplay   Does    : set screen display as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToDisplay    .block                           ; 
                            sta CLZ_ImageNumber             ; set image number - level input tile $00-$09/sprite number
                            
                            lda #>CL_ScreenGfxDisplay       ; get adr gfx display screen HI
                            bne ScreenImageOut              ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToPrepare   Does    : set screen prepare as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToPrepare    .block                           ; 
                            sta CLZ_ImageNumber             ; set level input tile $00-$09
                            
                            lda #>CL_ScreenGfxPrepare       ; get adr gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOut            Does    : output an image byte to its correct grafic screen location
;                           Expects : .A=target output screen address HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOut             .block                           ; 
                            sta CLZ_ImageOutputScreen       ; set target output  $20=$2000 $40=$4000
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            sty CLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            stx CLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            lda TabGfxImageClearLeft,x      ; get insert image left tab  (4 different image positions)
                            sta CLZ_GfxImageClearLeft       ; set isolate right grafic part
                            
                            lda TabGfxImageClearRight,x     ; get insert image right tab (4 different image positions)
                            sta CLZ_GfxImageClearRight      ; set isolate left grafic part
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to CLZ_ImageBuffer
                            
                            lda #CL_ImageHeight             ; get height of each image
                            sta CLZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini offset to image buffer byte
                            
                            lda CLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs InsNextImageGfxByteLong     ; check: GE - yes: never true as CLZ_ScreenGfxPartPosY is $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
; insert image byte to its grafic screen location
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByte         ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (CLZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and CLZ_GfxImageClearLeft       ; clear the left gfx part
                            ora CLZ_ImageBufferRowPos_01,x  ; insert new image byte from pos_01
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda (CLZ_ScreenGfxDisplayPtr),y ; get grafic screen image byte
                            and CLZ_GfxImageClearRight      ; clear the right grafic part
                            ora CLZ_ImageBufferRowPos_01,x  ; insert image buffer byte part 01
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set write grafic screen image byte
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - always empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte of image buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByte         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as CLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByteLong     ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (CLZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and CLZ_GfxImageClearLeft       ; clear the left gfx part
                            ora CLZ_ImageBuffer,x           ; insert new image byte from pos_01
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - middle part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda CLZ_ImageBuffer,x           ; get image buffer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set middle part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $03 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc offset to offset image byte pos_03
                            
                            ldy #$10                        ; get offset image right part
                            lda (CLZ_ScreenGfxDisplayPtr),y ; get right part of gfx image
                            and CLZ_GfxImageClearRight      ; clear the right image part
                            ora CLZ_ImageBuffer,x           ; insert new image byte from pos_03
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set right part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByteLong     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearLeft        = *       ; 
                            .byte $00 ; ........
                            .byte $c0 ; ##......
                            .byte $f0 ; ####....
                            .byte $fc ; ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearRight       = *       ; 
                            .byte $3f ; ..######
                            .byte $0f ; ....####
                            .byte $03 ; ......##
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageUpdate         Does    : process steps for shoot and close holes
;                                   : clear collected gold
;                           Expects : .A=image number
;                                   : .Y=image screen offset PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageUpdate          .block                           ; 
                            sty CLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta CLZ_ImageNumber             ; set level input tile $00-$09
                            
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta CLZ_WorkSpritePosX          ; 
                            stx CLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to CLZ_ImageBuffer
                            
                            ldx #CL_ImageHeight             ; get image height
                            stx CLZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini image buffer offset
                            
                            lda CLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs UpdNextImageGfxByteLong     ; check: GE - yes: never true as CLZ_ScreenGfxPartPosY is $00-$03
                            
GetNextGfxRowOffset         ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (CLZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (CLZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image right part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (CLZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (CLZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as CLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
UpdNextImageGfxByteLong     ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (CLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (CLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$10                        ; get offset image right part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (CLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne UpdNextImageGfxByteLong     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutSpecial     Does    : show loderunner and enemy sprites
;                                   : show images for hidden ladders/shoot sparks/gold/enemy rebirth steps
;                           Expects : .A=image number
;                                   ; .Y=grafic screen column pos on row
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutSpecial      .block                           ; 
                            sty CLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta CLZ_ImageNumber             ; set level input tile $00-$09
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta CLZ_WorkSpritePosX          ; 
                            stx CLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of 4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to CLZ_ImageBuffer
                            
                            lda #CL_ImageHeight             ; get image height
                            sta CLZ_ImageHeight             ; ini image height
                            
                            ldx #$00                        ; get initial value
                            stx CLZ_LodeRuEnemyCollision    ; ini loderunner-enemy sprite collision  $01=lr caught
                            
                            lda CLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs InsNextImageGfxByteLongSprt ; check: GE - yes: never true as CLZ_ScreenGfxPartPosY is $00-$03
                            
GetNextGfxRowOffset         ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            ora (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            ora (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as CLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByteLongSprt ldy CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            ora (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            ora (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$10                        ; get offset image right part
                            lda CLZ_ImageBuffer,x           ; get image byte
                            ora (CLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc CLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec CLZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByteLongSprt ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageGetBytes       Does    : get the appropriate image byte from tabled data
;                           Expects : .X=values $00-$03 for the 4 different image types
;                           Returns : 
;                           Remark  : image data access
;                                   : ini pointer CLZ_ImageDataOffPtr to TabImageDataOff to start
;                                   : get the image data start address according to image pos-X
;                                   : do image height times
;                                   :   get the image number
;                                   :   get offset to image data with CLZ_ImageDataOffPtr and the image number as an offset
;                                   :   get image row byte 1 - from $a000/$a200/$a400/$a600 - at TabImageDataOff_Len
;                                   :   get image row byte 2 - from $a100/$a300/$a500/$a700 - at TabImageDataOff_Len       - part 1 - combined with part 2
;                                   :                        - from $a000/$a200/$a400/$a600 - at TabImageDataOff_Len * $02 - part 2
;                                   :   get image row byte 3 - from $a100/$a300/$a500/$a700 - at TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageGetBytes        .block                           ; 
                            lda #CLZ_ImageHeight_Max        ; get image 11 rows with 3 bytes each
                            sta CLZ_ImageHeight             ; ini image row count
                            
                            lda #$00                        ; get initial value
                            sta CLZ_ImageDataOffPtr_Lo      ; ini image data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; image data tab pointer will be destroyed in case of a bad checksum
; --------------------------------------------------------------------------------------------------------------------- ;
smTileDataPtr               = * + $01                       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init self modified data image pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>TabImageDataOff           ; get adr image data row pointer
                            sta CLZ_ImageDataOffPtr_Hi      ; ini image pointer HI to TabImageDataOff
; --------------------------------------------------------------------------------------------------------------------- ;
; four different images
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabImageDataAdr_Hi,x        ; get four different image pos tab HI
                            sty smGetImageDataByte_01       ; ini $00=$a000 $01=$a200 $02=$a400 $03=$a600
                            sty smGetImageDataByte_02_P_02  ; ini $00=$a000 $01=$a200 $02=$a400 $03=$a600
                            
                            iny                             ; inc image pos tab HI
                            sty smGetImageDataByte_02_P_01  ; ini $00=$a100 $01=$a300 $02=$a500 $03=$a700
                            sty smGetImageDataByte_03       ; ini $00=$a100 $01=$a300 $02=$a500 $03=$a700
                            
                            ldx #$00                        ; ini zero page image buffer storage offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $01 from $a000/$a200/$a400/$a600
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextImageDataByteOff     ldy CLZ_ImageNumber             ; get image number as offset
                            lda (CLZ_ImageDataOffPtr),y     ; get the offset to the image data bytes
                            tay                             ; set as data offset
                            
smGetImageDataByte_01       = * + $02                       ; 
                            lda TabImageData,y              ; get 1st image byte from $a000/$a200/$a400/$a600 -  (1*off_len)
                            sta CLZ_ImageBuffer,x           ; set it to 1st buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $02 - from $a100/$a300/$a500/$a700 - part 01
; --------------------------------------------------------------------------------------------------------------------- ;
smGetImageDataByte_02_P_01  = * + $02                       ; 
                            lda TabImageData,y              ; get 2nd image byte from $a100/$a300/$a500/$a700 - 1st part (1*off_len) 
                            sta CLZ_ImageBufferRowPos_02,x  ; set it to 2nd position
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image data pointer - point to the next image data byte offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_ImageDataOffPtr_Lo      ; get image data pointer LO
                            clc                             ; 
                            adc #TabImageDataOff_Len        ; add max number of offsets
                            sta CLZ_ImageDataOffPtr_Lo      ; set image data pointer LO
                            
                            lda CLZ_ImageDataOffPtr_Hi      ; get image data pointer HI
                            adc #$00                        ; add .C
                            sta CLZ_ImageDataOffPtr_Hi      ; set image data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $02 - from $a000/$a200/$a400/$a600 - part 02 - combine with part 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ImageNumber             ; get image number
                            lda (CLZ_ImageDataOffPtr),y     ; get offset to the image data bytes
                            tay                             ; set offset to the image data bytes
                            
smGetImageDataByte_02_P_02  = * + $02                       ; 
                            lda TabImageData,y              ; get 2nd image byte from $a000/$a200/$a400/$a600 - 2nd part (2*off_len)
                            ora CLZ_ImageBufferRowPos_02,x  ; insert image buffer byte part 02
                            sta CLZ_ImageBufferRowPos_02,x  ; set it to 2nd buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $03 - from $a100/$a300/$a500/$a700
; --------------------------------------------------------------------------------------------------------------------- ;
smGetImageDataByte_03       = * + $02                       ; 
                            lda TabImageData,y              ; get 3rd image byte from $a100/$a300/$a500/$a700 -  (2*off_len)
                            sta CLZ_ImageBufferRowPos_03,x  ; set it to 3rd buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image data pointer - point to the next image data byte offset - prepare for next round
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_ImageDataOffPtr_Lo      ; get image data pointer LO
                            clc                             ; 
                            adc #TabImageDataOff_Len        ; add max number of images
                            sta CLZ_ImageDataOffPtr_Lo      ; set image data pointer LO
                            
                            lda CLZ_ImageDataOffPtr_Hi      ; get image data pointe HI
                            adc #$00                        ; add .C
                            sta CLZ_ImageDataOffPtr_Hi      ; set image data pointe HI
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image byte output buffer offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc zero page image buffer storage offset to next row
                            inx                             ; 
                            inx                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; dec imaage height and check end of copy
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CLZ_ImageHeight             ; image row count
                            bne GetNextImageDataByteOff     ; check: min - no: fill next zero page image buffer storage row
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataAdr_Hi          = *                               ; hi address of the 4 different image position types
                            .byte >TabImageDataPos_01_Part_01 ; $00 - from $A000
                            .byte >TabImageDataPos_02_Part_01 ; $01 - from $A200
                            .byte >TabImageDataPos_03_Part_01 ; $02 - from $A400
                            .byte >TabImageDataPos_04_Part_01 ; $03 - from $A600
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDisplayHandler      Does    : eventually display sprites and get loderunner sprite/sprite collision value
;                           Expects : .X=screen image column offset
;                           Returns : 
;                           Remark  : does not return to caller if a sprite was set up
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandler       .block                           ; 
                            lda CL_SpriteShow               ; get control sprite show - $05=no sprite display in edit mode
                            bne SpriteDisplayHandlerX       ; check: CL_SpriteShow_Off - yes: no sprite display - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the images sprite number replacement value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_ImageNumber             ; get image number
                            cmp #CLZ_ImageNumber_Hole_Close + $02 ; test max image number
                            bcs SpriteDisplayHandlerX       ; check: GE - yes: no display - exit
                            
                            tay                             ; set image number as offset
                            lda TabImageToSpriteNumValue,y  ; get image is sprite flag
                            bmi SpriteDisplayHandlerX       ; check: flag no sprite - yes: no display - exit
                            beq SetSpriteColOff             ; check: flag loderunner - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return to caller from here
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CLZ_ImageNumber             ; set enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteColOff             stx CLZ_WorkSpritePosX          ; save grafic row column offset from ScreenGetGfxPosXY
                            jsr SpriteDataBufferFill        ; fill the appropriate sprite buffer with sprite image data
; --------------------------------------------------------------------------------------------------------------------- ;
; .X=VIC sprite SPnX register offset
; --------------------------------------------------------------------------------------------------------------------- ;
; calc sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CLZ_WorkSpritePosX          ; restore grafic PosX from ScreenGetGfxPosXY
                            clc                             ; 
                            adc #VICSCN_MINX_40 / $02       ; add half of screen border height
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta SP0X,x                      ; set VIC($D000) Sprite 0 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            bcc SpriteClearMSB              ; check: MSB PosX to be set - no: clear PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprite_MSB_Set,x         ; get sprite set x pos msb tab
                            ora MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            
                            jmp SetSpritePosY               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteClearMSB              lda TabSprite_MSB_Clear,x       ; get sprite clear x pos msb tab
                            and MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpritePosY               lda CLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            clc                             ; 
                            adc #VICSCN_MINY_25 - $01       ; add screen border width
                            sta SP0Y,x                      ; VIC($D001) Sprite 0 Y-Pos (Bits 0-7)
; --------------------------------------------------------------------------------------------------------------------- ;
; get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPSPCL                      ; VIC($D01E) Sprite-Sprite Collision - Cleared on read
                            and #SPSPCL_M0M                 ; .......# - isolate bit 0
                            sta CLZ_LodeRuEnemyCollision    ; set loderunner-enemy sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; do not return to caller
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; discard the return address
                            pla                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit point for no sprite display
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandlerX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprite_MSB_Set           = * + $00 ; 
TabSprite_MSB_Clear         = * + $01 ; 
                            .byte %00000001 ; set   - sprite x pos msb tab
                            .byte %11111110 ; clear - sprite x pos msb tab
                            
                            .byte %00000010 ; set   - sprite x pos msb tab
                            .byte %11111101 ; clear - sprite x pos msb tab
                                  
                            .byte %00000100 ; set   - sprite x pos msb tab
                            .byte %11111011 ; clear - sprite x pos msb tab
                                  
                            .byte %00001000 ; set   - sprite x pos msb tab
                            .byte %11110111 ; clear - sprite x pos msb tab
                                  
                            .byte %00010000 ; set   - sprite x pos msb tab
                            .byte %11101111 ; clear - sprite x pos msb tab
                                  
                            .byte %00100000 ; set   - sprite x pos msb tab
                            .byte %11011111 ; clear - sprite x pos msb tab
                                  
                            .byte %01000000 ; set   - sprite x pos msb tab
                            .byte %10111111 ; clear - sprite x pos msb tab
                                  
                            .byte %10000000 ; set   - sprite x pos msb tab
                            .byte %01111111 ; clear - sprite x pos msb tab
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageToSpriteNumValue    = *       ; 
                            .byte $ff ; $00 - Level Tile Blank         - no sprite
                            .byte $ff ; $01 - Level Tile Wall Weak     - no sprite
                            .byte $ff ; $02 - Level Tile Wall Hard     - no sprite
                            .byte $ff ; $03 - Level Tile Ladder        - no sprite
                            .byte $ff ; $04 - Level Tile Pole          - no sprite
                            .byte $ff ; $05 - Level Tile Wall Trap     - no sprite
                            .byte $ff ; $06 - Level Tile Ladder Secret - no sprite
                            .byte $ff ; $07 - Level Tile Gold          - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $0b ; $08 - Level Tile Enemy      - Run Le  00
                            .byte $00 ; $09 - Level Tile Loderunner - Run Ri  00
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $0a - Blank Reverse             - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $0b - Loderunner Run  Le 00    
                            .byte $00 ; $0c - Loderunner Run  Le 01    
                            .byte $00 ; $0d - Loderunner Run  Le 02    
                            .byte $00 ; $0e - Loderunner Ladder  00    
                            .byte $00 ; $0f - Loderunner Fire Le    
                            .byte $00 ; $10 - Loderunner Run  Ri 01
                            .byte $00 ; $11 - Loderunner Run  Ri 02
                            .byte $00 ; $12 - Loderunner Ladder  01
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $1b - Shoot Spark Le    00 - no sprite
                            .byte $ff ; $1c - Shoot Spark Le    01 - no sprite
                            .byte $ff ; $1d - Shoot Spark Le/Ri 02 - no sprite
                            .byte $ff ; $1e - Shoot Spark Le/Ri 03 - no sprite
                            .byte $ff ; $1f - Shoot Melt Ground 00 - no sprite
                            .byte $ff ; $20 - Shoot Melt Ground 01 - no sprite
                            .byte $ff ; $21 - Shoot Melt Ground 02 - no sprite
                            .byte $ff ; $22 - Shoot Melt Ground 03 - no sprite
                            .byte $ff ; $23 - Shoot Melt Ground 04 - no sprite
                            .byte $ff ; $24 - Shoot Melt Ground 05 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $25 - Loderunner Fire Ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $26 - Shoot Spark Ri    00 - no sprite lr fire Ri
                            .byte $ff ; $27 - Shoot Spark Ri    01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $09 ; $28 - Enemy Run  Ri 00
                            .byte $10 ; $29 - Enemy Run  Ri 01
                            .byte $11 ; $2a - Enemy Run  Ri 02
                            .byte $0c ; $2b - Enemy Run  Le 01
                            .byte $0d ; $2c - Enemy Run  Le 02
                            .byte $15 ; $2d - Enemy Pole Ri 00
                            .byte $16 ; $2e - Enemy Pole Ri 01
                            .byte $17 ; $2f - Enemy Pole Ri 02
                            .byte $18 ; $30 - Enemy Pole Le 00
                            .byte $19 ; $31 - Enemy Pole Le 01
                            .byte $1a ; $32 - Enemy Pole Le 02
                            .byte $0e ; $33 - Enemy Ladder  00
                            .byte $12 ; $34 - Enemy Ladder  01
                            .byte $14 ; $35 - Enemy Fall Ri
                            .byte $13 ; $36 - Enemy Fall Le
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $37 - Close Hole Phase  00 - no sprite
                            .byte $ff ; $38 - Close Hole Phase  01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDataBufferFill      Does    : fill the appropriate sprite buffer with sprite image data
;                           Expects : .A=image number
;                           Returns : .X=VIC sprite SPnX register offset for sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDataBufferFill       .block                           ; 
                            pha                             ; save image id
                            
                            lda CLZ_WorkSpritePosX          ; get grafic xr offset from ScreenGetGfxPosXY
                            and #%00000011                  ; isolate bit 0-1 for the 4 different image types
                            tax                             ; set values $00-$03 for the 4 different image types
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to CLZ_ImageBuffer
                            
                            pla                             ; restore image id
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner always has number sprite number $00
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq SetSpriteBufferTabIndex     ; check: loderunner - yes: bypass get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
; get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CL_EnemyToMoveNum           ; get number of enemy to move - up to $05 enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite number as sprite tables index
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteBufferTabIndex     tax                             ; set as sprite buffer table index
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite data buffer pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteBuffer_Lo,x        ; get sprite data pos LO tab
                            sta smSpriteDataBuffer_Lo       ; set modify store address LO
                            
                            lda TabSpriteBuffer_Hi,x        ; get sprite data pos HI tab
                            sta smSpriteDataBuffer_Hi       ; set modify store address HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteNumber,x           ; get sprite number
                            tax                             ; save sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; copy sprite data to its data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CL_ImageHeight * $03 - $01 ; get $03 bytes per row image height times
GetNextSpiteDataBufferByte  lda CLZ_ImageBuffer,y           ; get all 33 image bytes from image buffer
smSpriteDataBuffer_Lo       = * + $01                       ; 
smSpriteDataBuffer_Hi       = * + $02                       ; 
SetSpiteDataBufferByte      sta SetSpiteDataBufferByte,y    ; set image byte to correct sprite data storage  ($0c00-$0dff)
                            
                            dey                             ; dec image byte count
                            bpl GetNextSpiteDataBufferByte  ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; calc offset VIC sprite 0-7 PosX registers
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; restore sprite number
                            asl a                           ; *2 - gives VIC sprite SPnX offset
                            tax                             ; set sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Lo           = *                    ; 
                            .byte <CL_SpriteData_00 ; $00
                            .byte <CL_SpriteData_01 ; $40 
                            .byte <CL_SpriteData_02 ; $80 
                            .byte <CL_SpriteData_03 ; $c0 
                            .byte <CL_SpriteData_04 ; $00 
                            .byte <CL_SpriteData_05 ; $40 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Hi          = *                     ; 
                            .byte >CL_SpriteData_00 ; $0c
                            .byte >CL_SpriteData_01 ; $0c
                            .byte >CL_SpriteData_02 ; $0c
                            .byte >CL_SpriteData_03 ; $0c
                            .byte >CL_SpriteData_04 ; $0d
                            .byte >CL_SpriteData_05 ; $0d
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteNumber             = *       ; 
                            .byte $00 ; loderunner
                            
                            .byte $02 ; enemy $01
                            .byte $03 ; enemy $02
                            .byte $04 ; enemy $03
                            
                            .byte $06 ; enemy $04
                            .byte $07 ; enemy $05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenGetGfxPosXY         Does    : get screen image offset in gfx screen
;                           Expects : .X=col number
;                                   : .Y=row number
;                           Returns : .X=screen image row column offset
;                                   : .Y=screen image row offset
;                           Remark  : game screen size is 40*25
;                                   : CL_ImageWidth will be expanded in ScreenRowByteColNumber and SpriteDisplayHandler
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenGetGfxPosXY          .block                           ; 
                            lda TabScreenRowOff,y           ; get screen image row offset
                            pha                             ; save screen image row offset
                            
                            lda TabScreenColOff,x           ; get screen image row column offset
                            tax                             ; set screen image row column offset
                            
                            pla                             ; restore screen image row offset
                            tay                             ; set screen image row offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenRowOff             = * ; $0b rows per image - screen size is 25*40
                            .byte CL_ImageHeight * $00       ; 01 - $01 - $00
                            .byte CL_ImageHeight * $01       ; 02 - $02 - $0b
                            .byte CL_ImageHeight * $02       ; 03 - $03 - $16
                            .byte CL_ImageHeight * $03       ; 04 - $04 - $21
                            .byte CL_ImageHeight * $04       ; 05 - $05 - $2c
                            .byte CL_ImageHeight * $05       ; 06 - $06 - $37
                            .byte CL_ImageHeight * $06       ; 07 - $07 - $42
                            .byte CL_ImageHeight * $07       ; 08 - $08 - $4d
                            .byte CL_ImageHeight * $08       ; 09 - $09 - $58
                            .byte CL_ImageHeight * $09       ; 00 - $0a - $63
                            .byte CL_ImageHeight * $0a       ; 11 - $0b - $6e
                            .byte CL_ImageHeight * $0b       ; 12 - $0c - $79
                            .byte CL_ImageHeight * $0c       ; 13 - $0d - $84
                            .byte CL_ImageHeight * $0d       ; 14 - $0e - $8f
                            .byte CL_ImageHeight * $0e       ; 15 - $0f - $9a
                            .byte CL_ImageHeight * $0f       ; 16 - $10 - $a5
                            .byte CL_ImageHeight * $10 + $05 ; 17 - $11 - $b5 - status row starts beyond separator line
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenColOff             = * ; $1c columns per row - force column offset to one byte
                            .byte CL_ImageWidth * $02 / $02  ; 01 - $01 - $0a - 1st two screen columns unused
                            .byte CL_ImageWidth * $03 / $02  ; 02 - $02 - $0f
                            .byte CL_ImageWidth * $04 / $02  ; 03 - $03 - $14
                            .byte CL_ImageWidth * $05 / $02  ; 04 - $04 - $19
                            .byte CL_ImageWidth * $06 / $02  ; 05 - $05 - $1e
                            .byte CL_ImageWidth * $07 / $02  ; 06 - $06 - $23
                            .byte CL_ImageWidth * $08 / $02  ; 07 - $07 - $28
                            .byte CL_ImageWidth * $09 / $02  ; 08 - $08 - $2d
                            .byte CL_ImageWidth * $0a / $02  ; 09 - $09 - $32
                            .byte CL_ImageWidth * $0b / $02  ; 10 - $0a - $37
                            .byte CL_ImageWidth * $0c / $02  ; 11 - $0b - $3c
                            .byte CL_ImageWidth * $0d / $02  ; 12 - $0c - $41
                            .byte CL_ImageWidth * $0e / $02  ; 13 - $0d - $46
                            .byte CL_ImageWidth * $0f / $02  ; 14 - $0e - $4b
                            .byte CL_ImageWidth * $10 / $02  ; 15 - $0f - $50
                            .byte CL_ImageWidth * $11 / $02  ; 16 - $10 - $55
                            .byte CL_ImageWidth * $12 / $02  ; 17 - $11 - $5a
                            .byte CL_ImageWidth * $13 / $02  ; 18 - $12 - $5f
                            .byte CL_ImageWidth * $14 / $02  ; 19 - $13 - $64
                            .byte CL_ImageWidth * $15 / $02  ; 20 - $14 - $69
                            .byte CL_ImageWidth * $16 / $02  ; 21 - $15 - $6e
                            .byte CL_ImageWidth * $17 / $02  ; 22 - $16 - $73
                            .byte CL_ImageWidth * $18 / $02  ; 23 - $17 - $78
                            .byte CL_ImageWidth * $19 / $02  ; 24 - $18 - $7d
                            .byte CL_ImageWidth * $1a / $02  ; 25 - $19 - $82
                            .byte CL_ImageWidth * $1b / $02  ; 26 - $1a - $87
                            .byte CL_ImageWidth * $1c / $02  ; 27 - $1b - $8c
                            .byte CL_ImageWidth * $1d / $02  ; 28 - $1c - $91 - last two screen columns unused
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosX   Does    : add horizontal gfx screen image offset
;                           Expects : .X=col number
;                                   : .Y=on image posX number
;                           Returns : .X=vertical position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosX    .block                           ; 
                            tya                             ; get on image posX number
                            pha                             ; save on image posX number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; restore on image posX number
                            tay                             ; set on image posX number
                            
                            txa                             ; get image column offset
                            clc                             ; 
                            adc TabOnGfxImagePosX,y         ; add on image offset value
                            tax                             ; set image column offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosX           = *       ; 
                            .byte $fe ; -2
                            .byte $ff ; -1
                            .byte $00 ;  0
                            .byte $01 ; +1
                            .byte $02 ; +2
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosY   Does    : add vertical gfx screen image offset
;                           Expects : .Y=row number
;                                   : .X=on image posY number
;                           Returns : .Y=horizontal position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosY    .block                           ; 
                            txa                             ; get on image posY number
                            pha                             ; save on image posY number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; 
                            tax                             ; restore on image posY number
                            
                            tya                             ; get image row offset
                            clc                             ; 
                            adc TabOnGfxImagePosY,x         ; add on image offset value
                            tay                             ; set horizontal position on image
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosY           = *       ; 
                            .byte $fb ; -4
                            .byte $fd ; -2
                            .byte $00 ;  0 - center
                            .byte $02 ; +2
                            .byte $04 ; +4
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; S_91d7                    Does    : get table values - unused subroutine
;                           Expects : .X=table offset
;                           Returns : .A=TabNoUse_LO table value
;                                   : .X=TabNoUse_HI table value
; --------------------------------------------------------------------------------------------------------------------- ;
S_91d7                     .block                           ; 
                            lda TabNoUse_LO,x               ; get TabNoUse_LO value
                            pha                             ; save TabNoUse_LO value
                            
                            lda TabNoUse_HI,x               ; get TabNoUse_HI value
                            tax                             ; set TabNoUse_HI value
                            
                            pla                             ; set TabNoUse_LO value
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabNoUse_LO                 = *       ; 
                            .byte $02 ; $00
                            .byte $03 ; $01
                            
                            .byte $05 ; $02
                            .byte $06 ; $03
                            .byte $07 ; $04
                            .byte $08 ; $05
                            
                            .byte $0a ; $06
                            .byte $0b ; $07
                            .byte $0c ; $08
                            .byte $0d ; $09
                            
                            .byte $0f ; $0a
                            .byte $10 ; $0b
                            .byte $11 ; $0c
                            .byte $12 ; $0d
                            
                            .byte $14 ; $0e
                            .byte $15 ; $0f
                            .byte $16 ; $10
                            .byte $17 ; $11
                            
                            .byte $19 ; $12
                            .byte $1a ; $13
                            .byte $1b ; $14
                            .byte $1c ; $15
                            
                            .byte $1e ; $16
                            .byte $1f ; $17
                            .byte $20 ; $18
                            .byte $21 ; $19
                            
                            .byte $23 ; $1a
                            .byte $24 ; $1b
                            .byte $25 ; $1c
                            .byte $26 ; $1d
; --------------------------------------------------------------------------------------------------------------------- ;
TabNoUse_HI                 = *       ; 
                            .byte $02 ; $00
                            .byte $03 ; $01
                            
                            .byte $00 ; $02
                            .byte $01 ; $03
                            .byte $02 ; $04
                            .byte $03 ; $05
                            
                            .byte $00 ; $06
                            .byte $01 ; $07
                            .byte $02 ; $08
                            .byte $03 ; $09
                            
                            .byte $00 ; $0a
                            .byte $01 ; $0b
                            .byte $02 ; $0c
                            .byte $03 ; $0d
                            
                            .byte $00 ; $0e
                            .byte $01 ; $0f
                            .byte $02 ; $10
                            .byte $03 ; $11
                            
                            .byte $00 ; $12
                            .byte $01 ; $13
                            .byte $02 ; $14
                            .byte $03 ; $15
                            
                            .byte $00 ; $16
                            .byte $01 ; $17
                            .byte $02 ; $18
                            .byte $03 ; $19
                            
                            .byte $00 ; $1a
                            .byte $01 ; $1b
                            .byte $02 ; $1c
                            .byte $03 ; $1d
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenRowByteColNumber    Does    : calculate hires row column byte number
;                           Expects : .X=screen image col offset
;                           Returns : .A=number of bytes to be bypassed
;                                   : .X=rest of (screen image col offset) MOD 4
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenRowByteColNumber     .block                           ; 
                            lda #$00                        ; get initial value
                            sta CL_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                            
                            txa                             ; get screen image col offset
                            pha                             ; save screen image col offset
                            
                            and #$03                        ; ......## - .X MOD 4
                            tax                             ; set the rest of division by 4
                            
                            pla                             ; restore screen image col offset
                            
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            rol CL_HiresRowColNumAdd_Hi     ; screen start of row column number HI
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta CL_HiresRowColNumAdd_Lo     ; set screen start of row column number LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetLevelDataPtrsToRow Does    : set level data pointers to start of selected row
;                           Expects : .Y=row number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetLevelDataPtrsToRow  .block                           ; 
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ScreenSetRowPointerStart  Does    : set grafic screen pointer to row start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointerStart   .block                           ; 
                            lda #$00                        ; get initial value
                            sta CL_HiresRowColNumAdd_Lo     ; ini screen start of row column number LO
                            sta CL_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetRowPointer       Does    : set grafic screen pointer to the output rows column
;                           Expects : .Y=screen grafic row PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointer        .block                           ; 
                            lda CL_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc CL_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta CLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            lda CL_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc CL_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora CLZ_ImageOutputScreen       ; graphic output  (20=2000-2fff  40=4000-4fff)
                            sta CLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CircleCalcHiresColByteOff Does    : calculate hires screen column byte offset from column number
;                           Expects : .X=column number
;                           Returns : 
;                           Remark  : Old Lode Runner remant - never called of course
; --------------------------------------------------------------------------------------------------------------------- ;
CircleCalcHiresColByteOff  .block                           ; 
                            lda #$00                        ; get 
                            sta CL_HiresRowColNumAdd_Hi     ; set screen start of row column number HI
                            
                            txa                             ; 
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8
                            rol CL_HiresRowColNumAdd_Hi     ; screen start of row column number HI
                            sta CL_HiresRowColNumAdd_Lo     ; set screen start of row column number LO
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetGfxPtrBoth       Does    : set grafic pointers for display an prepare screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetGfxPtrBoth        .block                           ; 
                            lda CL_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc CL_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta CLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            sta CLZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            
                            lda CL_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc CL_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora #>CL_ScreenGfxDisplay       ; ..#..... - point to $2000-$3fff  (display screen)
                            sta CLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            eor #>(CL_ScreenGfxPrepare + CL_ScreenGfxDisplay) ; .##..... - point to $4000-$5fff  (prepare screen)
                            sta CLZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenDisplayClear        Does    : clear grafic display screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenDisplayClear         .block                           ; 
                            lda #>CL_ScreenGfxDisplay       ; get start hires gfx display screen HI ($2000-$3fff)
                            ldx #SPENA_ALL_OFF              ; get disable all sprites
                            stx SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldx #>CL_ScreenGfxDisplayEnd + $01 ; get end hires gfx display screen HI
                            bne ScreenClearSelected         ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenPrepareClear        Does    : clear grafic prepare screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenPrepareClear         .block                           ; 
                            lda #>CL_ScreenGfxPrepare       ; get start hires gfx prepare screen HI ($4000-$5fff)
                            ldx #>CL_ScreenGfxPrepareEnd + $01 ; get end hires gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenClearSelected       Does    : clear selected grafic screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenClearSelected        .block                           ; 
                            sta CLZ_ScreenGfxPtr_Hi         ; set screen grafic HI pointer
                            
                            ldy #$00                        ; get initial value
                            sty CLZ_ScreenGfxPtr_Lo         ; set screen grafic LO pointer
                            
                            tya                             ; get blank
ClrNextGraficScreenByte     sta (CLZ_ScreenGfxPtr),y        ; set screen grafic pointer byte
                            
                            iny                             ; inc byte offset
                            bne ClrNextGraficScreenByte     ; check: min - no: continue
                            
                            inc CLZ_ScreenGfxPtr_Hi         ; set next page
                            
                            cpx CLZ_ScreenGfxPtr_Hi         ; test upper border
                            bne ClrNextGraficScreenByte     ; check: EQ - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelDataRow_Lo          = * ; offset start of game/ctrl level data rows LO
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte <CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameLevelDataRow_Hi      = * ; offset start of game level data rows pointer $0800-$09c3
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte >CL_LevelGameData + ((CL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabCtrlLevelDataRow_Hi      = * ; offset start of ctrl level data rows pointer  $0a00-$0bc3
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $00)       ; $00 - $0a00
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $01)       ; $01 - $0a1c
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $02)       ; $02 - $0a38
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $03)       ; $03 - $0a54
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $04)       ; $04 - $0a70
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $05)       ; $05 - $0a8c
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $06)       ; $06 - $0aa8
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $07)       ; $07 - $0ac4
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $08)       ; $08 - $0ae0
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0b00
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $0b1c
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0b38
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0b54
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0b70
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $0b8c
                            .byte >CL_LevelCtrlData + ((CL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $0ba8
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelExitLadderShow       Does    : show the hidden exit ladders
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelExitLadderShow        .block                           ; 
                            lda #CL_WA_ExitLadderMark_Free  ; get initial value
                            sta CL_WA_ExitLadderMark        ; ini no gold replaced by hidden ladder 
                            
                            ldx CL_ExitLadderCount          ; get number of hidden ladders
                            stx TabWorkExitLadderCount      ; set count of hidden ladders to display
                            
GetNextExitLadderCount      ldx TabWorkExitLadderCount      ; get count hidden ladders to display
                            beq LevelExitLadderShowFinish   ; check: min - yes: finished
                            
                            lda CL_WA_ExitLadderCol,x       ; get adr column hidden ladder tab
                            bmi DecExitLadderCount          ; check: already cleared - yes: try next hidden ladder
                            
                            sta CLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda CL_WA_ExitLadderRow,x       ; get adr row hidden ladders tab
                            sta CLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointer to hidden ladder row
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get row as index
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta CLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta CLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta CLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta CLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get tile on planned hidden ladder position in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (CLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
                            bne MarkDroppedGold             ; check: empty - no: can only be dropped gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set hidden ladder tile to level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Ladder          ; get ladder
                            sta (CLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; get tile on planned hidden ladder position in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            bne UncoverHiddenLadder         ; check: empty - no
; --------------------------------------------------------------------------------------------------------------------- ;
; set hidden ladder tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CL_TileNum_Ladder          ; get ladder
                            sta (CLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; output ladder tile to grafic screen
; --------------------------------------------------------------------------------------------------------------------- ;
UncoverHiddenLadder         lda #CL_TileNum_Ladder          ; get ladder
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx CLZ_ScreenCol               ; get screen col ($00-$1b)
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #CL_TileNum_Ladder          ; get ladder
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; mark hidden ladder WA position as free
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWorkExitLadderCount      ; get count hidden ladders as offset
                            lda #CL_WA_ExitLadder_Free      ; get entry freed marker
                            sta CL_WA_ExitLadderCol,x       ; set clear adr column hidden ladder tab
                            bmi DecExitLadderCount          ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; flag a gold bar was dropped on a hidden ladder position
; --------------------------------------------------------------------------------------------------------------------- ;
MarkDroppedGold             lda #CL_WA_ExitLadderMark_Gold  ; get not empty marker
                            sta CL_WA_ExitLadderMark        ; set flag hidden ladder replaced dropped gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set next iteration
; --------------------------------------------------------------------------------------------------------------------- ;
DecExitLadderCount          dec TabWorkExitLadderCount      ; dec number of hidden ladders
                            jmp GetNextExitLadderCount      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check dropped gold marker
; --------------------------------------------------------------------------------------------------------------------- ;
LevelExitLadderShowFinish   lda CL_WA_ExitLadderMark        ; get flag hidden ladder replaced dropped gold
                            bne LevelExitLadderShowX        ; check: dropped gold - no: not set
                            
                            dec CL_GoldToCollect            ; some gold was lost - dec gold to collect
                            
LevelExitLadderShowX        rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWorkExitLadderCount      .byte $00                       ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GetNewKey                 Does    : wait for a input key set in IRQ
;                           Expects : 
;                           Returns : .A=key got
; --------------------------------------------------------------------------------------------------------------------- ;
GetNewKey                  .block                           ; 
WaitForNewKey               lda CL_KeyNew                   ; get a new key
                            beq WaitForNewKey               ; check: new gey got - no: continue waiting
                            
                            ldx #CL_KeyNew_None             ; get initial value
                            stx CL_KeyNew                   ; ini new key input
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CopyProtection            Does    : read in check bytes from the original disk in drive
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtection             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild_Start         =   *                           ; start: checksum build byte block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$02                        ; get channel number
                            ldx #FA_DISK                    ; get disk number (8)
                            ldy #$02                        ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00); Kernal($FFBA) Set logical file parameters ($FE00)
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild_End           = * - $01                       ; end: checksum build byte block
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #<TabDiskCmdProtFileName    ; get address filename LO
                            ldy #>TabDiskCmdProtFileName    ; get address filename HI
                            lda #TabDiskCmdProtFileName_Len ; get filename length
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9); Kernal($FFBD) Set filename parameters ($FDF9)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A); Kernal($FFC0) Open a logical file (via $31A to $F34A)
; --------------------------------------------------------------------------------------------------------------------- ;
; send B-E command
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get channel number
                            ldx #FA_DISK                    ; get disk number (8)
                            ldy #SA_CHANNEL_CMD             ; get secondary address - cmd channel
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00); Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            ldx #<TabDiskCmdProt_BE         ; get address B-E command LO
                            ldy #>TabDiskCmdProt_BE         ; get address B-E command HI
                            lda #TabDiskCmdProt_BE_Len      ; get B-E command length
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9); Kernal($FFBD) Set filename parameters ($FDF9)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A); Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            
                            lda #$01                        ; get channel number
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291); Kernal($FFC3) Close a logical file (via $31C to $F291)
                            
                            lda #$02                        ; get channel number
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291); Kernal($FFC3) Close a logical file (via $31C to $F291)
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F); Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; send M-R command
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get channel number
                            ldx #FA_DISK                    ; get disk number (8)
                            ldy #SA_CHANNEL_CMD             ; get secondary address - cmd channel
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00); Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            lda #TabDiskCmdProt_MR_Len      ; get M-R command length
                            ldx #<TabDiskCmdProt_MR         ; get address M-R command LO
                            ldy #>TabDiskCmdProt_MR         ; get address M-R command HI
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9); Kernal($FFBD) Set filename parameters ($FDF9)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A); Kernal($FFC0) Open a logical file (via $31A to $F34A)
; --------------------------------------------------------------------------------------------------------------------- ;
; get and store data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$01                        ; get channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E); Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            
                            ldy #$00                        ; ini offset
GetNextDiskByte             jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157); Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            sta TabDiskCmdProt_BE,y         ; $02, $0f, $02, $0e, $22, $0f, $22, $0e
                            
                            iny                             ; inc offset
                            cpy #$10                        ; test max
                            bne GetNextDiskByte             ; check: EQ - no: continue
                            
                            lda #$01                        ; get channel number
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291); Kernal($FFC3) Close a logical file (via $31C to $F291)
                            jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F); Kernal($FFE7) Close all files (via $32C to $F32F)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmdProtFileName      = *       ; 
                            .byte "#" ; #
                            .byte "0" ; 
                            
                            .byte CR  ; <ENTER>
TabDiskCmdProtFileName_Len  = * -TabDiskCmdProtFileName ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmdProt_BE            = *      ; 
                            .byte "b" ; 
                            .byte "-" ; 
                            .byte "e" ; 
                            .byte " " ; 
                            .byte "2" ; channel number
                            .byte " " ; 
                            .byte "0" ; drive number (always 0)
                            .byte " " ; 
                            .byte "1" ; track number HI
                            .byte "8" ; track number LO
                            .byte " " ; 
                            .byte "1" ; sector number HI
                            .byte "0" ; sector number LO
                            
                            .byte CR  ; 
TabDiskCmdProt_BE_Len       = * - TabDiskCmdProt_BE ; 
                            .byte $00 ; End of Command
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmdProt_MR           = *       ; 
                            .byte "m" ; 
                            .byte "-" ; 
                            .byte "r" ; 
                            .byte <$03c0 ; buffer address LO
                            .byte >$03c0 ; buffer address HI
                            .byte $08 ; number of bytes to read
                            
                            .byte CR  ; 
TabDiskCmdProt_MR_Len       = * - TabDiskCmdProt_MR ; 
                            .byte $00 ; End of Command
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSign          Does    : spin game over billboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSign           .block                           ; 
                            lda #CL_SpinSignSpeed_Fast      ; get initial value
                            sta TabWrkGameOverSignSpinSpeed ; set init flip sign spin speed
                            
                            lda #>CL_ScreenGfxDisplay       ; get adr gfx display screen HI
                            sta CLZ_ImageOutputScreen       ; set graphic output  ($20=$2000-$2fff  $40=$4000-$4fff)
                            
GameOverSpinSignNextRound   jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_05    ; 
                            
                            jsr GameOverSpinSignPhase_0a    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_06    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_0a    ; 
                            
                            lda TabWrkGameOverSignSpinSpeed ; get flip sign spin speed
                            cmp #CL_SpinSignSpeed_Slow      ; test slowest
                            bcc GameOverSpinSignNextRound   ; check: lower - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set final phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            
                            clc                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_00  Does    : show game over sign spin phase 0
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_00   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
GameOverSpinSignParmTab     = *                             ; spin sign row data number tabele
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_03  ; $03
                            .byte TabGameOverSignRowNum_04  ; $04
                            .byte TabGameOverSignRowNum_05  ; $05
                            .byte TabGameOverSignRowNum_06  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_08  ; $08
                            .byte TabGameOverSignRowNum_09  ; $09
                            .byte TabGameOverSignRowNum_0a  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
GameOverSpinSignParmTab_Len = * - GameOverSpinSignParmTab   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_01  Does    : show game over sign spin phase 1
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_01   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_03  ; $04
                            .byte TabGameOverSignRowNum_04  ; $05
                            .byte TabGameOverSignRowNum_05  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_09  ; $08
                            .byte TabGameOverSignRowNum_0a  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_02  Does    : show game over sign spin phase 2
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_02   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_03  ; $05
                            .byte TabGameOverSignRowNum_04  ; $06
                            .byte TabGameOverSignRowNum_09  ; $07
                            .byte TabGameOverSignRowNum_0a  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_03  Does    : show game over sign spin phase 3
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_03   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_04  Does    : show game over sign spin phase 4
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_04   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_05  Does    : show game over sign spin phase 5
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_05   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_00  ; $05
                            .byte TabGameOverSignRowNum_01  ; $06
                            .byte TabGameOverSignRowNum_01  ; $07
                            .byte TabGameOverSignRowNum_00  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_06  Does    : show game over sign spin phase 6
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_06   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_0a  ; $03
                            .byte TabGameOverSignRowNum_09  ; $04
                            .byte TabGameOverSignRowNum_08  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_06  ; $07
                            .byte TabGameOverSignRowNum_05  ; $08
                            .byte TabGameOverSignRowNum_04  ; $09
                            .byte TabGameOverSignRowNum_03  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_07  Does    : show game over sign spin phase 7
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_07   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_0a  ; $04
                            .byte TabGameOverSignRowNum_09  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_05  ; $07
                            .byte TabGameOverSignRowNum_04  ; $08
                            .byte TabGameOverSignRowNum_03  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_08  Does    : show game over sign spin phase 8
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_08   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_0a  ; $05
                            .byte TabGameOverSignRowNum_09  ; $06
                            .byte TabGameOverSignRowNum_04  ; $07
                            .byte TabGameOverSignRowNum_03  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_09  Does    : show game over sign spin phase 9
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_09   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_0a  Does    : show game over sign spin phase 10
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_0a   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
;                         Row_00  ................................................................................................ 
;                         Row_01  ....#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.......
;                         Row_02  ..#.......................................................................................#.....
;                         Row_03  ..#...#.#.#.#...#.#.#...#.#.#.#.#...#.#.#.#.......#.#.#.#...#.#...#...#.#.#.#...#.#.#.#...#.....
;                         Row_04  ..#...#.....#...#...#...#.#.#...#...#.#...........#...#.#...#.#...#...#.#.#.#...#.....#...#.....
;                         Row_05  ..#...#.........#...#...#...#...#...#.#...........#...#.#...#.#...#...#.#.......#.....#...#.....
;                         Row_06  ..#...#.........#...#...#...#...#...#.#.#.#.......#...#.#...#.#...#...#.#.#.....#.#.#.#...#.....
;                         Row_07  ..#...#...#.#...#.#.#...#...#...#...#.#.#.#.......#.....#...#.#...#...#.........#.#.#.....#.....
;                         Row_08  ..#...#.....#...#...#...#...#...#...#.............#.....#...#.#.#.#...#.........#.#.#.....#.....
;                         Row_09  ..#...#.....#...#...#...#...#...#...#.............#.....#.....#.#.....#.........#.#...#...#.....
;                         Row_0a  ..#...#.#.#.#...#...#...#...#...#...#.#.#.#.......#.#.#.#.....#.......#.#.#.#...#.....#...#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRow_00   .byte %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000 ; 
TabGameOverDataSignRow_01   .byte %00001010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10000000 ; 
TabGameOverDataSignRow_02   .byte %00100000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00100000 ; 
TabGameOverDataSignRow_03   .byte %00100010, %10101000, %10101000, %10101010, %10001010, %10100000, %00101010, %10001010, %00100010, %10101000, %10101010, %00100000 ; 
TabGameOverDataSignRow_04   .byte %00100010, %00001000, %10001000, %10101000, %10001010, %00000000, %00100010, %10001010, %00100010, %10101000, %10000010, %00100000 ; 
TabGameOverDataSignRow_05   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %00000000, %00100010, %10001010, %00100010, %10000000, %10000010, %00100000 ; 
TabGameOverDataSignRow_06   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %10100000, %00100010, %10001010, %00100010, %10100000, %10101010, %00100000 ; 
TabGameOverDataSignRow_07   .byte %00100010, %00101000, %10101000, %10001000, %10001010, %10100000, %00100000, %10001010, %00100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_08   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10001010, %10100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_09   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10000010, %10000010, %00000000, %10100010, %00100000 ; 
TabGameOverDataSignRow_0a   .byte %00100010, %10101000, %10001000, %10001000, %10001010, %10100000, %00101010, %10000010, %00000010, %10101000, %10100010, %00100000 ; 
TabGameOverDataSignRow_Len  = * - TabGameOverDataSignRow_0a ; length data of each game over spin sign row
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRowAdr   = * ; spin game over sign data address tab
                            .word TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02 ; $8fd1
                            .word TabGameOverDataSignRow_01 - TabGameOverDataSignRow_Len - $02 ; $8fdd
                            .word TabGameOverDataSignRow_02 - TabGameOverDataSignRow_Len - $02 ; $8fe9
                            .word TabGameOverDataSignRow_03 - TabGameOverDataSignRow_Len - $02 ; $8ff5
                            .word TabGameOverDataSignRow_04 - TabGameOverDataSignRow_Len - $02 ; $9001
                            .word TabGameOverDataSignRow_05 - TabGameOverDataSignRow_Len - $02 ; $900d
                            .word TabGameOverDataSignRow_06 - TabGameOverDataSignRow_Len - $02 ; $9019
                            .word TabGameOverDataSignRow_07 - TabGameOverDataSignRow_Len - $02 ; $9025
                            .word TabGameOverDataSignRow_08 - TabGameOverDataSignRow_Len - $02 ; $9031
                            .word TabGameOverDataSignRow_09 - TabGameOverDataSignRow_Len - $02 ; $903d
                            .word TabGameOverDataSignRow_0a - TabGameOverDataSignRow_Len - $02 ; $9049
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverSignRowNum       = * ;                 
TabGameOverSignRowNum_00    = (TabGameOverDataSignRow_00 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_01    = (TabGameOverDataSignRow_01 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_02    = (TabGameOverDataSignRow_02 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_03    = (TabGameOverDataSignRow_03 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_04    = (TabGameOverDataSignRow_04 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_05    = (TabGameOverDataSignRow_05 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_06    = (TabGameOverDataSignRow_06 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_07    = (TabGameOverDataSignRow_07 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_08    = (TabGameOverDataSignRow_08 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_09    = (TabGameOverDataSignRow_09 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_0a    = (TabGameOverDataSignRow_0a - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhases    Does    : display the different game over billboard pahases
;                           Expects : pointer to $0d phase numbers on the stack
;                           Returns : 
;                           Remark  : checks player input to end spinning
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhases     .block                           ; 
                            pla                             ; get start address of data number array LO
                            sta CLZ_SignRowNumberTabPtr_Lo  ; set start address of data number array LO
                            pla                             ; get start address of data number array HI
                            sta CLZ_SignRowNumberTabPtr_Hi  ; set start address of data number array HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init output row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CLZ_ScreenRow_Spin         ; get grafic screen row offset
                            sty CLZ_ScreenRow               ; ini screen row ($00-$0f)
                            bne SetNextGameOverDataPtr      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSignScreenRow        jsr ScreenSetRowPointerStart    ; set grafic screen pointer to row start
                            
                            ldy #$00                        ; get offset
                            lda (CLZ_SignRowNumberTabPtr),y ; get next sign data number byte
                            asl a                           ; *2 - address length
                            tax                             ; set as table game over data sign row addresses offset
; --------------------------------------------------------------------------------------------------------------------- ;
; each entry is set to TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabGameOverDataSignRowAdr + $00,x ; get flip data address tab LO
                            sta smGetSignDataAdr_Lo         ; set get data address LO
                            
                            lda TabGameOverDataSignRowAdr + $01,x ; get flip data address tab HI
                            sta smGetSignDataAdr_Hi         ; set get data address HI
                            
                            ldy #CLZ_ScreenSpinColOff_Left  ; get grafic screen column offset
                            sty CLZ_ScreenSpinColOff        ; ini gfx screen image column offset
                            
                            ldy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len ; get spin sign row number parm table length
                            sty CLZ_WorkGameOverParmTabOff  ; set game over sign parm row number table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get offset to real address
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSignParmRowTabOff    ldy CLZ_WorkGameOverParmTabOff  ; get next game over sign parm row number table offset
                            inc CLZ_WorkGameOverParmTabOff  ; inc game over sign parm row number table offset
smGetSignDataAdr_Lo         = * + $01                       ; 
smGetSignDataAdr_Hi         = * + $02                       ; 
GetSignDataByte             lda GetSignDataByte,y           ; get sign data byte
                            lsr a                           ; /2
                            ldy CLZ_ScreenSpinColOff        ; get gfx screen image row offset
                            sta (CLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance output column offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            clc                             ; 
                            adc #$08                        ; point to next screen column position
                            sta CLZ_ScreenSpinColOff        ; set gfx screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CLZ_WorkGameOverParmTabOff  ; get sign data row length
                            cpy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len * $02 - $02 ; test  max
                            bcc GetNextSignParmRowTabOff    ; check: LT - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextGameOverDataPtr      jsr GameOverSpinSignIncTabPtr   ; inc pointer to game over sign number table
; --------------------------------------------------------------------------------------------------------------------- ;
; inc game over sign screen row and check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            ldy CLZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #CLZ_ScreenRow_Spin + GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len + $01 ; test max
                            bcc SetNextSignScreenRow        ; check: LT - no: continue with next row
; --------------------------------------------------------------------------------------------------------------------- ;
; handle spin timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkGameOverSignSpinSpeed ; get flip sign spin speed timer HI value
                            ldy #$ff                        ; ini wait timer LO
DecNextWaitTimerCount       dey                             ; dec wait timer LO
                            bne DecNextWaitTimerCount       ; check: timer LO underrun - no: continue
                            
                            dex                             ; dec wait timer HI
                            bne DecNextWaitTimerCount       ; check: timer HI underrun - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; slow down sign rotation speed a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkGameOverSignSpinSpeed ; flip sign spin speed so wait longer the next time
; --------------------------------------------------------------------------------------------------------------------- ;
; check player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            beq GameOverSpinSignPhasesX     ; check: pressed - yes: exir
                            
                            lda CL_KeyNew                   ; get actual key
                            bne GameOverSpinSignPhasesX     ; check: got a new one - yes: exit
                            
                            rts                             ; return to next phase
; --------------------------------------------------------------------------------------------------------------------- ;
; player interrupt ends spinnig - do not return to caller but to GameOver.DemoWaitInit   
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhasesX     pla                             ; pull return address from stack
                            pla                             ; 
                            
                            sec                             ; set flag player interrupt
                            rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGameOverSignSpinSpeed .byte $00                       ; save actual game over sign spinning speed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignIncTabPtr Does    : inc game over sign number table data pointer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignIncTabPtr  .block                           ; 
                            inc CLZ_SignRowNumberTabPtr_Lo  ; 
                            bne GameOverSpinSignIncTabPtrX  ; check: overflow - no
                            inc CLZ_SignRowNumberTabPtr_Hi  ; 
                            
GameOverSpinSignIncTabPtrX  rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
GarbageArea_01             .include "../inc/CL_Garbage_01.asm" ; old code renmnants - not references
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 2 columns of image data for each of the 4 possible image x-positions - accessed by TabImageDataOff
; --------------------------------------------------------------------------------------------------------------------- ;
; image row byte 1 - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len
; image row byte 2 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len       - part 1 - combined with part 2
;                  - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len * $02 - part 2
; image row byte 3 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageData                = *       ; 
TabImageDataPos_01_Part_01  = *       ; $a000    $a100      $a200    $a300      $a400    $a500      $a600    $a700   
                            .byte $00 ; ........ ........   ........ ........   ........ ........   ........ ........
                            .byte $01 ; .......# ........   ........ .#......   ........ ...#....   ........ .....#..
                            .byte $02 ; ......#. ........   ........ #.......   ........ ..#.....   ........ ....#...
                            .byte $03 ; ......## ........   ........ ##......   ........ ..##....   ........ ....##..
                            .byte $04 ; .....#.. ........   .......# ........   ........ .#......   ........ ...#....
                            .byte $05 ; .....#.# ........   .......# .#......   ........ .#.#....   ........ ...#.#..
                            .byte $06 ; .....##. ........   .......# #.......   ........ .##.....   ........ ...##...
                            .byte $07 ; .....### ........   .......# ##......   ........ .###....   ........ ...###..
                            .byte $08 ; ....#... ........   ......#. ........   ........ #.......   ........ ..#.....
                            .byte $09 ; ....#..# ........   ......#. .#......   ........ #..#....   ........ ..#..#..
                            .byte $0a ; ....#.#. ........   ......#. #.......   ........ #.#.....   ........ ..#.#...
                            .byte $0b ; ....#.## ........   ......#. ##......   ........ #.##....   ........ ..#.##..
                            .byte $0c ; ....##.. ........   ......## ........   ........ ##......   ........ ..##....
                            .byte $0d ; ....##.# ........   ......## .#......   ........ ##.#....   ........ ..##.#..
                            .byte $0e ; ....###. ........   ......## #.......   ........ ###.....   ........ ..###...
                            .byte $0f ; ....#### ........   ......## ##......   ........ ####....   ........ ..####..
                            .byte $10 ; ...#.... ........   .....#.. ........   .......# ........   ........ .#......
                            .byte $11 ; ...#...# ........   .....#.. .#......   .......# ...#....   ........ .#...#..
                            .byte $12 ; ...#..#. ........   .....#.. #.......   .......# ..#.....   ........ .#..#...
                            .byte $13 ; ...#..## ........   .....#.. ##......   .......# ..##....   ........ .#..##..
                            .byte $14 ; ...#.#.. ........   .....#.# ........   .......# .#......   ........ .#.#....
                            .byte $15 ; ...#.#.# ........   .....#.# .#......   .......# .#.#....   ........ .#.#.#..
                            .byte $16 ; ...#.##. ........   .....#.# #.......   .......# .##.....   ........ .#.##...
                            .byte $17 ; ...#.### ........   .....#.# ##......   .......# .###....   ........ .#.###..
                            .byte $18 ; ...##... ........   .....##. ........   .......# #.......   ........ .##.....
                            .byte $19 ; ...##..# ........   .....##. .#......   .......# #..#....   ........ .##..#..
                            .byte $1a ; ...##.#. ........   .....##. #.......   .......# #.#.....   ........ .##.#...
                            .byte $1b ; ...##.## ........   .....##. ##......   .......# #.##....   ........ .##.##..
                            .byte $1c ; ...###.. ........   .....### ........   .......# ##......   ........ .###....
                            .byte $1d ; ...###.# ........   .....### .#......   .......# ##.#....   ........ .###.#..
                            .byte $1e ; ...####. ........   .....### #.......   .......# ###.....   ........ .####...
                            .byte $1f ; ...##### ........   .....### ##......   .......# ####....   ........ .#####..
                            .byte $20 ; ..#..... ........   ....#... ........   ......#. ........   ........ #.......
                            .byte $21 ; ..#....# ........   ....#... .#......   ......#. ...#....   ........ #....#..
                            .byte $22 ; ..#...#. ........   ....#... #.......   ......#. ..#.....   ........ #...#...
                            .byte $23 ; ..#...## ........   ....#... ##......   ......#. ..##....   ........ #...##..
                            .byte $24 ; ..#..#.. ........   ....#..# ........   ......#. .#......   ........ #..#....
                            .byte $25 ; ..#..#.# ........   ....#..# .#......   ......#. .#.#....   ........ #..#.#..
                            .byte $26 ; ..#..##. ........   ....#..# #.......   ......#. .##.....   ........ #..##...
                            .byte $27 ; ..#..### ........   ....#..# ##......   ......#. .###....   ........ #..###..
                            .byte $28 ; ..#.#... ........   ....#.#. ........   ......#. #.......   ........ #.#.....
                            .byte $29 ; ..#.#..# ........   ....#.#. .#......   ......#. #..#....   ........ #.#..#..
                            .byte $2a ; ..#.#.#. ........   ....#.#. #.......   ......#. #.#.....   ........ #.#.#...
                            .byte $2b ; ..#.#.## ........   ....#.#. ##......   ......#. #.##....   ........ #.#.##..
                            .byte $2c ; ..#.##.. ........   ....#.## ........   ......#. ##......   ........ #.##....
                            .byte $2d ; ..#.##.# ........   ....#.## .#......   ......#. ##.#....   ........ #.##.#..
                            .byte $2e ; ..#.###. ........   ....#.## #.......   ......#. ###.....   ........ #.###...
                            .byte $2f ; ..#.#### ........   ....#.## ##......   ......#. ####....   ........ #.####..
                            .byte $30 ; ..##.... ........   ....##.. ........   ......## ........   ........ ##......
                            .byte $31 ; ..##...# ........   ....##.. .#......   ......## ...#....   ........ ##...#..
                            .byte $32 ; ..##..#. ........   ....##.. #.......   ......## ..#.....   ........ ##..#...
                            .byte $33 ; ..##..## ........   ....##.. ##......   ......## ..##....   ........ ##..##..
                            .byte $34 ; ..##.#.. ........   ....##.# ........   ......## .#......   ........ ##.#....
                            .byte $35 ; ..##.#.# ........   ....##.# .#......   ......## .#.#....   ........ ##.#.#..
                            .byte $36 ; ..##.##. ........   ....##.# #.......   ......## .##.....   ........ ##.##...
                            .byte $37 ; ..##.### ........   ....##.# ##......   ......## .###....   ........ ##.###..
                            .byte $38 ; ..###... ........   ....###. ........   ......## #.......   ........ ###.....
                            .byte $39 ; ..###..# ........   ....###. .#......   ......## #..#....   ........ ###..#..
                            .byte $3a ; ..###.#. ........   ....###. #.......   ......## #.#.....   ........ ###.#...
                            .byte $3b ; ..###.## ........   ....###. ##......   ......## #.##....   ........ ###.##..
                            .byte $3c ; ..####.. ........   ....#### ........   ......## ##......   ........ ####....
                            .byte $3d ; ..####.# ........   ....#### .#......   ......## ##.#....   ........ ####.#..
                            .byte $3e ; ..#####. ........   ....#### #.......   ......## ###.....   ........ #####...
                            .byte $3f ; ..###### ........   ....#### ##......   ......## ####....   ........ ######..
                            .byte $40 ; .#...... ........   ...#.... ........   .....#.. ........   .......# ........
                            .byte $41 ; .#.....# ........   ...#.... .#......   .....#.. ...#....   .......# .....#..
                            .byte $42 ; .#....#. ........   ...#.... #.......   .....#.. ..#.....   .......# ....#...
                            .byte $43 ; .#....## ........   ...#.... ##......   .....#.. ..##....   .......# ....##..
                            .byte $44 ; .#...#.. ........   ...#...# ........   .....#.. .#......   .......# ...#....
                            .byte $45 ; .#...#.# ........   ...#...# .#......   .....#.. .#.#....   .......# ...#.#..
                            .byte $46 ; .#...##. ........   ...#...# #.......   .....#.. .##.....   .......# ...##...
                            .byte $47 ; .#...### ........   ...#...# ##......   .....#.. .###....   .......# ...###..
                            .byte $48 ; .#..#... ........   ...#..#. ........   .....#.. #.......   .......# ..#.....
                            .byte $49 ; .#..#..# ........   ...#..#. .#......   .....#.. #..#....   .......# ..#..#..
                            .byte $4a ; .#..#.#. ........   ...#..#. #.......   .....#.. #.#.....   .......# ..#.#...
                            .byte $4b ; .#..#.## ........   ...#..#. ##......   .....#.. #.##....   .......# ..#.##..
                            .byte $4c ; .#..##.. ........   ...#..## ........   .....#.. ##......   .......# ..##....
                            .byte $4d ; .#..##.# ........   ...#..## .#......   .....#.. ##.#....   .......# ..##.#..
                            .byte $4e ; .#..###. ........   ...#..## #.......   .....#.. ###.....   .......# ..###...
                            .byte $4f ; .#..#### ........   ...#..## ##......   .....#.. ####....   .......# ..####..
                            .byte $50 ; .#.#.... ........   ...#.#.. ........   .....#.# ........   .......# .#......
                            .byte $51 ; .#.#...# ........   ...#.#.. .#......   .....#.# ...#....   .......# .#...#..
                            .byte $52 ; .#.#..#. ........   ...#.#.. #.......   .....#.# ..#.....   .......# .#..#...
                            .byte $53 ; .#.#..## ........   ...#.#.. ##......   .....#.# ..##....   .......# .#..##..
                            .byte $54 ; .#.#.#.. ........   ...#.#.# ........   .....#.# .#......   .......# .#.#....
                            .byte $55 ; .#.#.#.# ........   ...#.#.# .#......   .....#.# .#.#....   .......# .#.#.#..
                            .byte $56 ; .#.#.##. ........   ...#.#.# #.......   .....#.# .##.....   .......# .#.##...
                            .byte $57 ; .#.#.### ........   ...#.#.# ##......   .....#.# .###....   .......# .#.###..
                            .byte $58 ; .#.##... ........   ...#.##. ........   .....#.# #.......   .......# .##.....
                            .byte $59 ; .#.##..# ........   ...#.##. .#......   .....#.# #..#....   .......# .##..#..
                            .byte $5a ; .#.##.#. ........   ...#.##. #.......   .....#.# #.#.....   .......# .##.#...
                            .byte $5b ; .#.##.## ........   ...#.##. ##......   .....#.# #.##....   .......# .##.##..
                            .byte $5c ; .#.###.. ........   ...#.### ........   .....#.# ##......   .......# .###....
                            .byte $5d ; .#.###.# ........   ...#.### .#......   .....#.# ##.#....   .......# .###.#..
                            .byte $5e ; .#.####. ........   ...#.### #.......   .....#.# ###.....   .......# .####...
                            .byte $5f ; .#.##### ........   ...#.### ##......   .....#.# ####....   .......# .#####..
                            .byte $60 ; .##..... ........   ...##... ........   .....##. ........   .......# #.......
                            .byte $61 ; .##....# ........   ...##... .#......   .....##. ...#....   .......# #....#..
                            .byte $62 ; .##...#. ........   ...##... #.......   .....##. ..#.....   .......# #...#...
                            .byte $63 ; .##...## ........   ...##... ##......   .....##. ..##....   .......# #...##..
                            .byte $64 ; .##..#.. ........   ...##..# ........   .....##. .#......   .......# #..#....
                            .byte $65 ; .##..#.# ........   ...##..# .#......   .....##. .#.#....   .......# #..#.#..
                            .byte $66 ; .##..##. ........   ...##..# #.......   .....##. .##.....   .......# #..##...
                            .byte $67 ; .##..### ........   ...##..# ##......   .....##. .###....   .......# #..###..
                            .byte $68 ; .##.#... ........   ...##.#. ........   .....##. #.......   .......# #.#.....
                            .byte $69 ; .##.#..# ........   ...##.#. .#......   .....##. #..#....   .......# #.#..#..
                            .byte $6a ; .##.#.#. ........   ...##.#. #.......   .....##. #.#.....   .......# #.#.#...
                            .byte $6b ; .##.#.## ........   ...##.#. ##......   .....##. #.##....   .......# #.#.##..
                            .byte $6c ; .##.##.. ........   ...##.## ........   .....##. ##......   .......# #.##....
                            .byte $6d ; .##.##.# ........   ...##.## .#......   .....##. ##.#....   .......# #.##.#..
                            .byte $6e ; .##.###. ........   ...##.## #.......   .....##. ###.....   .......# #.###...
                            .byte $6f ; .##.#### ........   ...##.## ##......   .....##. ####....   .......# #.####..
                            .byte $70 ; .###.... ........   ...###.. ........   .....### ........   .......# ##......
                            .byte $71 ; .###...# ........   ...###.. .#......   .....### ...#....   .......# ##...#..
                            .byte $72 ; .###..#. ........   ...###.. #.......   .....### ..#.....   .......# ##..#...
                            .byte $73 ; .###..## ........   ...###.. ##......   .....### ..##....   .......# ##..##..
                            .byte $74 ; .###.#.. ........   ...###.# ........   .....### .#......   .......# ##.#....
                            .byte $75 ; .###.#.# ........   ...###.# .#......   .....### .#.#....   .......# ##.#.#..
                            .byte $76 ; .###.##. ........   ...###.# #.......   .....### .##.....   .......# ##.##...
                            .byte $77 ; .###.### ........   ...###.# ##......   .....### .###....   .......# ##.###..
                            .byte $78 ; .####... ........   ...####. ........   .....### #.......   .......# ###.....
                            .byte $79 ; .####..# ........   ...####. .#......   .....### #..#....   .......# ###..#..
                            .byte $7a ; .####.#. ........   ...####. #.......   .....### #.#.....   .......# ###.#...
                            .byte $7b ; .####.## ........   ...####. ##......   .....### #.##....   .......# ###.##..
                            .byte $7c ; .#####.. ........   ...##### ........   .....### ##......   .......# ####....
                            .byte $7d ; .#####.# ........   ...##### .#......   .....### ##.#....   .......# ####.#..
                            .byte $7e ; .######. ........   ...##### #.......   .....### ###.....   .......# #####...
                            .byte $7f ; .####### ........   ...##### ##......   .....### ####....   .......# ######..
                            .byte $80 ; #....... ........   ..#..... ........   ....#... ........   ......#. ........
                            .byte $81 ; #......# ........   ..#..... .#......   ....#... ...#....   ......#. .....#..
                            .byte $82 ; #.....#. ........   ..#..... #.......   ....#... ..#.....   ......#. ....#...
                            .byte $83 ; #.....## ........   ..#..... ##......   ....#... ..##....   ......#. ....##..
                            .byte $84 ; #....#.. ........   ..#....# ........   ....#... .#......   ......#. ...#....
                            .byte $85 ; #....#.# ........   ..#....# .#......   ....#... .#.#....   ......#. ...#.#..
                            .byte $86 ; #....##. ........   ..#....# #.......   ....#... .##.....   ......#. ...##...
                            .byte $87 ; #....### ........   ..#....# ##......   ....#... .###....   ......#. ...###..
                            .byte $88 ; #...#... ........   ..#...#. ........   ....#... #.......   ......#. ..#.....
                            .byte $89 ; #...#..# ........   ..#...#. .#......   ....#... #..#....   ......#. ..#..#..
                            .byte $8a ; #...#.#. ........   ..#...#. #.......   ....#... #.#.....   ......#. ..#.#...
                            .byte $8b ; #...#.## ........   ..#...#. ##......   ....#... #.##....   ......#. ..#.##..
                            .byte $8c ; #...##.. ........   ..#...## ........   ....#... ##......   ......#. ..##....
                            .byte $8d ; #...##.# ........   ..#...## .#......   ....#... ##.#....   ......#. ..##.#..
                            .byte $8e ; #...###. ........   ..#...## #.......   ....#... ###.....   ......#. ..###...
                            .byte $8f ; #...#### ........   ..#...## ##......   ....#... ####....   ......#. ..####..
                            .byte $90 ; #..#.... ........   ..#..#.. ........   ....#..# ........   ......#. .#......
                            .byte $91 ; #..#...# ........   ..#..#.. .#......   ....#..# ...#....   ......#. .#...#..
                            .byte $92 ; #..#..#. ........   ..#..#.. #.......   ....#..# ..#.....   ......#. .#..#...
                            .byte $93 ; #..#..## ........   ..#..#.. ##......   ....#..# ..##....   ......#. .#..##..
                            .byte $94 ; #..#.#.. ........   ..#..#.# ........   ....#..# .#......   ......#. .#.#....
                            .byte $95 ; #..#.#.# ........   ..#..#.# .#......   ....#..# .#.#....   ......#. .#.#.#..
                            .byte $96 ; #..#.##. ........   ..#..#.# #.......   ....#..# .##.....   ......#. .#.##...
                            .byte $97 ; #..#.### ........   ..#..#.# ##......   ....#..# .###....   ......#. .#.###..
                            .byte $98 ; #..##... ........   ..#..##. ........   ....#..# #.......   ......#. .##.....
                            .byte $99 ; #..##..# ........   ..#..##. .#......   ....#..# #..#....   ......#. .##..#..
                            .byte $9a ; #..##.#. ........   ..#..##. #.......   ....#..# #.#.....   ......#. .##.#...
                            .byte $9b ; #..##.## ........   ..#..##. ##......   ....#..# #.##....   ......#. .##.##..
                            .byte $9c ; #..###.. ........   ..#..### ........   ....#..# ##......   ......#. .###....
                            .byte $9d ; #..###.# ........   ..#..### .#......   ....#..# ##.#....   ......#. .###.#..
                            .byte $9e ; #..####. ........   ..#..### #.......   ....#..# ###.....   ......#. .####...
                            .byte $9f ; #..##### ........   ..#..### ##......   ....#..# ####....   ......#. .#####..
                            .byte $a0 ; #.#..... ........   ..#.#... ........   ....#.#. ........   ......#. #.......
                            .byte $a1 ; #.#....# ........   ..#.#... .#......   ....#.#. ...#....   ......#. #....#..
                            .byte $a2 ; #.#...#. ........   ..#.#... #.......   ....#.#. ..#.....   ......#. #...#...
                            .byte $a3 ; #.#...## ........   ..#.#... ##......   ....#.#. ..##....   ......#. #...##..
                            .byte $a4 ; #.#..#.. ........   ..#.#..# ........   ....#.#. .#......   ......#. #..#....
                            .byte $a5 ; #.#..#.# ........   ..#.#..# .#......   ....#.#. .#.#....   ......#. #..#.#..
                            .byte $a6 ; #.#..##. ........   ..#.#..# #.......   ....#.#. .##.....   ......#. #..##...
                            .byte $a7 ; #.#..### ........   ..#.#..# ##......   ....#.#. .###....   ......#. #..###..
                            .byte $a8 ; #.#.#... ........   ..#.#.#. ........   ....#.#. #.......   ......#. #.#.....
                            .byte $a9 ; #.#.#..# ........   ..#.#.#. .#......   ....#.#. #..#....   ......#. #.#..#..
                            .byte $aa ; #.#.#.#. ........   ..#.#.#. #.......   ....#.#. #.#.....   ......#. #.#.#...
                            .byte $ab ; #.#.#.## ........   ..#.#.#. ##......   ....#.#. #.##....   ......#. #.#.##..
                            .byte $ac ; #.#.##.. ........   ..#.#.## ........   ....#.#. ##......   ......#. #.##....
                            .byte $ad ; #.#.##.# ........   ..#.#.## .#......   ....#.#. ##.#....   ......#. #.##.#..
                            .byte $ae ; #.#.###. ........   ..#.#.## #.......   ....#.#. ###.....   ......#. #.###...
                            .byte $af ; #.#.#### ........   ..#.#.## ##......   ....#.#. ####....   ......#. #.####..
                            .byte $b0 ; #.##.... ........   ..#.##.. ........   ....#.## ........   ......#. ##......
                            .byte $b1 ; #.##...# ........   ..#.##.. .#......   ....#.## ...#....   ......#. ##...#..
                            .byte $b2 ; #.##..#. ........   ..#.##.. #.......   ....#.## ..#.....   ......#. ##..#...
                            .byte $b3 ; #.##..## ........   ..#.##.. ##......   ....#.## ..##....   ......#. ##..##..
                            .byte $b4 ; #.##.#.. ........   ..#.##.# ........   ....#.## .#......   ......#. ##.#....
                            .byte $b5 ; #.##.#.# ........   ..#.##.# .#......   ....#.## .#.#....   ......#. ##.#.#..
                            .byte $b6 ; #.##.##. ........   ..#.##.# #.......   ....#.## .##.....   ......#. ##.##...
                            .byte $b7 ; #.##.### ........   ..#.##.# ##......   ....#.## .###....   ......#. ##.###..
                            .byte $b8 ; #.###... ........   ..#.###. ........   ....#.## #.......   ......#. ###.....
                            .byte $b9 ; #.###..# ........   ..#.###. .#......   ....#.## #..#....   ......#. ###..#..
                            .byte $ba ; #.###.#. ........   ..#.###. #.......   ....#.## #.#.....   ......#. ###.#...
                            .byte $bb ; #.###.## ........   ..#.###. ##......   ....#.## #.##....   ......#. ###.##..
                            .byte $bc ; #.####.. ........   ..#.#### ........   ....#.## ##......   ......#. ####....
                            .byte $bd ; #.####.# ........   ..#.#### .#......   ....#.## ##.#....   ......#. ####.#..
                            .byte $be ; #.#####. ........   ..#.#### #.......   ....#.## ###.....   ......#. #####...
                            .byte $bf ; #.###### ........   ..#.#### ##......   ....#.## ####....   ......#. ######..
                            .byte $c0 ; ##...... ........   ..##.... ........   ....##.. ........   ......## ........
                            .byte $c1 ; ##.....# ........   ..##.... .#......   ....##.. ...#....   ......## .....#..
                            .byte $c2 ; ##....#. ........   ..##.... #.......   ....##.. ..#.....   ......## ....#...
                            .byte $c3 ; ##....## ........   ..##.... ##......   ....##.. ..##....   ......## ....##..
                            .byte $c4 ; ##...#.. ........   ..##...# ........   ....##.. .#......   ......## ...#....
                            .byte $c5 ; ##...#.# ........   ..##...# .#......   ....##.. .#.#....   ......## ...#.#..
                            .byte $c6 ; ##...##. ........   ..##...# #.......   ....##.. .##.....   ......## ...##...
                            .byte $c7 ; ##...### ........   ..##...# ##......   ....##.. .###....   ......## ...###..
                            .byte $c8 ; ##..#... ........   ..##..#. ........   ....##.. #.......   ......## ..#.....
                            .byte $c9 ; ##..#..# ........   ..##..#. .#......   ....##.. #..#....   ......## ..#..#..
                            .byte $ca ; ##..#.#. ........   ..##..#. #.......   ....##.. #.#.....   ......## ..#.#...
                            .byte $cb ; ##..#.## ........   ..##..#. ##......   ....##.. #.##....   ......## ..#.##..
                            .byte $cc ; ##..##.. ........   ..##..## ........   ....##.. ##......   ......## ..##....
                            .byte $cd ; ##..##.# ........   ..##..## .#......   ....##.. ##.#....   ......## ..##.#..
                            .byte $ce ; ##..###. ........   ..##..## #.......   ....##.. ###.....   ......## ..###...
                            .byte $cf ; ##..#### ........   ..##..## ##......   ....##.. ####....   ......## ..####..
                            .byte $d0 ; ##.#.... ........   ..##.#.. ........   ....##.# ........   ......## .#......
                            .byte $d1 ; ##.#...# ........   ..##.#.. .#......   ....##.# ...#....   ......## .#...#..
                            .byte $d2 ; ##.#..#. ........   ..##.#.. #.......   ....##.# ..#.....   ......## .#..#...
                            .byte $d3 ; ##.#..## ........   ..##.#.. ##......   ....##.# ..##....   ......## .#..##..
                            .byte $d4 ; ##.#.#.. ........   ..##.#.# ........   ....##.# .#......   ......## .#.#....
                            .byte $d5 ; ##.#.#.# ........   ..##.#.# .#......   ....##.# .#.#....   ......## .#.#.#..
                            .byte $d6 ; ##.#.##. ........   ..##.#.# #.......   ....##.# .##.....   ......## .#.##...
                            .byte $d7 ; ##.#.### ........   ..##.#.# ##......   ....##.# .###....   ......## .#.###..
                            .byte $d8 ; ##.##... ........   ..##.##. ........   ....##.# #.......   ......## .##.....
                            .byte $d9 ; ##.##..# ........   ..##.##. .#......   ....##.# #..#....   ......## .##..#..
                            .byte $da ; ##.##.#. ........   ..##.##. #.......   ....##.# #.#.....   ......## .##.#...
                            .byte $db ; ##.##.## ........   ..##.##. ##......   ....##.# #.##....   ......## .##.##..
                            .byte $dc ; ##.###.. ........   ..##.### ........   ....##.# ##......   ......## .###....
                            .byte $dd ; ##.###.# ........   ..##.### .#......   ....##.# ##.#....   ......## .###.#..
                            .byte $de ; ##.####. ........   ..##.### #.......   ....##.# ###.....   ......## .####...
                            .byte $df ; ##.##### ........   ..##.### ##......   ....##.# ####....   ......## .#####..
                            .byte $e0 ; ###..... ........   ..###... ........   ....###. ........   ......## #.......
                            .byte $e1 ; ###....# ........   ..###... .#......   ....###. ...#....   ......## #....#..
                            .byte $e2 ; ###...#. ........   ..###... #.......   ....###. ..#.....   ......## #...#...
                            .byte $e3 ; ###...## ........   ..###... ##......   ....###. ..##....   ......## #...##..
                            .byte $e4 ; ###..#.. ........   ..###..# ........   ....###. .#......   ......## #..#....
                            .byte $e5 ; ###..#.# ........   ..###..# .#......   ....###. .#.#....   ......## #..#.#..
                            .byte $e6 ; ###..##. ........   ..###..# #.......   ....###. .##.....   ......## #..##...
                            .byte $e7 ; ###..### ........   ..###..# ##......   ....###. .###....   ......## #..###..
                            .byte $e8 ; ###.#... ........   ..###.#. ........   ....###. #.......   ......## #.#.....
                            .byte $e9 ; ###.#..# ........   ..###.#. .#......   ....###. #..#....   ......## #.#..#..
                            .byte $ea ; ###.#.#. ........   ..###.#. #.......   ....###. #.#.....   ......## #.#.#...
                            .byte $eb ; ###.#.## ........   ..###.#. ##......   ....###. #.##....   ......## #.#.##..
                            .byte $ec ; ###.##.. ........   ..###.## ........   ....###. ##......   ......## #.##....
                            .byte $ed ; ###.##.# ........   ..###.## .#......   ....###. ##.#....   ......## #.##.#..
                            .byte $ee ; ###.###. ........   ..###.## #.......   ....###. ###.....   ......## #.###...
                            .byte $ef ; ###.#### ........   ..###.## ##......   ....###. ####....   ......## #.####..
                            .byte $f0 ; ####.... ........   ..####.. ........   ....#### ........   ......## ##......
                            .byte $f1 ; ####...# ........   ..####.. .#......   ....#### ...#....   ......## ##...#..
                            .byte $f2 ; ####..#. ........   ..####.. #.......   ....#### ..#.....   ......## ##..#...
                            .byte $f3 ; ####..## ........   ..####.. ##......   ....#### ..##....   ......## ##..##..
                            .byte $f4 ; ####.#.. ........   ..####.# ........   ....#### .#......   ......## ##.#....
                            .byte $f5 ; ####.#.# ........   ..####.# .#......   ....#### .#.#....   ......## ##.#.#..
                            .byte $f6 ; ####.##. ........   ..####.# #.......   ....#### .##.....   ......## ##.##...
                            .byte $f7 ; ####.### ........   ..####.# ##......   ....#### .###....   ......## ##.###..
                            .byte $f8 ; #####... ........   ..#####. ........   ....#### #.......   ......## ###.....
                            .byte $f9 ; #####..# ........   ..#####. .#......   ....#### #..#....   ......## ###..#..
                            .byte $fa ; #####.#. ........   ..#####. #.......   ....#### #.#.....   ......## ###.#...
                            .byte $fb ; #####.## ........   ..#####. ##......   ....#### #.##....   ......## ###.##..
                            .byte $fc ; ######.. ........   ..###### ........   ....#### ##......   ......## ####....
                            .byte $fd ; ######.# ........   ..###### .#......   ....#### ##.#....   ......## ####.#..
                            .byte $fe ; #######. ........   ..###### #.......   ....#### ###.....   ......## #####...
                            .byte $ff ; ######## ........   ..###### ##......   ....#### ####....   ......## ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_01_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_02_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  ##......
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  ##......
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  ##......
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  ##......
                            .byte $04 ; .....#..  ........
                            .byte $04 ; .....#..  .#......
                            .byte $04 ; .....#..  #.......
                            .byte $04 ; .....#..  ##......
                            .byte $05 ; .....#.#  ........
                            .byte $05 ; .....#.#  .#......
                            .byte $05 ; .....#.#  #.......
                            .byte $05 ; .....#.#  ##......
                            .byte $06 ; .....##.  ........
                            .byte $06 ; .....##.  .#......
                            .byte $06 ; .....##.  #.......
                            .byte $06 ; .....##.  ##......
                            .byte $07 ; .....###  ........
                            .byte $07 ; .....###  .#......
                            .byte $07 ; .....###  #.......
                            .byte $07 ; .....###  ##......
                            .byte $08 ; ....#...  ........
                            .byte $08 ; ....#...  .#......
                            .byte $08 ; ....#...  #.......
                            .byte $08 ; ....#...  ##......
                            .byte $09 ; ....#..#  ........
                            .byte $09 ; ....#..#  .#......
                            .byte $09 ; ....#..#  #.......
                            .byte $09 ; ....#..#  ##......
                            .byte $0a ; ....#.#.  ........
                            .byte $0a ; ....#.#.  .#......
                            .byte $0a ; ....#.#.  #.......
                            .byte $0a ; ....#.#.  ##......
                            .byte $0b ; ....#.##  ........
                            .byte $0b ; ....#.##  .#......
                            .byte $0b ; ....#.##  #.......
                            .byte $0b ; ....#.##  ##......
                            .byte $0c ; ....##..  ........
                            .byte $0c ; ....##..  .#......
                            .byte $0c ; ....##..  #.......
                            .byte $0c ; ....##..  ##......
                            .byte $0d ; ....##.#  ........
                            .byte $0d ; ....##.#  .#......
                            .byte $0d ; ....##.#  #.......
                            .byte $0d ; ....##.#  ##......
                            .byte $0e ; ....###.  ........
                            .byte $0e ; ....###.  .#......
                            .byte $0e ; ....###.  #.......
                            .byte $0e ; ....###.  ##......
                            .byte $0f ; ....####  ........
                            .byte $0f ; ....####  .#......
                            .byte $0f ; ....####  #.......
                            .byte $0f ; ....####  ##......
                            .byte $10 ; ...#....  ........
                            .byte $10 ; ...#....  .#......
                            .byte $10 ; ...#....  #.......
                            .byte $10 ; ...#....  ##......
                            .byte $11 ; ...#...#  ........
                            .byte $11 ; ...#...#  .#......
                            .byte $11 ; ...#...#  #.......
                            .byte $11 ; ...#...#  ##......
                            .byte $12 ; ...#..#.  ........
                            .byte $12 ; ...#..#.  .#......
                            .byte $12 ; ...#..#.  #.......
                            .byte $12 ; ...#..#.  ##......
                            .byte $13 ; ...#..##  ........
                            .byte $13 ; ...#..##  .#......
                            .byte $13 ; ...#..##  #.......
                            .byte $13 ; ...#..##  ##......
                            .byte $14 ; ...#.#..  ........
                            .byte $14 ; ...#.#..  .#......
                            .byte $14 ; ...#.#..  #.......
                            .byte $14 ; ...#.#..  ##......
                            .byte $15 ; ...#.#.#  ........
                            .byte $15 ; ...#.#.#  .#......
                            .byte $15 ; ...#.#.#  #.......
                            .byte $15 ; ...#.#.#  ##......
                            .byte $16 ; ...#.##.  ........
                            .byte $16 ; ...#.##.  .#......
                            .byte $16 ; ...#.##.  #.......
                            .byte $16 ; ...#.##.  ##......
                            .byte $17 ; ...#.###  ........
                            .byte $17 ; ...#.###  .#......
                            .byte $17 ; ...#.###  #.......
                            .byte $17 ; ...#.###  ##......
                            .byte $18 ; ...##...  ........
                            .byte $18 ; ...##...  .#......
                            .byte $18 ; ...##...  #.......
                            .byte $18 ; ...##...  ##......
                            .byte $19 ; ...##..#  ........
                            .byte $19 ; ...##..#  .#......
                            .byte $19 ; ...##..#  #.......
                            .byte $19 ; ...##..#  ##......
                            .byte $1a ; ...##.#.  ........
                            .byte $1a ; ...##.#.  .#......
                            .byte $1a ; ...##.#.  #.......
                            .byte $1a ; ...##.#.  ##......
                            .byte $1b ; ...##.##  ........
                            .byte $1b ; ...##.##  .#......
                            .byte $1b ; ...##.##  #.......
                            .byte $1b ; ...##.##  ##......
                            .byte $1c ; ...###..  ........
                            .byte $1c ; ...###..  .#......
                            .byte $1c ; ...###..  #.......
                            .byte $1c ; ...###..  ##......
                            .byte $1d ; ...###.#  ........
                            .byte $1d ; ...###.#  .#......
                            .byte $1d ; ...###.#  #.......
                            .byte $1d ; ...###.#  ##......
                            .byte $1e ; ...####.  ........
                            .byte $1e ; ...####.  .#......
                            .byte $1e ; ...####.  #.......
                            .byte $1e ; ...####.  ##......
                            .byte $1f ; ...#####  ........
                            .byte $1f ; ...#####  .#......
                            .byte $1f ; ...#####  #.......
                            .byte $1f ; ...#####  ##......
                            .byte $20 ; ..#.....  ........
                            .byte $20 ; ..#.....  .#......
                            .byte $20 ; ..#.....  #.......
                            .byte $20 ; ..#.....  ##......
                            .byte $21 ; ..#....#  ........
                            .byte $21 ; ..#....#  .#......
                            .byte $21 ; ..#....#  #.......
                            .byte $21 ; ..#....#  ##......
                            .byte $22 ; ..#...#.  ........
                            .byte $22 ; ..#...#.  .#......
                            .byte $22 ; ..#...#.  #.......
                            .byte $22 ; ..#...#.  ##......
                            .byte $23 ; ..#...##  ........
                            .byte $23 ; ..#...##  .#......
                            .byte $23 ; ..#...##  #.......
                            .byte $23 ; ..#...##  ##......
                            .byte $24 ; ..#..#..  ........
                            .byte $24 ; ..#..#..  .#......
                            .byte $24 ; ..#..#..  #.......
                            .byte $24 ; ..#..#..  ##......
                            .byte $25 ; ..#..#.#  ........
                            .byte $25 ; ..#..#.#  .#......
                            .byte $25 ; ..#..#.#  #.......
                            .byte $25 ; ..#..#.#  ##......
                            .byte $26 ; ..#..##.  ........
                            .byte $26 ; ..#..##.  .#......
                            .byte $26 ; ..#..##.  #.......
                            .byte $26 ; ..#..##.  ##......
                            .byte $27 ; ..#..###  ........
                            .byte $27 ; ..#..###  .#......
                            .byte $27 ; ..#..###  #.......
                            .byte $27 ; ..#..###  ##......
                            .byte $28 ; ..#.#...  ........
                            .byte $28 ; ..#.#...  .#......
                            .byte $28 ; ..#.#...  #.......
                            .byte $28 ; ..#.#...  ##......
                            .byte $29 ; ..#.#..#  ........
                            .byte $29 ; ..#.#..#  .#......
                            .byte $29 ; ..#.#..#  #.......
                            .byte $29 ; ..#.#..#  ##......
                            .byte $2a ; ..#.#.#.  ........
                            .byte $2a ; ..#.#.#.  .#......
                            .byte $2a ; ..#.#.#.  #.......
                            .byte $2a ; ..#.#.#.  ##......
                            .byte $2b ; ..#.#.##  ........
                            .byte $2b ; ..#.#.##  .#......
                            .byte $2b ; ..#.#.##  #.......
                            .byte $2b ; ..#.#.##  ##......
                            .byte $2c ; ..#.##..  ........
                            .byte $2c ; ..#.##..  .#......
                            .byte $2c ; ..#.##..  #.......
                            .byte $2c ; ..#.##..  ##......
                            .byte $2d ; ..#.##.#  ........
                            .byte $2d ; ..#.##.#  .#......
                            .byte $2d ; ..#.##.#  #.......
                            .byte $2d ; ..#.##.#  ##......
                            .byte $2e ; ..#.###.  ........
                            .byte $2e ; ..#.###.  .#......
                            .byte $2e ; ..#.###.  #.......
                            .byte $2e ; ..#.###.  ##......
                            .byte $2f ; ..#.####  ........
                            .byte $2f ; ..#.####  .#......
                            .byte $2f ; ..#.####  #.......
                            .byte $2f ; ..#.####  ##......
                            .byte $30 ; ..##....  ........
                            .byte $30 ; ..##....  .#......
                            .byte $30 ; ..##....  #.......
                            .byte $30 ; ..##....  ##......
                            .byte $31 ; ..##...#  ........
                            .byte $31 ; ..##...#  .#......
                            .byte $31 ; ..##...#  #.......
                            .byte $31 ; ..##...#  ##......
                            .byte $32 ; ..##..#.  ........
                            .byte $32 ; ..##..#.  .#......
                            .byte $32 ; ..##..#.  #.......
                            .byte $32 ; ..##..#.  ##......
                            .byte $33 ; ..##..##  ........
                            .byte $33 ; ..##..##  .#......
                            .byte $33 ; ..##..##  #.......
                            .byte $33 ; ..##..##  ##......
                            .byte $34 ; ..##.#..  ........
                            .byte $34 ; ..##.#..  .#......
                            .byte $34 ; ..##.#..  #.......
                            .byte $34 ; ..##.#..  ##......
                            .byte $35 ; ..##.#.#  ........
                            .byte $35 ; ..##.#.#  .#......
                            .byte $35 ; ..##.#.#  #.......
                            .byte $35 ; ..##.#.#  ##......
                            .byte $36 ; ..##.##.  ........
                            .byte $36 ; ..##.##.  .#......
                            .byte $36 ; ..##.##.  #.......
                            .byte $36 ; ..##.##.  ##......
                            .byte $37 ; ..##.###  ........
                            .byte $37 ; ..##.###  .#......
                            .byte $37 ; ..##.###  #.......
                            .byte $37 ; ..##.###  ##......
                            .byte $38 ; ..###...  ........
                            .byte $38 ; ..###...  .#......
                            .byte $38 ; ..###...  #.......
                            .byte $38 ; ..###...  ##......
                            .byte $39 ; ..###..#  ........
                            .byte $39 ; ..###..#  .#......
                            .byte $39 ; ..###..#  #.......
                            .byte $39 ; ..###..#  ##......
                            .byte $3a ; ..###.#.  ........
                            .byte $3a ; ..###.#.  .#......
                            .byte $3a ; ..###.#.  #.......
                            .byte $3a ; ..###.#.  ##......
                            .byte $3b ; ..###.##  ........
                            .byte $3b ; ..###.##  .#......
                            .byte $3b ; ..###.##  #.......
                            .byte $3b ; ..###.##  ##......
                            .byte $3c ; ..####..  ........
                            .byte $3c ; ..####..  .#......
                            .byte $3c ; ..####..  #.......
                            .byte $3c ; ..####..  ##......
                            .byte $3d ; ..####.#  ........
                            .byte $3d ; ..####.#  .#......
                            .byte $3d ; ..####.#  #.......
                            .byte $3d ; ..####.#  ##......
                            .byte $3e ; ..#####.  ........
                            .byte $3e ; ..#####.  .#......
                            .byte $3e ; ..#####.  #.......
                            .byte $3e ; ..#####.  ##......
                            .byte $3f ; ..######  ........
                            .byte $3f ; ..######  .#......
                            .byte $3f ; ..######  #.......
                            .byte $3f ; ..######  ##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_02_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_03_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  ...#....
                            .byte $00 ; ........  ..#.....
                            .byte $00 ; ........  ..##....
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  .#.#....
                            .byte $00 ; ........  .##.....
                            .byte $00 ; ........  .###....
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  #..#....
                            .byte $00 ; ........  #.#.....
                            .byte $00 ; ........  #.##....
                            .byte $00 ; ........  ##......
                            .byte $00 ; ........  ##.#....
                            .byte $00 ; ........  ###.....
                            .byte $00 ; ........  ####....
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  ...#....
                            .byte $01 ; .......#  ..#.....
                            .byte $01 ; .......#  ..##....
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  .#.#....
                            .byte $01 ; .......#  .##.....
                            .byte $01 ; .......#  .###....
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  #..#....
                            .byte $01 ; .......#  #.#.....
                            .byte $01 ; .......#  #.##....
                            .byte $01 ; .......#  ##......
                            .byte $01 ; .......#  ##.#....
                            .byte $01 ; .......#  ###.....
                            .byte $01 ; .......#  ####....
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  ...#....
                            .byte $02 ; ......#.  ..#.....
                            .byte $02 ; ......#.  ..##....
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  .#.#....
                            .byte $02 ; ......#.  .##.....
                            .byte $02 ; ......#.  .###....
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  #..#....
                            .byte $02 ; ......#.  #.#.....
                            .byte $02 ; ......#.  #.##....
                            .byte $02 ; ......#.  ##......
                            .byte $02 ; ......#.  ##.#....
                            .byte $02 ; ......#.  ###.....
                            .byte $02 ; ......#.  ####....
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  ...#....
                            .byte $03 ; ......##  ..#.....
                            .byte $03 ; ......##  ..##....
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  .#.#....
                            .byte $03 ; ......##  .##.....
                            .byte $03 ; ......##  .###....
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  #..#....
                            .byte $03 ; ......##  #.#.....
                            .byte $03 ; ......##  #.##....
                            .byte $03 ; ......##  ##......
                            .byte $03 ; ......##  ##.#....
                            .byte $03 ; ......##  ###.....
                            .byte $03 ; ......##  ####....
                            .byte $04 ; .....#..  ........
                            .byte $04 ; .....#..  ...#....
                            .byte $04 ; .....#..  ..#.....
                            .byte $04 ; .....#..  ..##....
                            .byte $04 ; .....#..  .#......
                            .byte $04 ; .....#..  .#.#....
                            .byte $04 ; .....#..  .##.....
                            .byte $04 ; .....#..  .###....
                            .byte $04 ; .....#..  #.......
                            .byte $04 ; .....#..  #..#....
                            .byte $04 ; .....#..  #.#.....
                            .byte $04 ; .....#..  #.##....
                            .byte $04 ; .....#..  ##......
                            .byte $04 ; .....#..  ##.#....
                            .byte $04 ; .....#..  ###.....
                            .byte $04 ; .....#..  ####....
                            .byte $05 ; .....#.#  ........
                            .byte $05 ; .....#.#  ...#....
                            .byte $05 ; .....#.#  ..#.....
                            .byte $05 ; .....#.#  ..##....
                            .byte $05 ; .....#.#  .#......
                            .byte $05 ; .....#.#  .#.#....
                            .byte $05 ; .....#.#  .##.....
                            .byte $05 ; .....#.#  .###....
                            .byte $05 ; .....#.#  #.......
                            .byte $05 ; .....#.#  #..#....
                            .byte $05 ; .....#.#  #.#.....
                            .byte $05 ; .....#.#  #.##....
                            .byte $05 ; .....#.#  ##......
                            .byte $05 ; .....#.#  ##.#....
                            .byte $05 ; .....#.#  ###.....
                            .byte $05 ; .....#.#  ####....
                            .byte $06 ; .....##.  ........
                            .byte $06 ; .....##.  ...#....
                            .byte $06 ; .....##.  ..#.....
                            .byte $06 ; .....##.  ..##....
                            .byte $06 ; .....##.  .#......
                            .byte $06 ; .....##.  .#.#....
                            .byte $06 ; .....##.  .##.....
                            .byte $06 ; .....##.  .###....
                            .byte $06 ; .....##.  #.......
                            .byte $06 ; .....##.  #..#....
                            .byte $06 ; .....##.  #.#.....
                            .byte $06 ; .....##.  #.##....
                            .byte $06 ; .....##.  ##......
                            .byte $06 ; .....##.  ##.#....
                            .byte $06 ; .....##.  ###.....
                            .byte $06 ; .....##.  ####....
                            .byte $07 ; .....###  ........
                            .byte $07 ; .....###  ...#....
                            .byte $07 ; .....###  ..#.....
                            .byte $07 ; .....###  ..##....
                            .byte $07 ; .....###  .#......
                            .byte $07 ; .....###  .#.#....
                            .byte $07 ; .....###  .##.....
                            .byte $07 ; .....###  .###....
                            .byte $07 ; .....###  #.......
                            .byte $07 ; .....###  #..#....
                            .byte $07 ; .....###  #.#.....
                            .byte $07 ; .....###  #.##....
                            .byte $07 ; .....###  ##......
                            .byte $07 ; .....###  ##.#....
                            .byte $07 ; .....###  ###.....
                            .byte $07 ; .....###  ####....
                            .byte $08 ; ....#...  ........
                            .byte $08 ; ....#...  ...#....
                            .byte $08 ; ....#...  ..#.....
                            .byte $08 ; ....#...  ..##....
                            .byte $08 ; ....#...  .#......
                            .byte $08 ; ....#...  .#.#....
                            .byte $08 ; ....#...  .##.....
                            .byte $08 ; ....#...  .###....
                            .byte $08 ; ....#...  #.......
                            .byte $08 ; ....#...  #..#....
                            .byte $08 ; ....#...  #.#.....
                            .byte $08 ; ....#...  #.##....
                            .byte $08 ; ....#...  ##......
                            .byte $08 ; ....#...  ##.#....
                            .byte $08 ; ....#...  ###.....
                            .byte $08 ; ....#...  ####....
                            .byte $09 ; ....#..#  ........
                            .byte $09 ; ....#..#  ...#....
                            .byte $09 ; ....#..#  ..#.....
                            .byte $09 ; ....#..#  ..##....
                            .byte $09 ; ....#..#  .#......
                            .byte $09 ; ....#..#  .#.#....
                            .byte $09 ; ....#..#  .##.....
                            .byte $09 ; ....#..#  .###....
                            .byte $09 ; ....#..#  #.......
                            .byte $09 ; ....#..#  #..#....
                            .byte $09 ; ....#..#  #.#.....
                            .byte $09 ; ....#..#  #.##....
                            .byte $09 ; ....#..#  ##......
                            .byte $09 ; ....#..#  ##.#....
                            .byte $09 ; ....#..#  ###.....
                            .byte $09 ; ....#..#  ####....
                            .byte $0a ; ....#.#.  ........
                            .byte $0a ; ....#.#.  ...#....
                            .byte $0a ; ....#.#.  ..#.....
                            .byte $0a ; ....#.#.  ..##....
                            .byte $0a ; ....#.#.  .#......
                            .byte $0a ; ....#.#.  .#.#....
                            .byte $0a ; ....#.#.  .##.....
                            .byte $0a ; ....#.#.  .###....
                            .byte $0a ; ....#.#.  #.......
                            .byte $0a ; ....#.#.  #..#....
                            .byte $0a ; ....#.#.  #.#.....
                            .byte $0a ; ....#.#.  #.##....
                            .byte $0a ; ....#.#.  ##......
                            .byte $0a ; ....#.#.  ##.#....
                            .byte $0a ; ....#.#.  ###.....
                            .byte $0a ; ....#.#.  ####....
                            .byte $0b ; ....#.##  ........
                            .byte $0b ; ....#.##  ...#....
                            .byte $0b ; ....#.##  ..#.....
                            .byte $0b ; ....#.##  ..##....
                            .byte $0b ; ....#.##  .#......
                            .byte $0b ; ....#.##  .#.#....
                            .byte $0b ; ....#.##  .##.....
                            .byte $0b ; ....#.##  .###....
                            .byte $0b ; ....#.##  #.......
                            .byte $0b ; ....#.##  #..#....
                            .byte $0b ; ....#.##  #.#.....
                            .byte $0b ; ....#.##  #.##....
                            .byte $0b ; ....#.##  ##......
                            .byte $0b ; ....#.##  ##.#....
                            .byte $0b ; ....#.##  ###.....
                            .byte $0b ; ....#.##  ####....
                            .byte $0c ; ....##..  ........
                            .byte $0c ; ....##..  ...#....
                            .byte $0c ; ....##..  ..#.....
                            .byte $0c ; ....##..  ..##....
                            .byte $0c ; ....##..  .#......
                            .byte $0c ; ....##..  .#.#....
                            .byte $0c ; ....##..  .##.....
                            .byte $0c ; ....##..  .###....
                            .byte $0c ; ....##..  #.......
                            .byte $0c ; ....##..  #..#....
                            .byte $0c ; ....##..  #.#.....
                            .byte $0c ; ....##..  #.##....
                            .byte $0c ; ....##..  ##......
                            .byte $0c ; ....##..  ##.#....
                            .byte $0c ; ....##..  ###.....
                            .byte $0c ; ....##..  ####....
                            .byte $0d ; ....##.#  ........
                            .byte $0d ; ....##.#  ...#....
                            .byte $0d ; ....##.#  ..#.....
                            .byte $0d ; ....##.#  ..##....
                            .byte $0d ; ....##.#  .#......
                            .byte $0d ; ....##.#  .#.#....
                            .byte $0d ; ....##.#  .##.....
                            .byte $0d ; ....##.#  .###....
                            .byte $0d ; ....##.#  #.......
                            .byte $0d ; ....##.#  #..#....
                            .byte $0d ; ....##.#  #.#.....
                            .byte $0d ; ....##.#  #.##....
                            .byte $0d ; ....##.#  ##......
                            .byte $0d ; ....##.#  ##.#....
                            .byte $0d ; ....##.#  ###.....
                            .byte $0d ; ....##.#  ####....
                            .byte $0e ; ....###.  ........
                            .byte $0e ; ....###.  ...#....
                            .byte $0e ; ....###.  ..#.....
                            .byte $0e ; ....###.  ..##....
                            .byte $0e ; ....###.  .#......
                            .byte $0e ; ....###.  .#.#....
                            .byte $0e ; ....###.  .##.....
                            .byte $0e ; ....###.  .###....
                            .byte $0e ; ....###.  #.......
                            .byte $0e ; ....###.  #..#....
                            .byte $0e ; ....###.  #.#.....
                            .byte $0e ; ....###.  #.##....
                            .byte $0e ; ....###.  ##......
                            .byte $0e ; ....###.  ##.#....
                            .byte $0e ; ....###.  ###.....
                            .byte $0e ; ....###.  ####....
                            .byte $0f ; ....####  ........
                            .byte $0f ; ....####  ...#....
                            .byte $0f ; ....####  ..#.....
                            .byte $0f ; ....####  ..##....
                            .byte $0f ; ....####  .#......
                            .byte $0f ; ....####  .#.#....
                            .byte $0f ; ....####  .##.....
                            .byte $0f ; ....####  .###....
                            .byte $0f ; ....####  #.......
                            .byte $0f ; ....####  #..#....
                            .byte $0f ; ....####  #.#.....
                            .byte $0f ; ....####  #.##....
                            .byte $0f ; ....####  ##......
                            .byte $0f ; ....####  ##.#....
                            .byte $0f ; ....####  ###.....
                            .byte $0f ; ....####  ####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_03_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_04_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  .....#..
                            .byte $00 ; ........  ....#...
                            .byte $00 ; ........  ....##..
                            .byte $00 ; ........  ...#....
                            .byte $00 ; ........  ...#.#..
                            .byte $00 ; ........  ...##...
                            .byte $00 ; ........  ...###..
                            .byte $00 ; ........  ..#.....
                            .byte $00 ; ........  ..#..#..
                            .byte $00 ; ........  ..#.#...
                            .byte $00 ; ........  ..#.##..
                            .byte $00 ; ........  ..##....
                            .byte $00 ; ........  ..##.#..
                            .byte $00 ; ........  ..###...
                            .byte $00 ; ........  ..####..
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  .#...#..
                            .byte $00 ; ........  .#..#...
                            .byte $00 ; ........  .#..##..
                            .byte $00 ; ........  .#.#....
                            .byte $00 ; ........  .#.#.#..
                            .byte $00 ; ........  .#.##...
                            .byte $00 ; ........  .#.###..
                            .byte $00 ; ........  .##.....
                            .byte $00 ; ........  .##..#..
                            .byte $00 ; ........  .##.#...
                            .byte $00 ; ........  .##.##..
                            .byte $00 ; ........  .###....
                            .byte $00 ; ........  .###.#..
                            .byte $00 ; ........  .####...
                            .byte $00 ; ........  .#####..
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  #....#..
                            .byte $00 ; ........  #...#...
                            .byte $00 ; ........  #...##..
                            .byte $00 ; ........  #..#....
                            .byte $00 ; ........  #..#.#..
                            .byte $00 ; ........  #..##...
                            .byte $00 ; ........  #..###..
                            .byte $00 ; ........  #.#.....
                            .byte $00 ; ........  #.#..#..
                            .byte $00 ; ........  #.#.#...
                            .byte $00 ; ........  #.#.##..
                            .byte $00 ; ........  #.##....
                            .byte $00 ; ........  #.##.#..
                            .byte $00 ; ........  #.###...
                            .byte $00 ; ........  #.####..
                            .byte $00 ; ........  ##......
                            .byte $00 ; ........  ##...#..
                            .byte $00 ; ........  ##..#...
                            .byte $00 ; ........  ##..##..
                            .byte $00 ; ........  ##.#....
                            .byte $00 ; ........  ##.#.#..
                            .byte $00 ; ........  ##.##...
                            .byte $00 ; ........  ##.###..
                            .byte $00 ; ........  ###.....
                            .byte $00 ; ........  ###..#..
                            .byte $00 ; ........  ###.#...
                            .byte $00 ; ........  ###.##..
                            .byte $00 ; ........  ####....
                            .byte $00 ; ........  ####.#..
                            .byte $00 ; ........  #####...
                            .byte $00 ; ........  ######..
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  .....#..
                            .byte $01 ; .......#  ....#...
                            .byte $01 ; .......#  ....##..
                            .byte $01 ; .......#  ...#....
                            .byte $01 ; .......#  ...#.#..
                            .byte $01 ; .......#  ...##...
                            .byte $01 ; .......#  ...###..
                            .byte $01 ; .......#  ..#.....
                            .byte $01 ; .......#  ..#..#..
                            .byte $01 ; .......#  ..#.#...
                            .byte $01 ; .......#  ..#.##..
                            .byte $01 ; .......#  ..##....
                            .byte $01 ; .......#  ..##.#..
                            .byte $01 ; .......#  ..###...
                            .byte $01 ; .......#  ..####..
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  .#...#..
                            .byte $01 ; .......#  .#..#...
                            .byte $01 ; .......#  .#..##..
                            .byte $01 ; .......#  .#.#....
                            .byte $01 ; .......#  .#.#.#..
                            .byte $01 ; .......#  .#.##...
                            .byte $01 ; .......#  .#.###..
                            .byte $01 ; .......#  .##.....
                            .byte $01 ; .......#  .##..#..
                            .byte $01 ; .......#  .##.#...
                            .byte $01 ; .......#  .##.##..
                            .byte $01 ; .......#  .###....
                            .byte $01 ; .......#  .###.#..
                            .byte $01 ; .......#  .####...
                            .byte $01 ; .......#  .#####..
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  #....#..
                            .byte $01 ; .......#  #...#...
                            .byte $01 ; .......#  #...##..
                            .byte $01 ; .......#  #..#....
                            .byte $01 ; .......#  #..#.#..
                            .byte $01 ; .......#  #..##...
                            .byte $01 ; .......#  #..###..
                            .byte $01 ; .......#  #.#.....
                            .byte $01 ; .......#  #.#..#..
                            .byte $01 ; .......#  #.#.#...
                            .byte $01 ; .......#  #.#.##..
                            .byte $01 ; .......#  #.##....
                            .byte $01 ; .......#  #.##.#..
                            .byte $01 ; .......#  #.###...
                            .byte $01 ; .......#  #.####..
                            .byte $01 ; .......#  ##......
                            .byte $01 ; .......#  ##...#..
                            .byte $01 ; .......#  ##..#...
                            .byte $01 ; .......#  ##..##..
                            .byte $01 ; .......#  ##.#....
                            .byte $01 ; .......#  ##.#.#..
                            .byte $01 ; .......#  ##.##...
                            .byte $01 ; .......#  ##.###..
                            .byte $01 ; .......#  ###.....
                            .byte $01 ; .......#  ###..#..
                            .byte $01 ; .......#  ###.#...
                            .byte $01 ; .......#  ###.##..
                            .byte $01 ; .......#  ####....
                            .byte $01 ; .......#  ####.#..
                            .byte $01 ; .......#  #####...
                            .byte $01 ; .......#  ######..
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  .....#..
                            .byte $02 ; ......#.  ....#...
                            .byte $02 ; ......#.  ....##..
                            .byte $02 ; ......#.  ...#....
                            .byte $02 ; ......#.  ...#.#..
                            .byte $02 ; ......#.  ...##...
                            .byte $02 ; ......#.  ...###..
                            .byte $02 ; ......#.  ..#.....
                            .byte $02 ; ......#.  ..#..#..
                            .byte $02 ; ......#.  ..#.#...
                            .byte $02 ; ......#.  ..#.##..
                            .byte $02 ; ......#.  ..##....
                            .byte $02 ; ......#.  ..##.#..
                            .byte $02 ; ......#.  ..###...
                            .byte $02 ; ......#.  ..####..
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  .#...#..
                            .byte $02 ; ......#.  .#..#...
                            .byte $02 ; ......#.  .#..##..
                            .byte $02 ; ......#.  .#.#....
                            .byte $02 ; ......#.  .#.#.#..
                            .byte $02 ; ......#.  .#.##...
                            .byte $02 ; ......#.  .#.###..
                            .byte $02 ; ......#.  .##.....
                            .byte $02 ; ......#.  .##..#..
                            .byte $02 ; ......#.  .##.#...
                            .byte $02 ; ......#.  .##.##..
                            .byte $02 ; ......#.  .###....
                            .byte $02 ; ......#.  .###.#..
                            .byte $02 ; ......#.  .####...
                            .byte $02 ; ......#.  .#####..
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  #....#..
                            .byte $02 ; ......#.  #...#...
                            .byte $02 ; ......#.  #...##..
                            .byte $02 ; ......#.  #..#....
                            .byte $02 ; ......#.  #..#.#..
                            .byte $02 ; ......#.  #..##...
                            .byte $02 ; ......#.  #..###..
                            .byte $02 ; ......#.  #.#.....
                            .byte $02 ; ......#.  #.#..#..
                            .byte $02 ; ......#.  #.#.#...
                            .byte $02 ; ......#.  #.#.##..
                            .byte $02 ; ......#.  #.##....
                            .byte $02 ; ......#.  #.##.#..
                            .byte $02 ; ......#.  #.###...
                            .byte $02 ; ......#.  #.####..
                            .byte $02 ; ......#.  ##......
                            .byte $02 ; ......#.  ##...#..
                            .byte $02 ; ......#.  ##..#...
                            .byte $02 ; ......#.  ##..##..
                            .byte $02 ; ......#.  ##.#....
                            .byte $02 ; ......#.  ##.#.#..
                            .byte $02 ; ......#.  ##.##...
                            .byte $02 ; ......#.  ##.###..
                            .byte $02 ; ......#.  ###.....
                            .byte $02 ; ......#.  ###..#..
                            .byte $02 ; ......#.  ###.#...
                            .byte $02 ; ......#.  ###.##..
                            .byte $02 ; ......#.  ####....
                            .byte $02 ; ......#.  ####.#..
                            .byte $02 ; ......#.  #####...
                            .byte $02 ; ......#.  ######..
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  .....#..
                            .byte $03 ; ......##  ....#...
                            .byte $03 ; ......##  ....##..
                            .byte $03 ; ......##  ...#....
                            .byte $03 ; ......##  ...#.#..
                            .byte $03 ; ......##  ...##...
                            .byte $03 ; ......##  ...###..
                            .byte $03 ; ......##  ..#.....
                            .byte $03 ; ......##  ..#..#..
                            .byte $03 ; ......##  ..#.#...
                            .byte $03 ; ......##  ..#.##..
                            .byte $03 ; ......##  ..##....
                            .byte $03 ; ......##  ..##.#..
                            .byte $03 ; ......##  ..###...
                            .byte $03 ; ......##  ..####..
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  .#...#..
                            .byte $03 ; ......##  .#..#...
                            .byte $03 ; ......##  .#..##..
                            .byte $03 ; ......##  .#.#....
                            .byte $03 ; ......##  .#.#.#..
                            .byte $03 ; ......##  .#.##...
                            .byte $03 ; ......##  .#.###..
                            .byte $03 ; ......##  .##.....
                            .byte $03 ; ......##  .##..#..
                            .byte $03 ; ......##  .##.#...
                            .byte $03 ; ......##  .##.##..
                            .byte $03 ; ......##  .###....
                            .byte $03 ; ......##  .###.#..
                            .byte $03 ; ......##  .####...
                            .byte $03 ; ......##  .#####..
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  #....#..
                            .byte $03 ; ......##  #...#...
                            .byte $03 ; ......##  #...##..
                            .byte $03 ; ......##  #..#....
                            .byte $03 ; ......##  #..#.#..
                            .byte $03 ; ......##  #..##...
                            .byte $03 ; ......##  #..###..
                            .byte $03 ; ......##  #.#.....
                            .byte $03 ; ......##  #.#..#..
                            .byte $03 ; ......##  #.#.#...
                            .byte $03 ; ......##  #.#.##..
                            .byte $03 ; ......##  #.##....
                            .byte $03 ; ......##  #.##.#..
                            .byte $03 ; ......##  #.###...
                            .byte $03 ; ......##  #.####..
                            .byte $03 ; ......##  ##......
                            .byte $03 ; ......##  ##...#..
                            .byte $03 ; ......##  ##..#...
                            .byte $03 ; ......##  ##..##..
                            .byte $03 ; ......##  ##.#....
                            .byte $03 ; ......##  ##.#.#..
                            .byte $03 ; ......##  ##.##...
                            .byte $03 ; ......##  ##.###..
                            .byte $03 ; ......##  ###.....
                            .byte $03 ; ......##  ###..#..
                            .byte $03 ; ......##  ###.#...
                            .byte $03 ; ......##  ###.##..
                            .byte $03 ; ......##  ####....
                            .byte $03 ; ......##  ####.#..
                            .byte $03 ; ......##  #####...
                            .byte $03 ; ......##  ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_04_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
; --------------------------------------------------------------------------------------------------------------------- ;
; table image data offsets for image rows $00-$0a and imges form $00-$67
; --------------------------------------------------------------------------------------------------------------------- ;
; to construct a image
;   select the image number row
;   pick up the data bytes from TabImageData with each of the row offsets 
;     image row byte 1 - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len
;     image row byte 2 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len       - part 1 - combined with part 2
;                      - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len * $02 - part 2
;     image row byte 3 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff             = *       ; image data offsets
; .---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------.
; ! row $00 ! row $01 ! row $02 ! row $03 ! row $04 ! row $05 ! row $06 ! row $07 ! row $08 ! row $09 ! row $0a ! image number                !
; +---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------+
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00 - Level Tile Blank      !
; ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $01 - Level Tile WallWeak   +
; ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $02 - Level Tile WallHard   !
; ! $c3-$00 ! $c3-$00 ! $ff-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $ff-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $03 - Level Tile Ladder     !
; ! $00-$00 ! $ff-$c0 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04 - Level Tile Pole       !
; ! $aa-$80 ! $aa-$80 ! $00-$00 ! $3f-$00 ! $0c-$00 ! $0c-$00 ! $0c-$00 ! $0c-$00 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $05 - Level Tile WallTrap   !
; ! $c0-$00 ! $c0-$00 ! $ff-$00 ! $c3-$00 ! $03-$00 ! $03-$00 ! $03-$00 ! $c3-$00 ! $ff-$00 ! $c0-$00 ! $c0-$00 ! $06 - Level Tile LadderSec  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $ff-$00 ! $eb-$00 ! $eb-$00 ! $eb-$00 ! $ff-$00 ! $00-$00 ! $07 - Level Tile Gold       !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $15-$00 ! $44-$40 ! $06-$00 ! $15-$00 ! $15-$40 ! $10-$00 ! $10-$00 ! $08 - Level Tile Enemy      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $0e-$00 ! $37-$00 ! $6c-$c0 ! $0c-$00 ! $0e-$00 ! $7b-$00 ! $03-$00 ! $03-$00 ! $09 - Level Tile LodeRunner !
; ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $0a - Blank Reverse         !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $1c-$00 ! $3b-$00 ! $cd-$80 ! $0c-$00 ! $1c-$00 ! $37-$80 ! $30-$00 ! $30-$00 ! $0b - Sprite Run Le 00      !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $18-$00 ! $1c-$00 ! $3e-$00 ! $de-$00 ! $38-$00 ! $3c-$00 ! $0e-$00 ! $0c-$00 ! $0c - Sprite Run Le 01      !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $18-$00 ! $5e-$00 ! $7b-$00 ! $18-$00 ! $3c-$00 ! $66-$00 ! $63-$00 ! $03-$00 ! $0d - Sprite Run Le 02      !
; ! $0c-$00 ! $0c-$40 ! $0f-$c0 ! $4e-$00 ! $7e-$00 ! $0e-$00 ! $0e-$00 ! $1b-$00 ! $1b-$80 ! $18-$00 ! $38-$00 ! $0e - Sprite Ladder 00      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $03-$00 ! $0f-$c0 ! $5b-$40 ! $43-$00 ! $07-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $0f - Sprite Fire Le        !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $06-$00 ! $0e-$00 ! $1f-$00 ! $1e-$c0 ! $07-$00 ! $0f-$00 ! $1c-$00 ! $0c-$00 ! $10 - Sprite Run Ri 00      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $06-$00 ! $1e-$80 ! $37-$80 ! $06-$00 ! $0f-$00 ! $19-$80 ! $31-$80 ! $30-$00 ! $11 - Sprite Run Ri 01      !
; ! $0c-$00 ! $8c-$00 ! $fc-$00 ! $1c-$80 ! $1f-$80 ! $1c-$00 ! $1c-$00 ! $36-$00 ! $76-$00 ! $06-$00 ! $07-$00 ! $12 - Sprite Run Ri 02      !
; ! $64-$c0 ! $6e-$c0 ! $6e-$c0 ! $3f-$80 ! $06-$00 ! $06-$00 ! $1e-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $06-$00 ! $13 - Sprite Fall Le        !
; ! $c9-$80 ! $dd-$80 ! $dd-$80 ! $7f-$00 ! $18-$00 ! $18-$00 ! $1e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $18-$00 ! $14 - Sprite Fall Ri        !
; ! $61-$80 ! $61-$80 ! $6d-$80 ! $6f-$00 ! $3c-$00 ! $18-$00 ! $18-$00 ! $78-$00 ! $d8-$00 ! $d8-$00 ! $b0-$00 ! $15 - Sprite Pole Ri 00     !
; ! $06-$00 ! $06-$00 ! $1e-$00 ! $1c-$00 ! $78-$00 ! $d8-$00 ! $18-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $6c-$00 ! $16 - Sprite Pole Ri 01     !
; ! $18-$00 ! $18-$00 ! $1e-$00 ! $0e-$c0 ! $07-$80 ! $06-$00 ! $06-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $17 - Sprite Pole Ri 02     !
; ! $61-$80 ! $61-$80 ! $6d-$80 ! $3d-$80 ! $0f-$00 ! $06-$00 ! $06-$00 ! $07-$80 ! $06-$c0 ! $06-$c0 ! $03-$40 ! $18 - Sprite Pole Le 00     !
; ! $18-$00 ! $18-$00 ! $1e-$00 ! $0e-$00 ! $07-$80 ! $06-$c0 ! $06-$00 ! $07-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $19 - Sprite Pole Le 01     !
; ! $06-$00 ! $06-$00 ! $1e-$00 ! $dc-$00 ! $78-$00 ! $18-$00 ! $18-$00 ! $1c-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $1a - Sprite Pole Le 02     !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $02-$40 ! $20-$40 ! $09-$00 ! $01-$00 ! $1b - Shoot Spark 00        !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $00-$80 ! $80-$00 ! $20-$00 ! $0a-$40 ! $21-$40 ! $09-$00 ! $1c - Shoot Spark 01        !
; ! $08-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $88-$00 ! $00-$80 ! $80-$00 ! $20-$00 ! $02-$00 ! $1d - Shoot Spark 02        !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $80-$00 ! $00-$00 ! $00-$80 ! $00-$00 ! $00-$00 ! $00-$00 ! $1e - Shoot Spark 03        !
; ! $a4-$80 ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $1f - Shoot Melt Ground 00  !
; ! $04-$00 ! $14-$00 ! $80-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $20 - Shoot Melt Ground 01  !
; ! $00-$00 ! $04-$00 ! $14-$00 ! $94-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $21 - Shoot Melt Ground 02  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $22 - Shoot Melt Ground 03  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $05-$00 ! $95-$00 ! $80-$00 ! $8a-$80 ! $00-$00 ! $23 - Shoot Melt Ground 04  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $00-$00 ! $24 - Shoot Melt Ground 05  !
; ! $08-$00 ! $1c-$00 ! $1c-$00 ! $18-$00 ! $7e-$00 ! $5b-$40 ! $18-$40 ! $1c-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $25 - Fire Ri               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $22-$00 ! $48-$00 ! $50-$80 ! $10-$00 ! $26 - Shoot Melt 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $00-$80 ! $a0-$00 ! $40-$00 ! $4a-$00 ! $11-$00 ! $11-$00 ! $27 - Shoot Melt 01         !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $15-$00 ! $44-$40 ! $0c-$00 ! $0e-$00 ! $7b-$00 ! $03-$00 ! $03-$00 ! $28 - Run Ri 00             !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $06-$40 ! $07-$00 ! $0f-$00 ! $1c-$00 ! $0c-$00 ! $29 - Run Ri 01             !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $15-$00 ! $45-$00 ! $06-$00 ! $0f-$00 ! $19-$80 ! $31-$80 ! $30-$00 ! $2a - Run Ri 02             !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $05-$00 ! $15-$00 ! $4c-$00 ! $1c-$00 ! $1e-$00 ! $07-$00 ! $06-$00 ! $2b - Run Le 01             !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $15-$00 ! $14-$40 ! $0c-$00 ! $1e-$00 ! $33-$00 ! $31-$80 ! $01-$80 ! $2c - Run Le 02             !
; ! $41-$00 ! $41-$00 ! $45-$00 ! $45-$00 ! $14-$00 ! $10-$00 ! $10-$00 ! $78-$00 ! $d8-$00 ! $d8-$00 ! $b0-$00 ! $2d - Pole Ri 00            !
; ! $04-$00 ! $04-$00 ! $14-$00 ! $14-$00 ! $50-$00 ! $50-$00 ! $10-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $0c-$00 ! $2e - Pole Ri 01            !
; ! $10-$00 ! $10-$00 ! $14-$00 ! $04-$40 ! $05-$00 ! $04-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $2f - Pole Ri 02            !
; ! $41-$00 ! $41-$00 ! $51-$00 ! $51-$00 ! $14-$00 ! $04-$00 ! $04-$00 ! $0f-$00 ! $0d-$80 ! $0d-$80 ! $06-$80 ! $30 - Pole Le 00            !
; ! $10-$00 ! $10-$00 ! $14-$00 ! $14-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $31 - Pole Le 01            !
; ! $04-$00 ! $04-$00 ! $14-$00 ! $10-$00 ! $50-$00 ! $10-$00 ! $10-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $6c-$00 ! $32 - Pole Le 02            !
; ! $04-$00 ! $04-$40 ! $05-$40 ! $44-$00 ! $54-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$80 ! $18-$00 ! $38-$00 ! $33 - Ladder  00            !
; ! $04-$00 ! $84-$00 ! $d4-$00 ! $14-$80 ! $15-$80 ! $14-$00 ! $1c-$00 ! $36-$00 ! $76-$00 ! $06-$00 ! $07-$00 ! $34 - Ladder  01            !
; ! $44-$40 ! $44-$40 ! $44-$40 ! $15-$00 ! $04-$00 ! $04-$00 ! $0f-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $0c-$00 ! $35 - Fall Ri               !
; ! $44-$40 ! $44-$40 ! $44-$40 ! $15-$00 ! $04-$00 ! $04-$00 ! $1e-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $06-$00 ! $36 - Fall Le               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$80 ! $80-$80 ! $00-$00 ! $37 - Close Hole 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$80 ! $80-$80 ! $80-$80 ! $80-$80 ! $00-$00 ! $38 - Close Hole 01         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $55-$00 ! $00-$00 ! $39 - Enemy Rebirth 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $55-$00 ! $55-$00 ! $00-$00 ! $3a - Enemy Rebirth 01         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $41-$00 ! $45-$00 ! $45-$00 ! $45-$00 ! $55-$00 ! $3b - Digit 0               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $04-$00 ! $04-$00 ! $04-$00 ! $15-$00 ! $15-$00 ! $3c - Digit 1               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $01-$00 ! $55-$00 ! $40-$00 ! $40-$00 ! $45-$00 ! $55-$00 ! $3d - Digit 2               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $01-$00 ! $15-$00 ! $01-$00 ! $01-$00 ! $41-$00 ! $55-$00 ! $3e - Digit 3               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $51-$00 ! $51-$00 ! $51-$00 ! $55-$00 ! $01-$00 ! $01-$00 ! $01-$00 ! $01-$00 ! $3f - Digit 4               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $40-$00 ! $40-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $55-$00 ! $40 - Digit 5               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $40-$00 ! $40-$00 ! $55-$00 ! $45-$00 ! $45-$00 ! $55-$00 ! $41 - Digit 6               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $14-$00 ! $10-$00 ! $10-$00 ! $10-$00 ! $42 - Digit 7               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $15-$00 ! $11-$00 ! $11-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $41-$00 ! $55-$00 ! $43 - Digit 8               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $44 - Digit 9               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $2a-$00 ! $22-$00 ! $22-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $8a-$00 ! $8a-$00 ! $45 - Char A                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a8-$00 ! $88-$00 ! $88-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $46 - Char B                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $80-$00 ! $a0-$00 ! $a0-$00 ! $a2-$00 ! $aa-$00 ! $47 - Char C                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a8-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a8-$00 ! $48 - Char D                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a8-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $aa-$00 ! $49 - Char E                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a8-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $4a - Char F                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $80-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $aa-$00 ! $4b - Char G                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $4c - Char H                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $20-$00 ! $20-$00 ! $20-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $4d - Char I                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $08-$00 ! $08-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $8a-$00 ! $aa-$00 ! $4e - Char J                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $8a-$00 ! $88-$00 ! $a8-$00 ! $aa-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $4f - Char K                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $aa-$00 ! $50 - Char L                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $a2-$00 ! $aa-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $51 - Char M                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $aa-$00 ! $aa-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $52 - Char N                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $53 - Char O                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $54 - Char P                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $88-$00 ! $a2-$00 ! $55 - Char Q                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a8-$00 ! $a8-$00 ! $a2-$00 ! $a2-$00 ! $56 - Char R                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $aa-$00 ! $0a-$00 ! $0a-$00 ! $8a-$00 ! $aa-$00 ! $57 - Char S                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $20-$00 ! $20-$00 ! $20-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $58 - Char T                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $aa-$00 ! $59 - Char U                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $aa-$00 ! $28-$00 ! $20-$00 ! $5a - Char V                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $aa-$00 ! $a2-$00 ! $82-$00 ! $5b - Char W                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $28-$00 ! $28-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $5c - Char X                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $8a-$00 ! $8a-$00 ! $8a-$00 ! $aa-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $5d - Char Y                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $08-$00 ! $28-$00 ! $80-$00 ! $8a-$00 ! $aa-$00 ! $5e - Char Z                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$00 ! $a0-$00 ! $28-$00 ! $0a-$00 ! $0a-$00 ! $28-$00 ! $a0-$00 ! $80-$00 ! $5f - Special Char  >       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $60 - Special Char  .       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $28-$00 ! $28-$00 ! $61 - Special Char  (       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $28-$00 ! $28-$00 ! $62 - Special Char  )       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $02-$00 ! $02-$00 ! $08-$00 ! $08-$00 ! $20-$00 ! $20-$00 ! $80-$00 ! $80-$00 ! $63 - Special Char  /       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $00-$00 ! $64 - Special Char  -       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $02-$00 ! $0a-$00 ! $28-$00 ! $a0-$00 ! $a0-$00 ! $28-$00 ! $0a-$00 ! $02-$00 ! $65 - Special Char  <       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $66 - Blank                 !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $67 - Blank                 !
; `---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------´
TabImageDataOff_R_00_B_01   = *       ; offset to image data row_00 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $08 ; $08 - Level Tile Enemy
                            .byte $02 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $10 ; $0b - Loderunner Run Le 00
                            .byte $10 ; $0c - Loderunner Run Le 01
                            .byte $10 ; $0d - Loderunner Run Le 02
                            .byte $0c ; $0e - Loderunner Ladder 00
                            .byte $02 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $02 ; $10 - Loderunner Run Ri 01
                            .byte $02 ; $11 - Loderunner Run Ri 02
                            .byte $0c ; $12 - Loderunner Ladder 01
                            .byte $64 ; $13 - Loderunner Fall Le
                            .byte $c9 ; $14 - Loderunner Fall Ri
                            .byte $61 ; $15 - Loderunner Pole Ri 00
                            .byte $06 ; $16 - Loderunner Pole Ri 01
                            .byte $18 ; $17 - Loderunner Pole Ri 02
                            .byte $61 ; $18 - Loderunner Pole Le 00
                            .byte $18 ; $19 - Loderunner Pole Le 01
                            .byte $06 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $08 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a4 ; $1f - Shoot Melt Ground 00
                            .byte $04 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $08 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $02 ; $28 - Enemy Run Ri 00
                            .byte $02 ; $29 - Enemy Run Ri 01
                            .byte $02 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $08 ; $2b - Enemy Run Le 01
                            .byte $08 ; $2c - Enemy Run Le 02
                            .byte $41 ; $2d - Enemy Pole Ri 00
                            .byte $04 ; $2e - Enemy Pole Ri 01
                            .byte $10 ; $2f - Enemy Pole Ri 02
                            .byte $41 ; $30 - Enemy Pole Le 00
                            .byte $10 ; $31 - Enemy Pole Le 01
                            .byte $04 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $04 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
TabImageDataOff_Len         = * - TabImageDataOff ; length of pointer table entry
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_00_B_02   = *       ; offset to image data row_00 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunnernner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_01_B_01   = *       ; offset to image data row_01 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $ff ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $14 ; $08 - Level Tile Enemy
                            .byte $07 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $38 ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $38 ; $0d - Loderunner Run Le 02
                            .byte $0c ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunnernner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $07 ; $11 - Loderunner Run Ri 01
                            .byte $8c ; $12 - Loderunner Run Ri 02
                            .byte $6e ; $13 - Loderunner Fall Le
                            .byte $dd ; $14 - Loderunner Fall Ri
                            .byte $61 ; $15 - Loderunner Pole Ri 00
                            .byte $06 ; $16 - Loderunner Pole Ri 01
                            .byte $18 ; $17 - Loderunner Pole Ri 02
                            .byte $61 ; $18 - Loderunner Pole Le 00
                            .byte $18 ; $19 - Loderunner Pole Le 01
                            .byte $06 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $14 ; $20 - Shoot Melt Ground 01
                            .byte $04 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $05 ; $28 - Enemy Run Ri 00
                            .byte $05 ; $29 - Enemy Run Ri 01
                            .byte $05 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $14 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $41 ; $2d - Enemy Pole Ri 00
                            .byte $04 ; $2e - Enemy Pole Ri 01
                            .byte $10 ; $2f - Enemy Pole Ri 02
                            .byte $41 ; $30 - Enemy Pole Le 00
                            .byte $10 ; $31 - Enemy Pole Le 01
                            .byte $04 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $84 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_01_B_02   = *       ; offset to image data row_01 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $c0 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $40 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $40 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_02_B_01   = *       ; offset to image data row_02 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $ff ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $ff ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $14 ; $08 - Level Tile Enemy
                            .byte $07 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $38 ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $38 ; $0d - Loderunner Run Le 02
                            .byte $0f ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $07 ; $11 - Loderunner Run Ri 01
                            .byte $fc ; $12 - Loderunner Run Ri 02
                            .byte $6e ; $13 - Loderunner Fall Le
                            .byte $dd ; $14 - Loderunner Fall Ri
                            .byte $6d ; $15 - Loderunner Pole Ri 00
                            .byte $1e ; $16 - Loderunner Pole Ri 01
                            .byte $1e ; $17 - Loderunner Pole Ri 02
                            .byte $6d ; $18 - Loderunner Pole Le 00
                            .byte $1e ; $19 - Loderunner Pole Le 01
                            .byte $1e ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $14 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $05 ; $28 - Enemy Run Ri 00
                            .byte $05 ; $29 - Enemy Run Ri 01
                            .byte $05 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $14 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $45 ; $2d - Enemy Pole Ri 00
                            .byte $14 ; $2e - Enemy Pole Ri 01
                            .byte $14 ; $2f - Enemy Pole Ri 02
                            .byte $51 ; $30 - Enemy Pole Le 00
                            .byte $14 ; $31 - Enemy Pole Le 01
                            .byte $14 ; $32 - Enemy Pole Le 02
                            .byte $05 ; $33 - Enemy Ladder  00
                            .byte $d4 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_02_B_02   = *       ; offset to image data row_02 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $c0 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $40 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_03_B_01   = *       ; offset to image data row_03 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $3f ; $05 - Level Tile Wall Trap
                            .byte $c3 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $04 ; $08 - Level Tile Enemy
                            .byte $0e ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $1c ; $0b - Loderunner Run Le 00
                            .byte $18 ; $0c - Loderunner Run Le 01
                            .byte $18 ; $0d - Loderunner Run Le 02
                            .byte $4e ; $0e - Loderunner Ladder 00
                            .byte $03 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $06 ; $10 - Loderunner Run Ri 00
                            .byte $06 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $3f ; $13 - Loderunner Fall Le
                            .byte $7f ; $14 - Loderunner Fall Ri
                            .byte $6f ; $15 - Loderunner Pole Ri 00
                            .byte $1c ; $16 - Loderunner Pole Ri 01
                            .byte $0e ; $17 - Loderunner Pole Ri 02
                            .byte $3d ; $18 - Loderunner Pole Le 00
                            .byte $0e ; $19 - Loderunner Pole Le 01
                            .byte $dc ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $08 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $08 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $a8 ; $20 - Shoot Melt Ground 01
                            .byte $94 ; $21 - Shoot Melt Ground 02
                            .byte $04 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $18 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $08 ; $27 - Shoot Melt 01
                            .byte $04 ; $28 - Enemy Run Ri 00
                            .byte $04 ; $29 - Enemy Run Ri 01
                            .byte $04 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $04 ; $2b - Enemy Run Le 01
                            .byte $04 ; $2c - Enemy Run Le 02
                            .byte $45 ; $2d - Enemy Pole Ri 00
                            .byte $14 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $51 ; $30 - Enemy Pole Le 00
                            .byte $14 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $44 ; $33 - Enemy Ladder  00
                            .byte $14 ; $34 - Enemy Ladder  01
                            .byte $15 ; $35 - Enemy Fall Ri
                            .byte $15 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $55 ; $3b - Digit 0
                            .byte $14 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $55 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $55 ; $42 - Digit 7
                            .byte $15 ; $43 - Digit 8
                            .byte $55 ; $44 - Digit 9
                            .byte $2a ; $45 - Char A
                            .byte $a8 ; $46 - Char B
                            .byte $aa ; $47 - Char C
                            .byte $a8 ; $48 - Char D
                            .byte $aa ; $49 - Char E
                            .byte $aa ; $4a - Char F
                            .byte $aa ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $82 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $aa ; $53 - Char O
                            .byte $aa ; $54 - Char P
                            .byte $aa ; $55 - Char Q
                            .byte $aa ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $aa ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $aa ; $5e - Char Z
                            .byte $80 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $02 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $02 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_03_B_02   = *       ; offset to image data row_03 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $80 ; $12 - Loderunner Run Ri 02
                            .byte $80 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $c0 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $40 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $80 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_04_B_01   = *       ; offset to image data row_04 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $37 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $3b ; $0b - Loderunner Run Le 00
                            .byte $1c ; $0c - Loderunner Run Le 01
                            .byte $5e ; $0d - Loderunner Run Le 02
                            .byte $7e ; $0e - Loderunner Ladder 00
                            .byte $0f ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0e ; $10 - Loderunner Run Ri 00
                            .byte $1e ; $11 - Loderunner Run Ri 01
                            .byte $1f ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $3c ; $15 - Loderunner Pole Ri 00
                            .byte $78 ; $16 - Loderunner Pole Ri 01
                            .byte $07 ; $17 - Loderunner Pole Ri 02
                            .byte $0f ; $18 - Loderunner Pole Le 00
                            .byte $07 ; $19 - Loderunner Pole Le 01
                            .byte $78 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $14 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $7e ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $15 ; $28 - Enemy Run Ri 00
                            .byte $14 ; $29 - Enemy Run Ri 01
                            .byte $15 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $05 ; $2b - Enemy Run Le 01
                            .byte $15 ; $2c - Enemy Run Le 02
                            .byte $14 ; $2d - Enemy Pole Ri 00
                            .byte $50 ; $2e - Enemy Pole Ri 01
                            .byte $05 ; $2f - Enemy Pole Ri 02
                            .byte $14 ; $30 - Enemy Pole Le 00
                            .byte $05 ; $31 - Enemy Pole Le 01
                            .byte $50 ; $32 - Enemy Pole Le 02
                            .byte $54 ; $33 - Enemy Ladder  00
                            .byte $15 ; $34 - Enemy Ladder  01
                            .byte $04 ; $35 - Enemy Fall Ri
                            .byte $04 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $14 ; $3c - Digit 1
                            .byte $41 ; $3d - Digit 2
                            .byte $41 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $40 ; $40 - Digit 5
                            .byte $41 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $11 ; $43 - Digit 8
                            .byte $41 ; $44 - Digit 9
                            .byte $22 ; $45 - Char A
                            .byte $88 ; $46 - Char B
                            .byte $82 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a0 ; $49 - Char E
                            .byte $a0 ; $4a - Char F
                            .byte $82 ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $8a ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $a2 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $8a ; $53 - Char O
                            .byte $82 ; $54 - Char P
                            .byte $8a ; $55 - Char Q
                            .byte $82 ; $56 - Char R
                            .byte $82 ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $82 ; $5e - Char Z
                            .byte $a0 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $02 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $0a ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_04_B_02   = *       ; offset to image data row_04 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $c0 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $80 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $80 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $80 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_05_B_01   = *       ; offset to image data row_05 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $ff ; $07 - Level Tile Gold
                            .byte $44 ; $08 - Level Tile Enemy
                            .byte $6c ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $cd ; $0b - Loderunner Run Le 00
                            .byte $3e ; $0c - Loderunner Run Le 01
                            .byte $7b ; $0d - Loderunner Run Le 02
                            .byte $0e ; $0e - Loderunner Ladder 00
                            .byte $5b ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1f ; $10 - Loderunner Run Ri 00
                            .byte $37 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $18 ; $15 - Loderunner Pole Ri 00
                            .byte $d8 ; $16 - Loderunner Pole Ri 01
                            .byte $06 ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $06 ; $19 - Loderunner Pole Le 01
                            .byte $18 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $80 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $15 ; $22 - Shoot Melt Ground 03
                            .byte $04 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $5b ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $44 ; $28 - Enemy Run Ri 00
                            .byte $15 ; $29 - Enemy Run Ri 01
                            .byte $45 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $15 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $10 ; $2d - Enemy Pole Ri 00
                            .byte $50 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $04 ; $30 - Enemy Pole Le 00
                            .byte $05 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $14 ; $34 - Enemy Ladder  01
                            .byte $04 ; $35 - Enemy Fall Ri
                            .byte $04 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $01 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $40 ; $40 - Digit 5
                            .byte $40 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $11 ; $43 - Digit 8
                            .byte $41 ; $44 - Digit 9
                            .byte $22 ; $45 - Char A
                            .byte $88 ; $46 - Char B
                            .byte $80 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a0 ; $49 - Char E
                            .byte $a0 ; $4a - Char F
                            .byte $80 ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $88 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $aa ; $51 - Char M
                            .byte $a2 ; $52 - Char N
                            .byte $8a ; $53 - Char O
                            .byte $82 ; $54 - Char P
                            .byte $8a ; $55 - Char Q
                            .byte $82 ; $56 - Char R
                            .byte $80 ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $82 ; $5e - Char Z
                            .byte $28 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $08 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $28 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_05_B_02   = *       ; offset to image data row_05 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $40 ; $08 - Level Tile Enemy
                            .byte $c0 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $80 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $40 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $c0 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $80 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $40 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $80 ; $27 - Shoot Melt 01
                            .byte $40 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $40 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_06_B_01   = *       ; offset to image data row_06 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $06 ; $08 - Level Tile Enemy
                            .byte $0c ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $0c ; $0b - Loderunner Run Le 00
                            .byte $de ; $0c - Loderunner Run Le 01
                            .byte $18 ; $0d - Loderunner Run Le 02
                            .byte $0e ; $0e - Loderunner Ladder 00
                            .byte $43 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1e ; $10 - Loderunner Run Ri 00
                            .byte $06 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $1e ; $13 - Loderunner Fall Le
                            .byte $1e ; $14 - Loderunner Fall Ri
                            .byte $18 ; $15 - Loderunner Pole Ri 00
                            .byte $18 ; $16 - Loderunner Pole Ri 01
                            .byte $06 ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $06 ; $19 - Loderunner Pole Le 01
                            .byte $18 ; $1a - Loderunner Pole Le 02
                            .byte $08 ; $1b - Shoot Spark 00
                            .byte $80 ; $1c - Shoot Spark 01
                            .byte $88 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $05 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $18 ; $25 - Fire Ri
                            .byte $08 ; $26 - Shoot Melt 00
                            .byte $a0 ; $27 - Shoot Melt 01
                            .byte $0c ; $28 - Enemy Run Ri 00
                            .byte $06 ; $29 - Enemy Run Ri 01
                            .byte $06 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $4c ; $2b - Enemy Run Le 01
                            .byte $0c ; $2c - Enemy Run Le 02
                            .byte $10 ; $2d - Enemy Pole Ri 00
                            .byte $10 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $04 ; $30 - Enemy Pole Le 00
                            .byte $04 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $0e ; $33 - Enemy Ladder  00
                            .byte $1c ; $34 - Enemy Ladder  01
                            .byte $0f ; $35 - Enemy Fall Ri
                            .byte $1e ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $15 ; $3e - Digit 3
                            .byte $55 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $40 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $55 ; $43 - Digit 8
                            .byte $55 ; $44 - Digit 9
                            .byte $aa ; $45 - Char A
                            .byte $aa ; $46 - Char B
                            .byte $80 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a8 ; $49 - Char E
                            .byte $a8 ; $4a - Char F
                            .byte $80 ; $4b - Char G
                            .byte $aa ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $a8 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $aa ; $51 - Char M
                            .byte $aa ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $aa ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $aa ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $28 ; $5c - Char X
                            .byte $aa ; $5d - Char Y
                            .byte $08 ; $5e - Char Z
                            .byte $0a ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $08 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $a0 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_06_B_02   = *       ; offset to image data row_06 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $c0 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $40 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $40 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_07_B_01   = *       ; offset to image data row_07 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $ff ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $c3 ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $0e ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $1c ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $3c ; $0d - Loderunner Run Le 02
                            .byte $1b ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $0f ; $11 - Loderunner Run Ri 01
                            .byte $36 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $78 ; $15 - Loderunner Pole Ri 00
                            .byte $38 ; $16 - Loderunner Pole Ri 01
                            .byte $0e ; $17 - Loderunner Pole Ri 02
                            .byte $07 ; $18 - Loderunner Pole Le 00
                            .byte $07 ; $19 - Loderunner Pole Le 01
                            .byte $1c ; $1a - Loderunner Pole Le 02
                            .byte $02 ; $1b - Shoot Spark 00
                            .byte $20 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $95 ; $23 - Shoot Melt Ground 04
                            .byte $04 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $22 ; $26 - Shoot Melt 00
                            .byte $40 ; $27 - Shoot Melt 01
                            .byte $0e ; $28 - Enemy Run Ri 00
                            .byte $07 ; $29 - Enemy Run Ri 01
                            .byte $0f ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $1c ; $2b - Enemy Run Le 01
                            .byte $1e ; $2c - Enemy Run Le 02
                            .byte $78 ; $2d - Enemy Pole Ri 00
                            .byte $38 ; $2e - Enemy Pole Ri 01
                            .byte $0e ; $2f - Enemy Pole Ri 02
                            .byte $0f ; $30 - Enemy Pole Le 00
                            .byte $0e ; $31 - Enemy Pole Le 01
                            .byte $38 ; $32 - Enemy Pole Le 02
                            .byte $1b ; $33 - Enemy Ladder  00
                            .byte $36 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $14 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $40 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $14 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $82 ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a0 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $8a ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $aa ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $aa ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $a8 ; $56 - Char R
                            .byte $0a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $aa ; $5b - Char W
                            .byte $28 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $28 ; $5e - Char Z
                            .byte $0a ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $20 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $a0 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_07_B_02   = *       ; offset to image data row_07 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $40 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $80 ; $1d - Shoot Spark 02
                            .byte $80 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_08_B_01   = *       ; offset to image data row_08 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $ff ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $7b ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $37 ; $0b - Loderunner Run Le 00
                            .byte $3c ; $0c - Loderunner Run Le 01
                            .byte $66 ; $0d - Loderunner Run Le 02
                            .byte $1b ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0f ; $10 - Loderunner Run Ri 00
                            .byte $19 ; $11 - Loderunner Run Ri 01
                            .byte $76 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $d8 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $20 ; $1b - Shoot Spark 00
                            .byte $0a ; $1c - Shoot Spark 01
                            .byte $80 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $80 ; $23 - Shoot Melt Ground 04
                            .byte $14 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $48 ; $26 - Shoot Melt 00
                            .byte $4a ; $27 - Shoot Melt 01
                            .byte $7b ; $28 - Enemy Run Ri 00
                            .byte $0f ; $29 - Enemy Run Ri 01
                            .byte $19 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $1e ; $2b - Enemy Run Le 01
                            .byte $33 ; $2c - Enemy Run Le 02
                            .byte $d8 ; $2d - Enemy Pole Ri 00
                            .byte $6c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $0d ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $1b ; $33 - Enemy Ladder  00
                            .byte $76 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $14 ; $39 - Enemy Rebirth 00
                            .byte $55 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $40 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $45 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $82 ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a0 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $8a ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $8a ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $a8 ; $56 - Char R
                            .byte $0a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $aa ; $5a - Char V
                            .byte $aa ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $80 ; $5e - Char Z
                            .byte $28 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $20 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $28 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_08_B_02   = *       ; offset to image data row_08 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $40 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $80 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $80 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $c0 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $40 ; $1b - Shoot Spark 00
                            .byte $40 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $80 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $80 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_09_B_01   = *       ; offset to image data row_09 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $ff ; $07 - Level Tile Gold
                            .byte $10 ; $08 - Level Tile Enemy
                            .byte $03 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $30 ; $0b - Loderunner Run Le 00
                            .byte $0e ; $0c - Loderunner Run Le 01
                            .byte $63 ; $0d - Loderunner Run Le 02
                            .byte $18 ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1c ; $10 - Loderunner Run Ri 00
                            .byte $31 ; $11 - Loderunner Run Ri 01
                            .byte $06 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $d8 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $09 ; $1b - Shoot Spark 00
                            .byte $21 ; $1c - Shoot Spark 01
                            .byte $20 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $8a ; $23 - Shoot Melt Ground 04
                            .byte $15 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $50 ; $26 - Shoot Melt 00
                            .byte $11 ; $27 - Shoot Melt 01
                            .byte $03 ; $28 - Enemy Run Ri 00
                            .byte $1c ; $29 - Enemy Run Ri 01
                            .byte $31 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $07 ; $2b - Enemy Run Le 01
                            .byte $31 ; $2c - Enemy Run Le 02
                            .byte $d8 ; $2d - Enemy Pole Ri 00
                            .byte $6c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $0d ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $18 ; $33 - Enemy Ladder  00
                            .byte $06 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $55 ; $39 - Enemy Rebirth 00
                            .byte $55 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $15 ; $3c - Digit 1
                            .byte $45 ; $3d - Digit 2
                            .byte $41 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $45 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $8a ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a2 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $82 ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $8a ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $88 ; $55 - Char Q
                            .byte $a2 ; $56 - Char R
                            .byte $8a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $28 ; $5a - Char V
                            .byte $a2 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $8a ; $5e - Char Z
                            .byte $a0 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $80 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $0a ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_09_B_02   = *       ; offset to image data row_09 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $c0 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $40 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $80 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $80 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $80 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $80 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_0a_B_01   = *       ; offset to image data row_0a byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $00 ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $10 ; $08 - Level Tile Enemy
                            .byte $03 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $30 ; $0b - Loderunner Run Le 00
                            .byte $0c ; $0c - Loderunner Run Le 01
                            .byte $03 ; $0d - Loderunner Run Le 02
                            .byte $38 ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0c ; $10 - Loderunner Run Ri 00
                            .byte $30 ; $11 - Loderunner Run Ri 01
                            .byte $07 ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $b0 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $03 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $01 ; $1b - Shoot Spark 00
                            .byte $09 ; $1c - Shoot Spark 01
                            .byte $02 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $10 ; $26 - Shoot Melt 00
                            .byte $11 ; $27 - Shoot Melt 01
                            .byte $03 ; $28 - Enemy Run Ri 00
                            .byte $0c ; $29 - Enemy Run Ri 01
                            .byte $30 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $06 ; $2b - Enemy Run Le 01
                            .byte $01 ; $2c - Enemy Run Le 02
                            .byte $b0 ; $2d - Enemy Pole Ri 00
                            .byte $0c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $06 ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $38 ; $33 - Enemy Ladder  00
                            .byte $07 ; $34 - Enemy Ladder  01
                            .byte $0c ; $35 - Enemy Fall Ri
                            .byte $06 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $55 ; $3b - Digit 0
                            .byte $15 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $55 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $55 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $8a ; $45 - Char A
                            .byte $aa ; $46 - Char B
                            .byte $aa ; $47 - Char C
                            .byte $a8 ; $48 - Char D
                            .byte $aa ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $aa ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $aa ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $aa ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $aa ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $a2 ; $55 - Char Q
                            .byte $a2 ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $aa ; $59 - Char U
                            .byte $20 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $aa ; $5e - Char Z
                            .byte $80 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $80 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $02 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_0a_B_02   = *       ; offset to image data row_0a byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $00 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $40 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $80 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
A_b0f0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; demo moves table entry layout
; --------------------------------------------------------------------------------------------------------------------- ;
; byte 1 - move direction
;          left  nibble le/ri - offset to TabDemoJoystickMove - 1=le 3=ri 4=fire-ri 5=fire-le 6=none
;          right nibble up/do - offset to TabDemoJoystickMove - 0=up 2=do
; byte 2 - move duration
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoMoves                = *       ; 
TabDemoMovesLevel_01        = *       ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
TabDemoMoveEntry_Len        = * - TabDemoMoves ;
                            .byte $33 ; right- right-
                            .byte $03 ; 
                            .byte $11 ; left-- left-- 
                            .byte $06 ; 
                            .byte $33 ; right- right-
                            .byte $27 ; 
                            .byte $00 ; up---- up----
                            .byte $1d ; 
                            .byte $33 ; right- right-
                            .byte $2d ; 
                            .byte $11 ; left-- left-- 
                            .byte $1f ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
A_b110                      .byte $11 ; left-- left-- 
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $22 ; down-- down--
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $22 ; down-- down--
                            .byte $13 ; 
                            .byte $11 ; left-- left-- 
                            .byte $0b ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $0a ; 
A_b120                      .byte $22 ; down-- down--
                            .byte $1f ; 
                            .byte $00 ; up---- up----
                            .byte $13 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $00 ; up---- up----
                            .byte $33 ; 
                            .byte $33 ; right- right-
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $03 ; 
                            .byte $11 ; left-- left-- 
                            .byte $09 ; 
A_b130                      .byte $00 ; up---- up----
                            .byte $9d ; 
                            .byte $33 ; right- right-
                            .byte $31 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $09 ; 
                            .byte $33 ; right- right-
                            .byte $10 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
A_b140                      .byte $11 ; left-- left-- 
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $10 ; 
                            .byte $33 ; right- right-
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $0e ; 
A_b150                      .byte $33 ; right- right-
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $14 ; 
                            .byte $33 ; right- right-
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $04 ; 
A_b160                      .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $13 ; 
                            .byte $33 ; right- right-
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $10 ; 
                            .byte $33 ; right- right-
                            .byte $08 ; 
A_b170                      .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $21 ; 
                            .byte $33 ; right- right-
                            .byte $03 ; 
                            .byte $22 ; down-- down--
                            .byte $46 ; 
                            .byte $33 ; right- right-
                            .byte $03 ; 
                            .byte $11 ; left-- left-- 
                            .byte $0b ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $07 ; 
A_b180                      .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $05 ; 
                            .byte $33 ; right- right-
                            .byte $01 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $bd ; 
                            .byte $11 ; left-- left-- 
                            .byte $0e ; 
A_b190                      .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $22 ; down-- down--
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $04 ; 
                            .byte $33 ; right- right-
                            .byte $08 ; 
                            .byte $00 ; up---- up----
                            .byte $04 ; 
                            .byte $33 ; right- right-
                            .byte $05 ; 
                            .byte $00 ; up---- up----
                            .byte $7e ; 
A_b1a0                      .byte $11 ; left-- left-- 
                            .byte $22 ; 
                            .byte $00 ; up---- up----
                            .byte $0e ; 
                            .byte $11 ; left-- left-- 
                            .byte $19 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $05 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
A_b1b0                      .byte $11 ; left-- left-- 
                            .byte $07 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $22 ; down-- down--
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $00 ; up---- up----
                            .byte $0e ; 
                            .byte $11 ; left-- left-- 
                            .byte $03 ; 
                            .byte $33 ; right- right-
                            .byte $1e ; 
A_b1c0                      .byte $00 ; up---- up----
                            .byte $47 ; 
                            .byte $11 ; left-- left-- 
                            .byte $2a ; 
                            .byte $00 ; up---- up----
                            .byte $07 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $36 ; 
                            .byte $33 ; right- right-
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $03 ; 
A_b1d0                      .byte $33 ; right- right-
                            .byte $2c ; 
                            .byte $00 ; up---- up----
                            .byte $0d ; 
                            .byte $33 ; right- right-
                            .byte $11 ; 
                            .byte $11 ; left-- left-- 
                            .byte $04 ; 
                            .byte $00 ; up---- up----
                            .byte $0b ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $22 ; down-- down--
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
A_b1e0                      .byte $33 ; right- right-
                            .byte $0d ; 
                            .byte $00 ; up---- up----
                            .byte $03 ; 
                            .byte $33 ; right- right-
                            .byte $17 ; 
                            .byte $11 ; left-- left-- 
                            .byte $0f ; 
                            .byte $00 ; up---- up----
                            .byte $03 ; 
                            .byte $11 ; left-- left-- 
                            .byte $21 ; 
                            .byte $00 ; up---- up----
                            .byte $0f ; 
                            .byte $33 ; right- right-
                            .byte $12 ; 
A_b1f0                      .byte $00 ; up---- up----
                            .byte $0f ; 
                            .byte $33 ; right- right-
                            .byte $0a ; 
                            .byte $00 ; up---- up----
                            .byte $5a ; 
                            .byte $33 ; right- right-
                            .byte $19 ; 
                            .byte $00 ; up---- up----
                            .byte $0a ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $33 ; right- right-
                            .byte $03 ; 
A_b200                      .byte $11 ; left-- left-- 
                            .byte $06 ; 
                            .byte $33 ; right- right-
                            .byte $22 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $1f ; 
A_b210                      .byte $00 ; up---- up----
                            .byte $1a ; 
                            .byte $33 ; right- right-
                            .byte $22 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $33 ; right- right-
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $11 ; left-- left-- 
                            .byte $15 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $7b ; 
A_b220                      .byte $10 ; left-- ------
                            .byte $1f ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $30 ; right- up----
                            .byte $09 ; 
                            .byte $36 ; right- ------
                            .byte $33 ; 
                            .byte $66 ; ------ ------
                            .byte $04 ; 
                            .byte $10 ; left-- ------
                            .byte $09 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $12 ; left-- down--
                            .byte $01 ; 
A_b230                      .byte $62 ; ------ down--
                            .byte $0c ; 
                            .byte $32 ; right- down--
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $32 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
A_b240                      .byte $10 ; left-- ------
                            .byte $2c ; 
                            .byte $60 ; ------ up----
                            .byte $04 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $0a ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
A_b250                      .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $55 ; fi_le- fi_le- 
                            .byte $01 ; 
A_b260                      .byte $66 ; ------ ------
                            .byte $4c ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $10 ; left-- ------
                            .byte $15 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $10 ; left-- ------
                            .byte $2f ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $12 ; left-- down--
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $12 ; 
A_b270                      .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $2d ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $10 ; left-- ------
                            .byte $1c ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
A_b280                      .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $32 ; right- down--
                            .byte $15 ; 
                            .byte $36 ; right- ------
                            .byte $0b ; 
                            .byte $30 ; right- up----
                            .byte $0b ; 
                            .byte $60 ; ------ up----
                            .byte $0c ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $62 ; ------ down--
                            .byte $0d ; 
A_b290                      .byte $12 ; left-- down--
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $0d ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $20 ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $30 ; right- up----
                            .byte $17 ; 
                            .byte $36 ; right- ------
                            .byte $1e ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
A_b2a0                      .byte $36 ; right- ------
                            .byte $2f ; 
                            .byte $30 ; right- up----
                            .byte $08 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $10 ; left-- ------
                            .byte $22 ; 
                            .byte $16 ; left-- ------
                            .byte $1b ; 
                            .byte $66 ; ------ ------
                            .byte $26 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $07 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
A_b2b0                      .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $1d ; 
                            .byte $16 ; left-- ------
                            .byte $02 ; 
                            .byte $10 ; left-- ------
                            .byte $85 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $32 ; right- down--
                            .byte $0f ; 
A_b2c0                      .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $0c ; 
                            .byte $36 ; right- ------
                            .byte $20 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $0a ; 
                            .byte $60 ; ------ up----
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
A_b2d0                      .byte $30 ; right- up----
                            .byte $05 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- ------
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
A_b2e0                      .byte $30 ; right- up----
                            .byte $04 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- ------
                            .byte $02 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
A_b2f0                      .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $10 ; left-- ------
                            .byte $02 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $07 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
A_b300                      .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $10 ; left-- ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- ------
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $0a ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
A_b310                      .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $10 ; left-- ------
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $04 ; 
                            .byte $10 ; left-- ------
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $05 ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $07 ; 
                            .byte $66 ; ------ ------
                            .byte $16 ; 
A_b320                      .byte $36 ; right- ------
                            .byte $02 ; 
                            .byte $66 ; ------ ------
                            .byte $33 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $05 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
A_b330                      .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $a9 ; 
                            .byte $62 ; ------ down--
                            .byte $0c ; 
                            .byte $66 ; ------ ------
                            .byte $07 ; 
                            .byte $60 ; ------ up----
                            .byte $0f ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
A_b340                      .byte $66 ; ------ ------
                            .byte $18 ; 
                            .byte $16 ; left-- ------
                            .byte $2a ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
A_b350                      .byte $30 ; right- up----
                            .byte $1b ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $18 ; 
                            .byte $36 ; right- ------
                            .byte $0f ; 
                            .byte $66 ; ------ ------
                            .byte $08 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $38 ; 
A_b360                      .byte $30 ; right- up----
                            .byte $0e ; 
                            .byte $66 ; ------ ------
                            .byte $11 ; 
                            .byte $60 ; ------ up----
                            .byte $04 ; 
                            .byte $66 ; ------ ------
                            .byte $49 ; 
                            .byte $37 ; right- ------
                            .byte $03 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
GarbageArea_02              .include "../inc/CL_Garbage_02.asm" ; old memory remnants - not referenced
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel             = *      ; 
TabDemoDataLevel_01          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $09, $81, $88, $18, $00, $00, $07, $00, $70, $00, $00, $00, $00, $00 ; 
                            .byte $11, $41, $44, $14, $13, $11, $11, $11, $11, $61, $11, $11, $01, $00 ; 
                            .byte $00, $01, $00, $10, $13, $00, $00, $04, $00, $60, $00, $04, $40, $00 ; 
                            .byte $00, $07, $00, $10, $13, $13, $11, $16, $11, $71, $11, $10, $01, $11 ; 
                            .byte $11, $01, $00, $10, $13, $13, $17, $16, $11, $11, $17, $01, $11, $10 ; 
                            .byte $33, $00, $00, $10, $13, $13, $10, $06, $00, $10, $71, $11, $10, $01 ; 
                            .byte $33, $00, $00, $30, $13, $13, $11, $06, $00, $00, $11, $17, $01, $11 ; 
                            .byte $33, $00, $00, $00, $00, $13, $00, $06, $00, $00, $10, $71, $11, $10 ; 
                            .byte $11, $01, $00, $10, $11, $13, $00, $06, $00, $00, $00, $11, $17, $01 ; 
                            .byte $22, $22, $22, $22, $22, $11, $16, $11, $11, $11, $03, $10, $71, $11 ; 
                            .byte $00, $00, $00, $00, $00, $00, $16, $37, $01, $00, $03, $00, $11, $10 ; 
                            .byte $07, $00, $00, $00, $00, $31, $16, $00, $01, $00, $03, $00, $00, $00 ; 
                            .byte $11, $11, $11, $11, $31, $11, $11, $22, $11, $11, $11, $11, $13, $31 ; 
                            .byte $00, $00, $00, $00, $30, $00, $00, $00, $00, $00, $01, $00, $10, $30 ; 
                            .byte $07, $00, $00, $00, $30, $00, $00, $53, $03, $70, $11, $11, $71, $30 ; 
                            .byte $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $51, $13 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r"                       ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel_02          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $09, $81, $88, $18, $00, $00, $07, $00, $70, $00, $00, $00, $00, $00 ; 
                            .byte $11, $41, $44, $14, $13, $11, $11, $11, $11, $61, $11, $11, $01, $00 ; 
                            .byte $00, $01, $00, $10, $13, $00, $00, $04, $00, $60, $00, $04, $40, $00 ; 
                            .byte $00, $07, $00, $10, $13, $13, $11, $16, $11, $71, $11, $10, $01, $11 ; 
                            .byte $11, $01, $00, $10, $13, $13, $17, $16, $11, $11, $17, $01, $11, $10 ; 
                            .byte $33, $00, $00, $10, $13, $13, $10, $06, $00, $10, $71, $11, $10, $01 ; 
                            .byte $33, $00, $00, $30, $13, $13, $11, $06, $00, $00, $11, $17, $01, $11 ; 
                            .byte $33, $00, $00, $00, $00, $13, $00, $06, $00, $00, $10, $71, $11, $10 ; 
                            .byte $11, $01, $00, $10, $11, $13, $00, $06, $00, $00, $00, $11, $17, $01 ; 
                            .byte $22, $22, $22, $22, $22, $11, $16, $11, $11, $11, $03, $10, $71, $11 ; 
                            .byte $00, $00, $00, $00, $00, $00, $16, $37, $01, $00, $03, $00, $11, $10 ; 
                            .byte $07, $00, $00, $00, $00, $31, $16, $00, $01, $00, $03, $00, $00, $00 ; 
                            .byte $11, $11, $11, $11, $31, $11, $11, $22, $11, $11, $11, $11, $13, $31 ; 
                            .byte $00, $00, $00, $00, $30, $00, $00, $00, $00, $00, $01, $00, $10, $30 ; 
                            .byte $07, $00, $00, $00, $30, $00, $00, $53, $03, $70, $11, $11, $71, $30 ; 
                            .byte $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $51, $13 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "g" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r"                       ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel_03          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $00, $00, $00, $30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $80, $07, $00, $30, $00, $00, $00, $00, $00, $00, $00, $00, $70, $08 ; 
                            .byte $13, $81, $07, $30, $00, $00, $00, $00, $00, $00, $00, $70, $18, $31 ; 
                            .byte $03, $10, $01, $30, $11, $11, $36, $11, $11, $31, $00, $10, $01, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $30, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $30, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $00, $00, $09, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; 
                            .byte $03, $00, $30, $11, $11, $11, $11, $11, $11, $11, $11, $03, $00, $30 ; 
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleMaxNum             .byte TabJingleDataPtr_Len ; 
TabJingleHeight_Min         .byte $02 ; 
TabJingleHeight_Max         .byte $0c ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleDataPtr            = *       ; 
TabJingleDataPtr_Lo         = * + $00 ;
TabJingleDataPtr_Hi         = * + $01 ;
                            .word TabJingleData_00 ; $00
                            .word TabJingleData_01 ; $01
                            .word TabJingleData_02 ; $02
                            .word TabJingleData_03 ; $03
                            .word TabJingleData_04 ; $04
                            .word TabJingleData_05 ; $05
                            .word TabJingleData_06 ; $06
                            .word TabJingleData_07 ; $07
                            .word TabJingleData_08 ; $08
                            .word TabJingleData_09 ; $09
TabJingleDataPtr_Len        = (* - TabJingleDataPtr) / 2 - 1
; --------------------------------------------------------------------------------------------------------------------- ;
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
; --------------------------------------------------------------------------------------------------------------------- ;
TabFreqCtrlData_Lo          = *       ; 
                            .byte $00 ; 
                            .byte $e1 ; 
                            .byte $68 ; 
                            .byte $f7 ; 
                            .byte $8f ; 
                            .byte $30 ; 
                            .byte $da ; 
                            .byte $8f ; 
                            .byte $4e ; 
                            .byte $18 ; 
                            .byte $ef ; 
                            .byte $d2 ; 
                            .byte $c3 ; 
                            .byte $c3 ; 
                            .byte $d1 ; 
                            .byte $ef ; 
                            .byte $1f ; 
                            .byte $60 ; 
                            .byte $b5 ; 
                            .byte $1e ; 
                            .byte $9c ; 
                            .byte $31 ; 
                            .byte $df ; 
                            .byte $a5 ; 
                            .byte $87 ; 
                            .byte $86 ; 
                            .byte $a2 ; 
                            .byte $df ; 
                            .byte $3e ; 
                            .byte $c1 ; 
                            .byte $6b ; 
                            .byte $3c ; 
                            .byte $39 ; 
                            .byte $63 ; 
                            .byte $be ; 
                            .byte $4b ; 
                            .byte $0f ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFreqCtrlData_Hi          = *       ; 
                            .byte $00 ; 
                            .byte $08 ; 
                            .byte $09 ; 
                            .byte $09 ; 
                            .byte $0a ; 
                            .byte $0b ; 
                            .byte $0b ; 
                            .byte $0c ; 
                            .byte $0d ; 
                            .byte $0e ; 
                            .byte $0e ; 
                            .byte $0f ; 
                            .byte $10 ; 
                            .byte $11 ; 
                            .byte $12 ; 
                            .byte $13 ; 
                            .byte $15 ; 
                            .byte $16 ; 
                            .byte $17 ; 
                            .byte $19 ; 
                            .byte $1a ; 
                            .byte $1c ; 
                            .byte $1d ; 
                            .byte $1f ; 
                            .byte $21 ; 
                            .byte $23 ; 
                            .byte $25 ; 
                            .byte $27 ; 
                            .byte $2a ; 
                            .byte $2c ; 
                            .byte $2f ; 
                            .byte $32 ; 
                            .byte $35 ; 
                            .byte $38 ; 
                            .byte $3b ; 
                            .byte $3f ; 
                            .byte $43 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_09            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
TabJingleDataBlock_Len      = * - TabJingleData_09
                            
                            .byte $08 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_05            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $c0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $14 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_02            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $05 ; playtime
                            .byte $02 ; tune voice2
                            .byte $1c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $04 ; tune voice2
                            .byte $17 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $05 ; tune voice2
                            .byte $15 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $07 ; tune voice2
                            .byte $13 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $09 ; tune voice2
                            .byte $11 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $0b ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $0c ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0b ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $11 ; tune voice2
                            .byte $09 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $13 ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $15 ; tune voice2
                            .byte $05 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $17 ; tune voice2
                            .byte $04 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $1c ; tune voice2
                            .byte $02 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_06            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $c0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $06 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $08 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $11 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_08            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol

                            .byte $03 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol

                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0b ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_03            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $50 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_00            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $11 ; tune voice2
                            .byte $0e ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $11 ; tune voice2
                            .byte $0e ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $90 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $90 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $60 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $50 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $30 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $20 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_04            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_07            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $16 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $14 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0d ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_01            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $1f ; tune voice2
                            .byte $0f ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $1f ; tune voice2
                            .byte $0f ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_0a            = *       ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
GarbageArea_03              .include "../inc/CL_Garbage_03.asm" ; old memory remnants - not referenced
                            
; --------------------------------------------------------------------------------------------------------------------- ;
